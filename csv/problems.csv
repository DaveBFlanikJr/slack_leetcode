number,problem_name,code
0001,two-sum,"# frozen_string_literal: true

# 1. Two Sum
# https://leetcode.com/problems/two-sum

# @param {Integer[]} nums
# @param {Integer} target
# @return {Integer[]}
def two_sum(nums, target)
  h = {}
  (0..nums.size - 1).each do |i|
    complement = target - nums[i]

    return [i, h[complement]] if h.key?(complement)

    h[nums[i]] = i
  end
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_two_sum < Test::Unit::TestCase
  def test_
    assert_equal [0, 1].sort, two_sum([2, 7, 11, 15], 9).sort
    assert_equal [1, 2].sort, two_sum([3, 2, 4], 6).sort
    assert_equal [0, 1].sort, two_sum([3, 3], 6).sort
  end
end
"
0002,add-two-numbers,"# frozen_string_literal: true

# 2. Add Two Numbers
# https://leetcode.com/problems/add-two-numbers

# Definition for singly-linked list.
# class ListNode
#   attr_accessor :val, :next

#   def initialize(val = 0, _next = nil)
#     @val = val
#     @next = _next
#   end
# end
# @param {ListNode} l1
# @param {ListNode} l2
# @return {ListNode}
def add_two_numbers(l1, l2, carry = 0)
  return nil if l1.nil? && l2.nil? && carry.zero?

  sum = (l1&.val || 0) + (l2&.val || 0) + carry
  ListNode.new(sum % 10).tap do |l3|
    l3.next = add_two_numbers(l1&.next, l2&.next, sum / 10)
  end
end

# **************** #
#       TEST       #
# **************** #

# TODO: Write tests
"
0003,longest-substring-without-repeating-characters,"# frozen_string_literal: true

# 3. Longest Substring Without Repeating Characters
# https://leetcode.com/problems/longest-substring-without-repeating-characters

# @param {String} s
# @return {Integer}
def length_of_longest_substring(s)
  max_len = 0
  i = 0
  h = {}

  (0...s.length).each do |j|
    i = [h[s[j]], i].max if h[s[j]].to_i.positive?
    max_len = [max_len, j - i + 1].max
    h[s[j]] = j + 1
  end

  max_len
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_length_of_longest_substring < Test::Unit::TestCase
  def test_
    assert_equal 3, length_of_longest_substring(""abcabcbb"")
    assert_equal 1, length_of_longest_substring(""bbbbb"")
    assert_equal 3, length_of_longest_substring(""pwwkew"")
  end
end
"
0004,median-of-two-sorted-arrays,"# frozen_string_literal: true

# 4. Median of Two Sorted Arrays
# https://leetcode.com/problems/median-of-two-sorted-arrays

# @param {Integer[]} nums1
# @param {Integer[]} nums2
# @return {Float}
def find_median_sorted_arrays(nums1, nums2)
  sorted = (nums1 + nums2).sort
  len = sorted.length
  (sorted[(len - 1) / 2] + sorted[len / 2]) / 2.0
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_find_median_sorted_arrays < Test::Unit::TestCase
  def test_
    assert_equal 2.0, find_median_sorted_arrays([1, 3], [2])
    assert_equal 2.5, find_median_sorted_arrays([1, 2], [3, 4])
  end
end
"
0005,longest-palindromic-substring,"# frozen_string_literal: true

# 5. Longest Palindromic Substring
# https://leetcode.com/problems/longest-palindromic-substring

=begin

Given a string s, return the longest palindromic substring in s.

# Constraints:

* 1 <= s.length <= 1000
* s consist of only digits and English letters.

=end

# @param {String} s
# @return {String}
def longest_palindrome(s)
  return """" if s.empty?

  chars = s.chars.zip(s.size.times.map { ""|"" }).flatten.unshift(""|"")
  n = chars.size

  p_len = Array.new(3, n)
  p_len[0] = 0
  p_len[1] = 1

  max_len, max_len_pos = 0, 0

  center = 1
  right = 2

  2.step(n - 1).each do |i|   # want to use enumerator; n.times.drop(2) makes (n-2) length array
    mirror = 2 * center - i
    diff = right - i

    expand = false

    if 0 < diff
      len = p_len[mirror]

      if len < diff
        p_len[i] = len

      elsif len == diff && i == n - 1
        p_len[i] = len

      elsif len == diff && i < n - 1
        p_len[i] = len
        expand = true

      elsif diff < len
        p_len[i] = diff
        expand = true

      end
    else
      p_len[i] = 0
      expand = true
    end

    if expand
      while (i + p_len[i]) < n && 0 < (i - p_len[i]) && (not_boundary_char(p_len, i) || same_char?(chars, p_len, i))
        p_len[i] += 1
      end
    end

    if max_len < p_len[i]
      max_len = p_len[i]
      max_len_pos = i
    end

    if i < i + p_len[i]
      center = i
      right = i + p_len[i]
    end
  end

  first = (max_len_pos - max_len) / 2
  last = first + max_len - 1
  s[first..last]
end

def not_boundary_char(p_len, i)
  (i + p_len[i] + 1) % 2 == 0
end

def same_char?(chars, p_len, i)
  chars[i - p_len[i] - 1] == chars[i + p_len[i] + 1]
end

# @param {String} s
# @return {String}
def longest_palindrome1(s)
  arr = s.downcase.chars
  s.length.downto(1) do |n|
    ana = arr.each_cons(n).find { |b| b == b.reverse }
    return ana.join if ana
  end
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_longest_palindrome < Test::Unit::TestCase
  def test_
    assert_equal ""bab"", longest_palindrome(""babad"")
    assert_equal ""bb"", longest_palindrome(""cbbd"")
    assert_equal ""SQQSYYSQQS"", longest_palindrome(""SQQSYYSQQS"")
  end
end

# ********************#
#     Benchmark       #
# ********************#

require ""benchmark""

s = ""anugnxshgonmqydttcvmtsoaprxnhpmpovdolbidqiyqubirkvhwppcdyeouvgedccipsvnobrccbndzjdbgxkzdbcjsjjovnhpnbkurxqfupiprpbiwqdnwaqvjbqoaqzkqgdxkfczdkznqxvupdmnyiidqpnbvgjraszbvvztpapxmomnghfaywkzlrupvjpcvascgvstqmvuveiiixjmdofdwyvhgkydrnfuojhzulhobyhtsxmcovwmamjwljioevhafdlpjpmqstguqhrhvsdvinphejfbdvrvabthpyyphyqharjvzriosrdnwmaxtgriivdqlmugtagvsoylqfwhjpmjxcysfujdvcqovxabjdbvyvembfpahvyoybdhweikcgnzrdqlzusgoobysfmlzifwjzlazuepimhbgkrfimmemhayxeqxynewcnynmgyjcwrpqnayvxoebgyjusppfpsfeonfwnbsdonucaipoafavmlrrlplnnbsaghbawooabsjndqnvruuwvllpvvhuepmqtprgktnwxmflmmbifbbsfthbeafseqrgwnwjxkkcqgbucwusjdipxuekanzwimuizqynaxrvicyzjhulqjshtsqswehnozehmbsdmacciflcgsrlyhjukpvosptmsjfteoimtewkrivdllqiotvtrubgkfcacvgqzxjmhmmqlikrtfrurltgtcreafcgisjpvasiwmhcofqkcteudgjoqqmtucnwcocsoiqtfuoazxdayricnmwcg""
Benchmark.bm do |x|
  x.report(""longest_palindrome: "") { longest_palindrome(s) }
  x.report(""longest_palindrome1: "") { longest_palindrome1(s) }
end

# user     system      total        real
# longest_palindrome:   0.007118   0.000000   0.007118 (  0.007215)
# longest_palindrome1:   0.433382   0.055217   0.488599 (  0.512605)
"
0006,zigzag-conversion,"# frozen_string_literal: true

# 6. Verifying an Alien Dictionary
# https://leetcode.com/problems/zigzag-conversion

# @param {String} s
# @param {Integer} num_rows
# @return {String}
def convert(s, num_rows)
  return s if s.size == 1 || num_rows == 1

  str = s.chars
  res = Array.new(num_rows) { [] }

  j = 0
  while str.any?
    if num_rows == 1 || (j % (num_rows - 1)).zero?
      num_rows.times { |i| res[i][j] = str.shift }
    else
      res[num_rows - (j % (num_rows - 1)) - 1][j] = str.shift
    end

    j += 1
  end

  res.flatten.compact.join
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_convert < Test::Unit::TestCase
  def test_
    assert_equal ""PAHNAPLSIIGYIR"", convert(""PAYPALISHIRING"", 3)
    assert_equal ""PINALSIGYAHRPI"", convert(""PAYPALISHIRING"", 4)
    assert_equal ""A"", convert(""A"", 1)
  end
end
"
0007,reverse-integer,"# frozen_string_literal: true

# 7. Reverse Integer
# https://leetcode.com/problems/reverse-integer

=begin

Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.

Assume the environment does not allow you to store 64-bit integers (signed or unsigned).

Constraints:

* -231 <= x <= 231 - 1

=end

# @param {Integer} x
# @return {Integer}
def reverse(x)
  if x.negative?
    x = (x.to_s.reverse.to_i * -1)
  else
    x = x.to_s.reverse.to_i
  end

  x.bit_length > 31 ? 0 : x
end

# @param {Integer} x
# @return {Integer}
def reverse1(x)
  max = 2**31 - 1
  min = -2**31

  neg = x.negative?
  x *= -1 if neg

  rev = 0
  while x != 0
    pop = x.remainder(10)
    x /= 10
    rev = rev * 10 + pop
  end

  return 0 if rev < min || max < rev

  neg ? rev * -1 : rev
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_reverse < Test::Unit::TestCase
  def test_
    assert_equal 321, reverse(123)
    assert_equal(-321, reverse(-123))
    assert_equal 21, reverse(120)
  end
end

# ********************#
#     Benchmark       #
# ********************#

require ""benchmark""

x = 12320238384812489
Benchmark.bm do |bm|
  bm.report(""reverse: "") { reverse(x) }
  bm.report(""reverse1: "") { reverse1(x) }
end

# user     system      total        real
# reverse:   0.000012   0.000005   0.000017 (  0.000012)
# reverse1:   0.000013   0.000005   0.000018 (  0.000016)
"
0008,string-to-integer-atoi,"# frozen_string_literal: true

# 8. String to Integer (atoi)
# URL:https://leetcode.com/problems/string-to-integer-atoi

=begin

Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function).

The algorithm for myAtoi(string s) is as follows:

Read in and ignore any leading whitespace.
Check if the next character (if not already at the end of the string) is '-' or '+'. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.
Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.
Convert these digits into an integer (i.e. ""123"" -> 123, ""0032"" -> 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2).
If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -231 should be clamped to -231, and integers greater than 231 - 1 should be clamped to 231 - 1.
Return the integer as the final result.

### Note:

* Only the space character ' ' is considered a whitespace character.
* Do not ignore any characters other than the leading whitespace or the rest of the string after the digits.

### Constraints:

* 0 <= s.length <= 200
* s consists of English letters (lower-case and upper-case), digits (0-9), ' ', '+', '-', and '.'.

=end

# @param {String} s
# @return {Integer}
def my_atoi(s)
  i = s.scan(/^[-+\s]*\d+/).first.to_i
  i >= 0 ? [2147483647, i].min : [-2147483648, i].max
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_my_atoi < Test::Unit::TestCase
  def test_
    assert_equal 42, my_atoi(""42"")
    assert_equal(-42, my_atoi(""   -42""))
    assert_equal 4193, my_atoi(""4193 with words"")
  end
end
"
0009,palindrome-number,"# frozen_string_literal: true

# 9. Palindrome Number
# https://leetcode.com/problems/palindrome-number

# @param {Integer} x
# @return {Boolean}
def is_palindrome(x)
  return false if x.negative?

  x.digits.join.to_i == x
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_is_palindrome < Test::Unit::TestCase
  def test_
    assert_equal true, is_palindrome(121)
    assert_equal false, is_palindrome(-121)
    assert_equal false, is_palindrome(10)
  end
end
"
0010,regular-expression-matching,"# frozen_string_literal: true

# 10. Regular Expression Matching
# https://leetcode.com/problems/regular-expression-matching

# @param {String} s
# @param {String} p
# @return {Boolean}
def is_match(s, p)
  s = s.bytes
  p = p.bytes
  dp = Array.new(s.length + 1) { Array.new(p.length + 1, false) }
  m = s.length
  n = p.length
  dp[m][n] = true
  m.downto(0) do |i|
    (n - 1).downto(0) do |j|
      first = i < m && (s[i] == p[j] || p[j] == 46)
      dp[i][j] = if p[j + 1] == 42
        dp[i][j + 2] || (first && dp[i + 1][j])
      else
        first && dp[i + 1][j + 1]
      end
    end
  end
  dp[0][0]
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_is_match < Test::Unit::TestCase
  def test_
    assert_equal false, is_match(""aa"", ""a"")
    assert_equal true, is_match(""aa"", ""a*"")
    assert_equal true, is_match(""ab"", "".*"")
  end
end
"
0011,container-with-most-water,"# frozen_string_literal: true

# 11. Container With Most Water
# https://leetcode.com/problems/container-with-most-water/
# Medium

=begin

You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).

Find two lines that together with the x-axis form a container, such that the container contains the most water.

Return the maximum amount of water a container can store.

Notice that you may not slant the container.

### Constraints:

* n == height.length
* 2 <= n <= 105
* 0 <= height[i] <= 104

=end

# @param {Integer[]} height
# @return {Integer}
def max_area1(height)
  max_area = 0
  left, right = 0, height.size - 1

  while left < right
    min_h = [height[left], height[right]].min
    max_area = [max_area, min_h * (right - left)].max
    if height[left] < height[right]
      left += 1
    else
      right -= 1
    end
  end
  max_area
end

# @param {Integer[]} height
# @return {Integer}
def max_area2(height)
  max_area = 0
  height.size.times do |i|
    (i + 1..height.size - 1).each do |j|
      min_h = [height[i], height[j]].min
      max_area = [max_area, min_h * (j - i)].max
    end
  end
  max_area
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_max_area < Test::Unit::TestCase
  def test_
    assert_equal 49, max_area1([1, 8, 6, 2, 5, 4, 8, 3, 7])
    assert_equal 1, max_area1([1, 1])

    assert_equal 49, max_area2([1, 8, 6, 2, 5, 4, 8, 3, 7])
    assert_equal 1, max_area2([1, 1])
  end
end


# ********************#
#     Benchmark       #
# ********************#

require ""benchmark""

height = [1, 8, 6, 2, 5, 4, 8, 3, 7]
Benchmark.bm do |x|
  x.report(""max_area1: "") { max_area1(height) }
  x.report(""max_area2: "") { max_area2(height) }
end

# user     system      total        real
# max_area1:   0.000019   0.000004   0.000023 (  0.000018)
# max_area2:   0.000025   0.000000   0.000025 (  0.000025)
"
0012,integer-to-roman,"# frozen_string_literal: true

# 12. Integer to Roman
# https://leetcode.com/problems/integer-to-roman

=begin

Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
For example, 2 is written as II in Roman numeral, just two one's added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

* I can be placed before V (5) and X (10) to make 4 and 9.
* X can be placed before L (50) and C (100) to make 40 and 90.
* C can be placed before D (500) and M (1000) to make 400 and 900.
Given an integer, convert it to a roman numeral.

### Constraints:

* 1 <= num <= 3999

=end

# @param {Integer} num
# @return {String}
def int_to_roman(num)
  digits_to_roman = {
    1000 => ""M"",
    900 => ""CM"",
    500 => ""D"",
    400 => ""CD"",
    100 => ""C"",
    90 => ""XC"",
    50 => ""L"",
    40 => ""XL"",
    10 => ""X"",
    9 => ""IX"",
    5 => ""V"",
    4 => ""IV"",
    1 => ""I""
  }
  roman = """"
  digits_to_roman.each { |d, r|
    if num >= d
      times = num / d
      roman += r * times
      num -= d * times
    end
  }
  roman
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_int_to_roman < Test::Unit::TestCase
  def test_
    assert_equal ""III"", int_to_roman(3)
    assert_equal ""LVIII"", int_to_roman(58)
    assert_equal ""MCMXCIV"", int_to_roman(1994)
  end
end
"
0013,roman-to-integer,"# frozen_string_literal: true

# 13. Roman to Integer
# https://leetcode.com/problems/roman-to-integer

ROMAN_VALUES = {
  ""I"" => 1,
  ""V"" => 5,
  ""X"" => 10,
  ""L"" => 50,
  ""C"" => 100,
  ""D"" => 500,
  ""M"" => 1000
}.freeze

# @param {String} s
# @return {Integer}
def roman_to_int(s)
  sum = 0
  v = 0
  s.chars.each_with_index do |c, i|
    if s[i + 1] && ROMAN_VALUES[c] < ROMAN_VALUES[s[i + 1]]
      v = ROMAN_VALUES[c]
    else
      sum += ROMAN_VALUES[c] - v
      v = 0
    end
  end

  sum
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_roman_to_int < Test::Unit::TestCase
  def test_
    assert_equal 3, roman_to_int(""III"")
    assert_equal 58, roman_to_int(""LVIII"")
    assert_equal 1994, roman_to_int(""MCMXCIV"")
  end
end
"
0014,longest-common-prefix,"# frozen_string_literal: true

# 14. Longest Common Prefix
# https://leetcode.com/problems/longest-common-prefix
# Easy

# @param {String[]} strs
# @return {String}
def longest_common_prefix(strs)
  return """" if strs.empty?

  prefix = strs[0]
  strs[1..].each do |str|
    loop do
      break if str.start_with?(prefix)

      prefix = prefix[0...prefix.length - 1]
      return """" if prefix.empty?
    end
  end

  prefix
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_longest_common_prefix < Test::Unit::TestCase
  def test_
    assert_equal ""fl"", longest_common_prefix(%w[flower flow flight])
    assert_equal """", longest_common_prefix(%w[dog racecar car])
  end
end
"
0015,3sum,"# frozen_string_literal: true

# 15. 3Sum
# https://leetcode.com/problems/3sum
# Medium

=begin
Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.

Notice that the solution set must not contain duplicate triplets.

Example 1:
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
Explanation:
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.
The distinct triplets are [-1,0,1] and [-1,-1,2].
Notice that the order of the output and the order of the triplets does not matter.

Example 2:
Input: nums = [0,1,1]
Output: []
Explanation: The only possible triplet does not sum up to 0.

Example 3:
Input: nums = [0,0,0]
Output: [[0,0,0]]
Explanation: The only possible triplet sums up to 0.

Constraints:
3 <= nums.length <= 3000
-105 <= nums[i] <= 105
=end

# @param {Integer[]} nums
# @return {Integer[][]}
def three_sum(nums)
  nums.sort!
  triplets = []
  n = nums.length - 1

  (0..n - 2).each do |i|
    left = i + 1
    right = n
    target = -nums[i]

    next if i.positive? && nums[i] == nums[i - 1]

    while left < right
      sum = nums[left] + nums[right]
      if sum < target
        left += 1
      elsif sum > target
        right -= 1
      elsif sum == target
        triplets << [nums[i], nums[left], nums[right]]
        left += 1
        right -= 1

        left += 1 while left < right && nums[left] == nums[left - 1]
      end
    end
  end

  triplets.uniq
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_three_sum < Test::Unit::TestCase
  def test_
    assert_equal [[-1, -1, 2], [-1, 0, 1]], three_sum([-1, 0, 1, 2, -1, -4])
    assert_equal [], three_sum([0, 1, 1])
    assert_equal [[0, 0, 0]], three_sum([0, 0, 0])
  end
end
"
0016,3sum-closest,"# frozen_string_literal: true

# 16. 3Sum Closest
# https://leetcode.com/problems/3sum-closest/
# Medium

=begin
Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.

Return the sum of the three integers.

You may assume that each input would have exactly one solution.

Example 1:
Input: nums = [-1,2,1,-4], target = 1
Output: 2
Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).

Example 2:
Input: nums = [0,0,0], target = 1
Output: 0
Explanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0).

Constraints:
* 3 <= nums.length <= 500
* -1000 <= nums[i] <= 1000
* -104 <= target <= 104
=end

# @param {Integer[]} nums
# @param {Integer} target
# @return {Integer}
def three_sum_closest(nums, target)
  nums.sort!
  result = Float::INFINITY

  (0..nums.size - 3).each do |i|
    left = i + 1
    right = nums.size - 1

    next if i.positive? && nums[i] == nums[i - 1]

    while left < right
      sum = nums[i] + nums[left] + nums[right]
      return sum if sum == target

      sum < target ? left += 1 : right -= 1
      result = sum if (target - sum).abs < (target - result).abs
    end
  end

  result
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_three_sum_closest < Test::Unit::TestCase
  def test_
    assert_equal(2, three_sum_closest([-1, 2, 1, -4], 1))
    assert_equal(0, three_sum_closest([0, 0, 0], 1))
  end
end
"
0017,letter-combinations-of-a-phone-number,"# frozen_string_literal: true

# 17. Letter Combinations of a Phone Number
# https://leetcode.com/problems/letter-combinations-of-a-phone-number
# Medium

=begin
Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.

A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.

Example 1:
Input: digits = ""23""
Output: [""ad"",""ae"",""af"",""bd"",""be"",""bf"",""cd"",""ce"",""cf""]

Example 2:
Input: digits = """"
Output: []

Example 3:
Input: digits = ""2""
Output: [""a"",""b"",""c""]

Constraints:
0 <= digits.length <= 4
digits[i] is a digit in the range ['2', '9'].
=end

# @param {String} digits
# @return {String[]}
def letter_combinations(digits)
  map = ""- - abc def ghi jkl mno pqrs tuv wxyz"".split
  charsets = digits.chars.map { |d| map[d.to_i].chars }
  digits == """" ? [] : [""""].product(*charsets).map(&:join)
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_letter_combinations < Test::Unit::TestCase
  def test_
    assert_equal [""ad"", ""ae"", ""af"", ""bd"", ""be"", ""bf"", ""cd"", ""ce"", ""cf""], letter_combinations(""23"")
    assert_equal [], letter_combinations("""")
    assert_equal [""a"", ""b"", ""c""], letter_combinations(""2"")
  end
end
"
0018,4sum,"# frozen_string_literal: true

# 18. 4Sum
# Medium
# https://leetcode.com/problems/4sum

=begin
Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:
* 0 <= a, b, c, d < n
* a, b, c, and d are distinct.
* nums[a] + nums[b] + nums[c] + nums[d] == target
You may return the answer in any order.

Example 1:
Input: nums = [1,0,-1,0,-2,2], target = 0
Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]

Example 2:
Input: nums = [2,2,2,2,2], target = 8
Output: [[2,2,2,2]]

Constraints:
1 <= nums.length <= 200
-109 <= nums[i] <= 109
-109 <= target <= 109
=end

# @param {Integer[]} nums
# @param {Integer} target
# @return {Integer[][]}
def max_four(nums)
  count = nums.tally
  arr = []
  count.each do |k, v|
    ([v, 4].min).times { arr << k }
  end
  arr
end

def four_sum(nums, target)
  nums = max_four(nums)
  res = Set[]

  # hash: sum is key, array of pairs of indices is value
  two_sum = Hash.new { |h, k| h[k] = [] }

  (0...nums.length).each do |a|
    (a + 1...nums.length).each do |b|
      sum = nums[a] + nums[b]

      two_sum[target - sum].each do |pair|
        if ([a, b] + pair).uniq.length == 4
          c, d = pair
          res.add([nums[a], nums[b], nums[c], nums[d]].sort)
        end
      end

      two_sum[sum] << [a, b]
    end
  end

  res.to_a
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_four_sum < Test::Unit::TestCase
  def test_
    assert_equal [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]].sort, four_sum([1, 0, -1, 0, -2, 2], 0).sort
    assert_equal [[2, 2, 2, 2]].sort, four_sum([2, 2, 2, 2, 2], 8).sort
  end
end
"
0019,remove-nth-node-from-end-of-list,"# frozen_string_literal: true

# 19. Remove Nth Node From End of List
# https://leetcode.com/problems/remove-nth-node-from-end-of-list

=begin

Given the head of a linked list, remove the nth node from the end of the list and return its head.

### Example 1:
Input: head = [1,2,3,4,5], n = 2
Output: [1,2,3,5]

### Example 2:
Input: head = [1], n = 1
Output: []

### Example 3:
Input: head = [1,2], n = 1
Output: [1]

### Constraints:
The number of nodes in the list is sz.
1 <= sz <= 30
0 <= Node.val <= 100
1 <= n <= sz

=end

# Definition for singly-linked list.
# class ListNode
#     attr_accessor :val, :next
#     def initialize(val = 0, _next = nil)
#         @val = val
#         @next = _next
#     end
# end
# @param {ListNode} head
# @param {Integer} n
# @return {ListNode}
def remove_nth_from_end(head, n)
  dummy = ListNode.new(0)
  dummy.next = head
  slow = dummy
  fast = dummy
  (n + 1).times do
    fast = fast.next
  end
  while fast
    slow = slow.next
    fast = fast.next
  end
  slow.next = slow.next.next
  dummy.next
end
"
0020,valid-parentheses,"# frozen_string_literal: true

# 20. Valid Parentheses
# https://leetcode.com/problems/valid-parentheses

# @param {String} s
# @return {Boolean}
def is_valid(s)
  arr = []

  s.chars.each do |c|
    if [""("", ""{"", ""[""].include?(c)
      arr.push(c)
    else
      return false if arr.empty?
      if c == "")"" && arr.last != ""("" ||
         c == ""}"" && arr.last != ""{"" ||
         c == ""]"" && arr.last != ""[""

        return false
      end

      arr.pop
    end
  end

  arr.empty?
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_is_valid < Test::Unit::TestCase
  def test_
    assert_equal true, is_valid(""()"")
    assert_equal true, is_valid(""()[]{}"")
    assert_equal false, is_valid(""(]"")
  end
end
"
0021,merge-two-sorted-lists,"# frozen_string_literal: true

# 21. Merge Two Sorted Lists
# https://leetcode.com/problems/merge-two-sorted-lists

# Definition for singly-linked list.
# class ListNode
#     attr_accessor :val, :next
#     def initialize(val = 0, _next = nil)
#         @val = val
#         @next = _next
#     end
# end
# @param {ListNode} list1
# @param {ListNode} list2
# @return {ListNode}
def merge_two_lists(list1, list2)
  return list1 unless list2
  return list2 unless list1

  if list1.val < list2.val
    list1.next = merge_two_lists(list1.next, list2)
    list1
  else
    list2.next = merge_two_lists(list1, list2.next)
    list2
  end
end

# **************** #
#       TEST       #
# **************** #

# TODO: Write tests
"
0022,generate-parentheses,"# frozen_string_literal: true

# 22. Generate Parentheses
# https://leetcode.com/problems/generate-parentheses
# Medium

=begin
Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

Example 1:
Input: n = 3
Output: [""((()))"",""(()())"",""(())()"",""()(())"",""()()()""]

Example 2:
Input: n = 1
Output: [""()""]

Constraints:
* 1 <= n <= 8
=end

# @param {Integer} n
# @return {String[]}
def generate_parenthesis(n)
  @res = []
  backtrack("""", 0, 0, n)
  @res
end

def backtrack(curr, open, close, n)
  @res << curr and return if curr.length == n * 2
  backtrack(curr + ""("", open + 1, close, n) if open < n
  backtrack(curr + "")"", open, close + 1, n) if close < open
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_generate_parenthesis < Test::Unit::TestCase
  def test_
    assert_equal [""((()))"", ""(()())"", ""(())()"", ""()(())"", ""()()()""], generate_parenthesis(3)
    assert_equal [""()""], generate_parenthesis(1)
  end
end
"
0023,merge-k-sorted-lists,"# frozen_string_literal: true

# 23. Merge k Sorted Lists
# https://leetcode.com/problems/merge-k-sorted-lists

=begin

You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.
Merge all the linked-lists into one sorted linked-list and return it.

# Constraints:

* k == lists.length
* 0 <= k <= 104
* 0 <= lists[i].length <= 500
* -104 <= lists[i][j] <= 104
* lists[i] is sorted in ascending order.
* The sum of lists[i].length will not exceed 104.

=end

# Definition for singly-linked list.
# class ListNode
#     attr_accessor :val, :next
#     def initialize(val = 0, _next = nil)
#         @val = val
#         @next = _next
#     end
# end
# @param {ListNode[]} lists
# @return {ListNode}
def merge_k_lists(lists)
  values = []

  lists.each do |list|
    while list
      values << list.val
      list = list.next
    end
  end

  values.sort!
  head = dumphead = ListNode.new(nil)

  values.each do |value|
    head.next = ListNode.new(value)
    head = head.next
  end

  dumphead.next
end
"
0024,swap-nodes-in-pairs,"# frozen_string_literal: true

# 24. Swap Nodes in Pairs
# https://leetcode.com/problems/swap-nodes-in-pairs
# Medium

=begin
Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)

Example 1:
Input: head = [1,2,3,4]
Output: [2,1,4,3]

Example 2:
Input: head = []
Output: []

Example 3:
Input: head = [1]
Output: [1]

Constraints:
The number of nodes in the list is in the range [0, 100].
0 <= Node.val <= 100
=end

# Definition for singly-linked list.
# class ListNode
#     attr_accessor :val, :next
#     def initialize(val = 0, _next = nil)
#         @val = val
#         @next = _next
#     end
# end
# @param {ListNode} head
# @return {ListNode}

def swap_pairs(head)
  return head if !head || !head.next

  next_node, next_segment = head.next, head.next.next
  next_node.next = head
  head_next = swap_pairs(next_segment)
  head.next = head_next

  next_node
end
"
0025,reverse-nodes-in-k-group,"# frozen_string_literal: true

# 25. Reverse Nodes in k-Group
# https://leetcode.com/problems/reverse-nodes-in-k-group
# Hard

=begin
Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.

k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.

You may not alter the values in the list's nodes, only nodes themselves may be changed.

Example 1:
Input: head = [1,2,3,4,5], k = 2
Output: [2,1,4,3,5]

Example 2:
Input: head = [1,2,3,4,5], k = 3
Output: [3,2,1,4,5]

Constraints:
* The number of nodes in the list is n.
* 1 <= k <= n <= 5000
* 0 <= Node.val <= 1000
=end

# Definition for singly-linked list.
# class ListNode
#     attr_accessor :val, :next
#     def initialize(val = 0, _next = nil)
#         @val = val
#         @next = _next
#     end
# end
# @param {ListNode} head
# @param {Integer} k
# @return {ListNode}
def reverse_k_group(head, k)
  dummy = ListNode.new(""dummy"", head)
  prev = dummy

  loop do
    scout = prev

    k.times do
      break unless scout
      scout = scout.next
    end

    break unless scout

    pivot = prev.next

    until prev.next == scout
      prev.next, pivot.next.next = pivot.next.next, prev.next
      prev.next, pivot.next = pivot.next, prev.next
    end

    k.times { prev = prev.next }
  end

  dummy.next
end
"
0026,remove-duplicates-from-sorted-array,"# frozen_string_literal: true

# 26. Remove Duplicates from Sorted Array
# https://leetcode.com/problems/remove-duplicates-from-sorted-array
# Easy

=begin
Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.

Consider the number of unique elements of nums to be k, to get accepted, you need to do the following things:

Change the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums.
Return k.
Custom Judge:

The judge will test your solution with the following code:

int[] nums = [...]; // Input array
int[] expectedNums = [...]; // The expected answer with correct length

int k = removeDuplicates(nums); // Calls your implementation

assert k == expectedNums.length;
for (int i = 0; i < k; i++) {
    assert nums[i] == expectedNums[i];
}
If all assertions pass, then your solution will be accepted.

Example 1:
Input: nums = [1,1,2]
Output: 2, nums = [1,2,_]
Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).

Example 2:
Input: nums = [0,0,1,1,1,2,2,3,3,4]
Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]
Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).

Constraints:
1 <= nums.length <= 3 * 104
-100 <= nums[i] <= 100
nums is sorted in non-decreasing order.
=end

# @param {Integer[]} nums
# @return {Integer}
def remove_duplicates(nums)
  nums.uniq!
  nums.size
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_remove_duplicates < Test::Unit::TestCase
  def test_
    assert_equal 2, remove_duplicates([1, 1, 2])
    assert_equal 5, remove_duplicates([0, 0, 1, 1, 1, 2, 2, 3, 3, 4])
  end
end
"
0027,remove-element,"# frozen_string_literal: true

# 27. Remove Element
# https://leetcode.com/problems/remove-element
# Easy

=begin
Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.

Consider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:

Change the array nums such that the first k elements of nums contain the elements which are not equal to val. The remaining elements of nums are not important as well as the size of nums.
Return k.
Custom Judge:

The judge will test your solution with the following code:

int[] nums = [...]; // Input array
int val = ...; // Value to remove
int[] expectedNums = [...]; // The expected answer with correct length.
                            // It is sorted with no values equaling val.

int k = removeElement(nums, val); // Calls your implementation

assert k == expectedNums.length;
sort(nums, 0, k); // Sort the first k elements of nums
for (int i = 0; i < actualLength; i++) {
    assert nums[i] == expectedNums[i];
}
If all assertions pass, then your solution will be accepted.

Example 1:
Input: nums = [3,2,2,3], val = 3
Output: 2, nums = [2,2,_,_]
Explanation: Your function should return k = 2, with the first two elements of nums being 2.
It does not matter what you leave beyond the returned k (hence they are underscores).

Example 2:
Input: nums = [0,1,2,2,3,0,4,2], val = 2
Output: 5, nums = [0,1,4,0,3,_,_,_]
Explanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.
Note that the five elements can be returned in any order.
It does not matter what you leave beyond the returned k (hence they are underscores).

Constraints:
0 <= nums.length <= 100
0 <= nums[i] <= 50
0 <= val <= 100
=end

# @param {Integer[]} nums
# @param {Integer} val
# @return {Integer}
def remove_element(nums, val)
  nums.delete(val)
  nums.size
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_remove_element < Test::Unit::TestCase
  def test_
    assert_equal 2, remove_element([3, 2, 2, 3], 3)
    assert_equal 5, remove_element([0, 1, 2, 2, 3, 0, 4, 2], 2)
  end
end
"
0028,find-the-index-of-the-first-occurrence-in-a-string,"# frozen_string_literal: true

# 28. Find the Index of the First Occurrence in a String
# https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string

# @param {String} haystack
# @param {String} needle
# @return {Integer}
def str_str(haystack, needle)
  return 0 if needle.empty?
  return -1 if needle.size > haystack.size

  (haystack.size - needle.size + 1).times do |i|
    return i if haystack[i..i + needle.size - 1] == needle
  end

  -1
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_str_str < Test::Unit::TestCase
  def test_
    assert_equal 0, str_str(""sadbutsad"", ""sad"")
    assert_equal(-1, str_str(""leetcode"", ""leeto""))
  end
end
"
0030,substring-with-concatenation-of-all-words,"# frozen_string_literal: true

# 30. Substring with Concatenation of All Words
# https://leetcode.com/problems/substring-with-concatenation-of-all-words
# Hard

=begin
You are given a string s and an array of strings words. All the strings of words are of the same length.

A concatenated substring in s is a substring that contains all the strings of any permutation of words concatenated.

For example, if words = [""ab"",""cd"",""ef""], then ""abcdef"", ""abefcd"", ""cdabef"", ""cdefab"", ""efabcd"", and ""efcdab"" are all concatenated strings. ""acdbef"" is not a concatenated substring because it is not the concatenation of any permutation of words.
Return the starting indices of all the concatenated substrings in s. You can return the answer in any order.

Example 1:
Input: s = ""barfoothefoobarman"", words = [""foo"",""bar""]
Output: [0,9]
Explanation: Since words.length == 2 and words[i].length == 3, the concatenated substring has to be of length 6.
The substring starting at 0 is ""barfoo"". It is the concatenation of [""bar"",""foo""] which is a permutation of words.
The substring starting at 9 is ""foobar"". It is the concatenation of [""foo"",""bar""] which is a permutation of words.
The output order does not matter. Returning [9,0] is fine too.

Example 2:
Input: s = ""wordgoodgoodgoodbestword"", words = [""word"",""good"",""best"",""word""]
Output: []
Explanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.
There is no substring of length 16 is s that is equal to the concatenation of any permutation of words.
We return an empty array.

Example 3:
Input: s = ""barfoofoobarthefoobarman"", words = [""bar"",""foo"",""the""]
Output: [6,9,12]
Explanation: Since words.length == 3 and words[i].length == 3, the concatenated substring has to be of length 9.
The substring starting at 6 is ""foobarthe"". It is the concatenation of [""foo"",""bar"",""the""] which is a permutation of words.
The substring starting at 9 is ""barthefoo"". It is the concatenation of [""bar"",""the"",""foo""] which is a permutation of words.
The substring starting at 12 is ""thefoobar"". It is the concatenation of [""the"",""foo"",""bar""] which is a permutation of words.

Constraints:
1 <= s.length <= 104
1 <= words.length <= 5000
1 <= words[i].length <= 30
s and words[i] consist of lowercase English letters.
=end

# @param {String} s
# @param {String[]} words
# @return {Integer[]}
def find_substring(s, words)
  ws = words.first.size
  ts = ws * words.size
  return [] if s.size < ts
  omp = words.tally
  (s.size - ts + 1).times.inject([]) do |r, i|
    mp = omp.dup
    r << i if words.size.times.all? { |k|
      su = s[i + k * ws, ws]
      break false unless mp.has_key?(su)
      break false if mp[su].zero?
      mp[su] -= 1
      true
    }
    r
  end
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_find_substring < Test::Unit::TestCase
  def test_
    assert_equal [0, 9], find_substring(""barfoothefoobarman"", [""foo"", ""bar""])
    assert_equal [], find_substring(""wordgoodgoodgoodbestword"", [""word"", ""good"", ""best"", ""word""])
    assert_equal [6, 9, 12], find_substring(""barfoofoobarthefoobarman"", [""bar"", ""foo"", ""the""])
  end
end
"
0033,search-in-rotated-sorted-array,"# frozen_string_literal: true

# 33. Search in Rotated Sorted Array
# https://leetcode.com/problems/search-in-rotated-sorted-array
# Medium

=begin
There is an integer array nums sorted in ascending order (with distinct values).

Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].

Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.

You must write an algorithm with O(log n) runtime complexity.

### Example 1:
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4

### Example 2:
Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1

### Example 3:
Input: nums = [1], target = 0
Output: -1

### Constraints:
* 1 <= nums.length <= 5000
* -104 <= nums[i] <= 104
* All values of nums are unique.
* nums is an ascending array that is possibly rotated.
* -104 <= target <= 104
=end

# @param {Integer[]} nums
# @param {Integer} target
# @return {Integer}
def search(nums, target)
  left, right = 0, nums.size - 1

  while left <= right
    mid = (left + right) / 2

    return mid if nums[mid] == target

    if nums[mid] >= nums[left]
      if nums[mid] >= target && target >= nums[left]
        right = mid - 1
      else
        left = mid + 1
      end
    else
      if nums[mid] <= target && target <= nums[right]
        left = mid + 1
      else
        right = mid - 1
      end
    end
  end

  -1
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_search < Test::Unit::TestCase
  def test_
    assert_equal 4, search([4, 5, 6, 7, 0, 1, 2], 0)
    assert_equal(-1, search([4, 5, 6, 7, 0, 1, 2], 3))
    assert_equal(-1, search([1], 0))
  end
end
"
0034,find-first-and-last-position-of-element-in-sorted-array,"# frozen_string_literal: true

# https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array
# 34. Find First and Last Position of Element in Sorted Array
# Medium

=begin
Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.

If target is not found in the array, return [-1, -1].

You must write an algorithm with O(log n) runtime complexity.

Example 1:
Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]

Example 2:
Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]

Example 3:
Input: nums = [], target = 0
Output: [-1,-1]

Constraints:
* 0 <= nums.length <= 105
* -109 <= nums[i] <= 109
* nums is a non-decreasing array.
* -109 <= target <= 109
=end

# @param {Integer[]} nums
# @param {Integer} target
# @return {Integer[]}
def search_range(nums, target)
  records = Hash.new([])
  for i in 0...nums.length
    records[nums[i]] = []
  end
  for i in 0...nums.length
    records[nums[i]] << i
  end
  records[target].empty? ? [-1, -1] : [records[target][0], records[target][-1]]
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_search_range < Test::Unit::TestCase
  def test_
    assert_equal [3, 4], search_range([5, 7, 7, 8, 8, 10], 8)
    assert_equal [-1, -1], search_range([5, 7, 7, 8, 8, 10], 6)
    assert_equal [-1, -1], search_range([], 0)
  end
end
"
0035,search-insert-position,"# frozen_string_literal: true

# 35. Search Insert Position
# https://leetcode.com/problems/search-insert-position

# @param {Integer[]} nums
# @param {Integer} target
# @return {Integer}
def search_insert(nums, target)
  return 0 if nums.empty?

  l = 0
  r = nums.length - 1
  while l <= r
    m = (l + r) / 2
    if nums[m] == target
      return m
    elsif nums[m] > target
      r = m - 1
    else
      l = m + 1
    end
  end

  l
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_search_insert < Test::Unit::TestCase
  def test_
    assert_equal 1, search_insert([1, 3, 5, 6], 2)
    assert_equal 4, search_insert([1, 3, 5, 6], 7)
  end
end
"
0036,valid-sudoku,"# frozen_string_literal: true

# 36. Valid Sudoku
# https://leetcode.com/problems/valid-sudoku
# Medium

=begin
Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:

Each row must contain the digits 1-9 without repetition.
Each column must contain the digits 1-9 without repetition.
Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.
Note:

A Sudoku board (partially filled) could be valid but is not necessarily solvable.
Only the filled cells need to be validated according to the mentioned rules.

Example 1:
Input: board =
[[""5"",""3"",""."",""."",""7"",""."",""."",""."","".""]
,[""6"",""."",""."",""1"",""9"",""5"",""."",""."","".""]
,[""."",""9"",""8"",""."",""."",""."",""."",""6"","".""]
,[""8"",""."",""."",""."",""6"",""."",""."",""."",""3""]
,[""4"",""."",""."",""8"",""."",""3"",""."",""."",""1""]
,[""7"",""."",""."",""."",""2"",""."",""."",""."",""6""]
,[""."",""6"",""."",""."",""."",""."",""2"",""8"","".""]
,[""."",""."",""."",""4"",""1"",""9"",""."",""."",""5""]
,[""."",""."",""."",""."",""8"",""."",""."",""7"",""9""]]
Output: true

Example 2:
Input: board =
[[""8"",""3"",""."",""."",""7"",""."",""."",""."","".""]
,[""6"",""."",""."",""1"",""9"",""5"",""."",""."","".""]
,[""."",""9"",""8"",""."",""."",""."",""."",""6"","".""]
,[""8"",""."",""."",""."",""6"",""."",""."",""."",""3""]
,[""4"",""."",""."",""8"",""."",""3"",""."",""."",""1""]
,[""7"",""."",""."",""."",""2"",""."",""."",""."",""6""]
,[""."",""6"",""."",""."",""."",""."",""2"",""8"","".""]
,[""."",""."",""."",""4"",""1"",""9"",""."",""."",""5""]
,[""."",""."",""."",""."",""8"",""."",""."",""7"",""9""]]
Output: false
Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.

Constraints:
board.length == 9
board[i].length == 9
board[i][j] is a digit 1-9 or '.'.
=end

# @param {Character[][]} board
# @return {Boolean}
def is_valid_sudoku(board)
  l = -> { Array.new 9 do Hash.new 0 end }
  h, v, c = l.call, l.call, l.call
  for i in 0...9
    for j in 0...9
      return false if (k = board[i][j]) != ?. && begin
          (h[i][k] += 1) > 1 ||
          (v[j][k] += 1) > 1 ||
          (c[(i / 3) * 3 + j / 3][k] += 1) > 1
        end
    end
  end
  true
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_is_valid_sudoku < Test::Unit::TestCase
  def test_
    assert_equal true,
      is_valid_sudoku([
        [""5"", ""3"", ""."", ""."", ""7"", ""."", ""."", ""."", "".""],
        [""6"", ""."", ""."", ""1"", ""9"", ""5"", ""."", ""."", "".""],
        [""."", ""9"", ""8"", ""."", ""."", ""."", ""."", ""6"", "".""],
        [""8"", ""."", ""."", ""."", ""6"", ""."", ""."", ""."", ""3""],
        [""4"", ""."", ""."", ""8"", ""."", ""3"", ""."", ""."", ""1""],
        [""7"", ""."", ""."", ""."", ""2"", ""."", ""."", ""."", ""6""],
        [""."", ""6"", ""."", ""."", ""."", ""."", ""2"", ""8"", "".""],
        [""."", ""."", ""."", ""4"", ""1"", ""9"", ""."", ""."", ""5""],
        [""."", ""."", ""."", ""."", ""8"", ""."", ""."", ""7"", ""9""]])

    assert_equal false,
     is_valid_sudoku([
        [""8"", ""3"", ""."", ""."", ""7"", ""."", ""."", ""."", "".""],
        [""6"", ""."", ""."", ""1"", ""9"", ""5"", ""."", ""."", "".""],
        [""."", ""9"", ""8"", ""."", ""."", ""."", ""."", ""6"", "".""],
        [""8"", ""."", ""."", ""."", ""6"", ""."", ""."", ""."", ""3""],
        [""4"", ""."", ""."", ""8"", ""."", ""3"", ""."", ""."", ""1""],
        [""7"", ""."", ""."", ""."", ""2"", ""."", ""."", ""."", ""6""],
        [""."", ""6"", ""."", ""."", ""."", ""."", ""2"", ""8"", "".""],
        [""."", ""."", ""."", ""4"", ""1"", ""9"", ""."", ""."", ""5""],
        [""."", ""."", ""."", ""."", ""8"", ""."", ""."", ""7"", ""9""]])
  end
end
"
0039,combination-sum,"# frozen_string_literal: true

# 39. Combination Sum
# https://leetcode.com/problems/combination-sum
# Medium

=begin
Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.
The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.
The test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.

Example 1:
Input: candidates = [2,3,6,7], target = 7
Output: [[2,2,3],[7]]
Explanation:
2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.
7 is a candidate, and 7 = 7.
These are the only two combinations.

Example 2:
Input: candidates = [2,3,5], target = 8
Output: [[2,2,2,2],[2,3,3],[3,5]]

Example 3:

Input: candidates = [2], target = 1
Output: []

Constraints:
1 <= candidates.length <= 30
2 <= candidates[i] <= 40
All elements of candidates are distinct.
1 <= target <= 40
=end

# @param {Integer[]} candidates
# @param {Integer} target
# @return {Integer[][]}
def combination_sum(candidates, target)
  candidates.sort!

  stack = [[0, 0, []]]
  result = []

  until stack.empty?
    total, start, combination = stack.pop

    if total == target
      result << combination
    end

    (start...candidates.count).each do |i|
      new_total = total + candidates[i]

      if new_total > target
        break
      end

      stack << [
        new_total,
        i,
        combination + [candidates[i]]
      ]
    end
  end

  result
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_combination_sum < Test::Unit::TestCase
  def test_
    assert_equal [[2, 2, 3], [7]].sort, combination_sum([2, 3, 6, 7], 7).sort
    assert_equal [[2, 2, 2, 2], [2, 3, 3], [3, 5]].sort, combination_sum([2, 3, 5], 8).sort
    assert_equal [], combination_sum([2], 1).sort
  end
end
"
0042,trapping-rain-water,"# frozen_string_literal: true

# 42. Trapping Rain Water
# https://leetcode.com/problems/trapping-rain-water
# Hard

=begin
Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.

Example 1:
Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.

Example 2:
Input: height = [4,2,0,3,2,5]
Output: 9

Constraints:
n == height.length
1 <= n <= 2 * 104
0 <= height[i] <= 105
=end

# @param {Integer[]} height
# @return {Integer}
def trap(height)
  max_left, max_right = [], []

  height.each_index do |i|
    if i == 0
      max_left << height[i]
      max_right << height[-i - 1]
    else
      max_left.push([max_left[i - 1], height[i]].max)
      max_right.unshift([max_right[-i], height[-i - 1]].max)
    end
  end

  s = 0
  height.each_index do |i|
    s += ([max_right[i], max_left[i]].min - height[i])
  end
  s
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_trap < Test::Unit::TestCase
  def test_
    assert_equal 6, trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])
    assert_equal 9, trap([4, 2, 0, 3, 2, 5])
  end
end
"
0043,multiply-strings,"# frozen_string_literal: true

# 43. Multiply Strings
# https:#leetcode.com/problems/multiply-strings

=begin

Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.

Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.

### Example 1:
Input: num1 = ""2"", num2 = ""3""
Output: ""6""

### Example 2:
Input: num1 = ""123"", num2 = ""456""
Output: ""56088""

### Constraints:
* 1 <= num1.length, num2.length <= 200
* num1 and num2 consist of digits only.
* Both num1 and num2 do not contain any leading zero, except the number 0 itself.

=end

# Runtime 119 ms Beats 44.26%
# Memory 211 MB Beats 70.49%%
# @param {String} num1
# @param {String} num2
# @return {String}
def multiply(num1, num2)
  if num1 == ""0"" || num2 == ""0""
    return ""0""
  end

  first_numbers = num1.each_char.map(&:to_i).reverse
  second_numbers = num2.each_char.map(&:to_i).reverse

  # To store the multiplication result of each digit of secondNumber with firstNumber.
  len = first_numbers.length + second_numbers.length
  answer = Array.new(len, 0)

  second_numbers.each_with_index do |digit2, place2|
    first_numbers.each_with_index do |digit1, place1|
      # The number of zeros from multiplying to digits depends on the
      # place of digit2 in secondNumber and the place of the digit1 in firstNumber.
      currentPos = place1 + place2

      # The digit currently at position currentPos in the answer string
      # is carried over and summed with the current result.
      carry = answer[currentPos]
      multiplication = digit1 * digit2 + carry

      # Set the ones place of the multiplication result.
      answer[currentPos] = multiplication % 10

      # Carry the tens place of the multiplication result by
      # adding it to the next position in the answer array.
      answer[currentPos + 1] += multiplication / 10
    end
  end

  answer.pop if answer.last == 0

  # Ans is in the reversed order.
  # Reverse it to get the final ans.
  answer.reverse.join("""")
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_multiply < Test::Unit::TestCase
  def test_
    assert_equal ""6"", multiply(""2"", ""3"")
    assert_equal ""56088"", multiply(""123"", ""456"")
  end
end
"
0045,jump-game-ii,"# frozen_string_literal: true

# 45. Jump Game II
# https://leetcode.com/problems/jump-game-ii

# @param {Integer[]} nums
# @return {Integer}
def jump(nums)
  current_jump = 0
  last_jump = 0
  step = 0

  (nums.size - 1).times do |i|
    current_jump = [current_jump, i + nums[i]].max
    if i == last_jump
      step += 1
      last_jump = current_jump
    end
  end

  step
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_jump < Test::Unit::TestCase
  def test_
    assert_equal 2, jump([2, 3, 1, 1, 4])
    assert_equal 2, jump([2, 3, 0, 1, 4])
  end
end
"
0046,permutations,"# frozen_string_literal: true

# 46. Permutations
# https://leetcode.com/problems/permutations
# Medium

=begin
Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.

Example 1:
Input: nums = [1,2,3]
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

Example 2:
Input: nums = [0,1]
Output: [[0,1],[1,0]]

Example 3:
Input: nums = [1]
Output: [[1]]

Constraints:
1 <= nums.length <= 6
-10 <= nums[i] <= 10
All the integers of nums are unique.
=end

# @param {Integer[]} nums
# @return {Integer[][]}
def permute(nums, temp = [], res = [])
  nums.empty? ? res << temp : nums.each { |num| permute(nums - [num], temp + [num], res) }
  res
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_combination_sumpermute < Test::Unit::TestCase
  def test_
    assert_equal [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]], permute([1, 2, 3])
    assert_equal [[0, 1], [1, 0]], permute([0, 1])
    assert_equal [[1]], permute([1])
  end
end
"
0048,rotate-image,"# frozen_string_literal: true

# 48. Rotate Image
# https://leetcode.com/problems/rotate-image
# Medium

=begin
You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).

You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.

Example 1:
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [[7,4,1],[8,5,2],[9,6,3]]

Example 2:
Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]

Constraints:
n == matrix.length == matrix[i].length
1 <= n <= 20
-1000 <= matrix[i][j] <= 1000
=end

# @param {Integer[][]} matrix
# @return {Void} Do not return anything, modify matrix in-place instead.
def rotate(matrix, z = matrix.size - 1)
  for i in 0...(matrix.size / 2)
    for j in i..(z - i - 1)
      matrix[    i][j], matrix[j][z - i], matrix[z - i][z - j], matrix[z - j][    i] =
      matrix[z - j][i], matrix[i][    j], matrix[    j][z - i], matrix[z - i][z - j]
    end
  end
end
"
0049,group-anagrams,"# frozen_string_literal: true

# 49. Group Anagrams
# https://leetcode.com/problems/group-anagrams
# Medium

=begin
Given an array of strings strs, group the anagrams together. You can return the answer in any order.

An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

Example 1:
Input: strs = [""eat"",""tea"",""tan"",""ate"",""nat"",""bat""]
Output: [[""bat""],[""nat"",""tan""],[""ate"",""eat"",""tea""]]

Example 2:
Input: strs = [""""]
Output: [[""""]]

Example 3:
Input: strs = [""a""]
Output: [[""a""]]

Constraints:
1 <= strs.length <= 104
0 <= strs[i].length <= 100
strs[i] consists of lowercase English letters.
=end

# @param {String[]} strs
# @return {String[][]}
def group_anagrams(strs)
  strs.sort.group_by { |s| s.chars.sort }.values
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_group_anagrams < Test::Unit::TestCase
  def test_
    assert_equal [[""bat""], [""nat"", ""tan""], [""ate"", ""eat"", ""tea""]].sort, group_anagrams([""eat"", ""tea"", ""tan"", ""ate"", ""nat"", ""bat""])
    assert_equal [[""""]].sort, group_anagrams([""""])
    assert_equal [[""a""]].sort, group_anagrams([""a""])
  end
end
"
0050,powx-n,"# frozen_string_literal: true

# 50. Pow(x, n)
# https://leetcode.com/problems/powx-n
# Medium

=begin
Implement pow(x, n), which calculates x raised to the power n (i.e., x**n).

Example 1:
Input: x = 2.00000, n = 10
Output: 1024.00000

Example 2:
Input: x = 2.10000, n = 3
Output: 9.26100

Example 3:
Input: x = 2.00000, n = -2
Output: 0.25000
Explanation: 2-2 = 1/22 = 1/4 = 0.25

Constraints:
-100.0 < x < 100.0
-231 <= n <= 231-1
n is an integer.
Either x is not zero or n > 0.
-104 <= xn <= 104
=end

# @param {Float} x
# @param {Integer} n
# @return {Float}
def pow(x, n)
  return 1 if n.zero?
  return (1 / pow(x, -n)) if n.negative?
  return x * pow(x, n - 1) if n.odd?
  pow(x * x, n / 2)
end

def my_pow(x, n)
  pow(x, n).round(5)
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_my_pow < Test::Unit::TestCase
  def test_
    assert_equal 1024.00000, my_pow(2.00000, 10)
    assert_equal 9.26100, my_pow(2.10000, 3)
    assert_equal 0.25000, my_pow(2.00000, -2)
  end
end
"
0052,n-queens-ii,"# frozen_string_literal: true

# 52. N-Queens II
# https://leetcode.com/problems/n-queens-ii
# Hard

=begin
The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.

Given an integer n, return the number of distinct solutions to the n-queens puzzle.

Example 1:
Input: n = 4
Output: 2
Explanation: There are two distinct solutions to the 4-queens puzzle as shown.

Example 2:
Input: n = 1
Output: 1

Constraints:
* 1 <= n <= 9
=end

# @param {Integer} n
# @return {Integer}
def total_n_queens(n)
  return 1 if n == 1
  return 0 if n < 4

  @count = 0
  @n = n
  @board = Array.new(n) { Array.new(n, false) }

  backtrack(0)
  @count
end

def backtrack(row)
  if row == @n
    @count += 1
    return
  end

  (0...@n).each do |col|
    if is_valid(row, col)
      @board[row][col] = true
      backtrack(row + 1)
      @board[row][col] = false
    end
  end
end

def is_valid(row, col)
  # Check the same column
  (0...row).each do |i|
    return false if @board[i][col]
  end

  # Check the upper left diagonal
  i = row - 1
  j = col - 1
  while i >= 0 && j >= 0
    return false if @board[i][j]
    i -= 1
    j -= 1
  end

  # Check the upper right diagonal
  i = row - 1
  j = col + 1
  while i >= 0 && j < @n
    return false if @board[i][j]
    i -= 1
    j += 1
  end

  true
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_total_n_queens < Test::Unit::TestCase
  def test_
    assert_equal 2, total_n_queens(4)
    assert_equal 1, total_n_queens(1)
  end
end
"
0053,maximum-subarray,"# frozen_string_literal: true

# https://leetcode.com/problems/maximum-subarray
# 53. Maximum Subarray
# Medium

=begin
Given an integer array nums, find the subarray with the largest sum, and return its sum.

Example 1:
Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
Explanation: The subarray [4,-1,2,1] has the largest sum 6.

Example 2:
Input: nums = [1]
Output: 1
Explanation: The subarray [1] has the largest sum 1.

Example 3:
Input: nums = [5,4,-1,7,8]
Output: 23
Explanation: The subarray [5,4,-1,7,8] has the largest sum 23.

Constraints:
* 1 <= nums.length <= 105
* -104 <= nums[i] <= 104
=end

# @param {Integer[]} nums
# @return {Integer}
def max_sub_array(nums)
  max_sum = nums[0]
  current_sum = nums[0]

  nums[1..-1].each do |num|
    current_sum = [num, current_sum + num].max
    max_sum = [max_sum, current_sum].max
  end

  max_sum
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_max_sub_array < Test::Unit::TestCase
  def test_
    assert_equal 6, max_sub_array([-2, 1, -3, 4, -1, 2, 1, -5, 4])
    assert_equal 1, max_sub_array([1])
    assert_equal 23, max_sub_array([5, 4, -1, 7, 8])
  end
end
"
0054,spiral-matrix,"# frozen_string_literal: true

# 54. Spiral Matrix
# https://leetcode.com/problems/spiral-matrix

=begin

Given an m x n matrix, return all elements of the matrix in spiral order.

### Example 1:
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [1,2,3,6,9,8,7,4,5]

### Example 2:
Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
Output: [1,2,3,4,8,12,11,10,9,5,6,7]

### Constraints:
* m == matrix.length
* n == matrix[i].length
* 1 <= m, n <= 10
* -100 <= matrix[i][j] <= 100

=end

# @param {Integer[][]} matrix
# @return {Integer[]}
def spiral_order(matrix)
  (row = matrix.shift) ? row + spiral_order(matrix.transpose.reverse) : []
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_spiral_order < Test::Unit::TestCase
  def test_
    assert_equal [1, 2, 3, 6, 9, 8, 7, 4, 5], spiral_order([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    assert_equal [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7], spiral_order([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])
  end
end
"
0055,jump-game,"# frozen_string_literal: true

# 55. Jump Game
# https://leetcode.com/problems/jump-game
# Medium

=begin
You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.

Return true if you can reach the last index, or false otherwise.

Example 1:
Input: nums = [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.

Example 2:
Input: nums = [3,2,1,0,4]
Output: false
Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.

Constraints:
1 <= nums.length <= 104
0 <= nums[i] <= 105
=end

# @param {Integer[]} nums
# @return {Boolean}
def can_jump(nums)
  i = nums.length - 2
  distance = 1

  while i >= 0 do
    if nums[i] - distance >= 0
      distance = 1
    else
      distance += 1
    end

    i -= 1
  end

  distance == 1
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_can_jump < Test::Unit::TestCase
  def test_
    assert_equal true, can_jump([2, 3, 1, 1, 4])
    assert_equal false, can_jump([3, 2, 1, 0, 4])
  end
end
"
0056,merge-intervals,"# frozen_string_literal: true

# 56. Merge Intervals
# https://leetcode.com/problems/merge-intervals
# Medium

=begin
Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.

Example 1:
Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].

Example 2:
Input: intervals = [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.

Constraints:
* 1 <= intervals.length <= 104
* intervals[i].length == 2
* 0 <= starti <= endi <= 104
=end

# @param {Integer[][]} intervals
# @return {Integer[][]}
def merge(intervals)
  result = []

  intervals.sort_by { |interval| interval[0] }.each do |interval|
    if !result.empty? && interval[0] <= result[-1][1]
      result[-1][1] = [result[-1][1], interval[1]].max
    else
      result << interval
    end
  end

  result
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_merge < Test::Unit::TestCase
  def test_
    assert_equal([[1, 6], [8, 10], [15, 18]], merge([[1, 3], [2, 6], [8, 10], [15, 18]]))
    assert_equal([[1, 5]], merge([[1, 4], [4, 5]]))
  end
end
"
0057,insert-interval,"# frozen_string_literal: true

# 57. Insert Interval
# https://leetcode.com/problems/insert-interval
# Medium

=begin
You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.

Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).

Return intervals after the insertion.

Example 1:
Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
Output: [[1,5],[6,9]]

Example 2:
Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
Output: [[1,2],[3,10],[12,16]]
Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].

Constraints:
* 0 <= intervals.length <= 104
* intervals[i].length == 2
* 0 <= starti <= endi <= 105
* intervals is sorted by starti in ascending order.
* newInterval.length == 2
* 0 <= start <= end <= 105
=end

# @param {Integer[][]} intervals
# @param {Integer[]} new_interval
# @return {Integer[][]}
def insert(intervals, new_interval)
  result = []

  (intervals + [new_interval]).sort.each do |interval|
    if result.empty? || result.last[1] < interval[0]
      result << interval
    else
      result[-1][1] = [result.last[1], interval[1]].max
    end
  end

  result
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_merge < Test::Unit::TestCase
  def test_
    assert_equal([[1, 5], [6, 9]], insert([[1, 3], [6, 9]], [2, 5]))
    assert_equal([[1, 2], [3, 10], [12, 16]], insert([[1, 2], [3, 5], [6, 7], [8, 10], [12, 16]], [4, 8]))
  end
end
"
0058,length-of-last-word,"# frozen_string_literal: true

# 58. Length of Last Word
# https://leetcode.com/problems/length-of-last-word

# @param {String} s
# @return {Integer}
def length_of_last_word(s)
  words = s.strip.split("" "")
  words.last.length
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_length_of_last_word < Test::Unit::TestCase
  def test_
    assert_equal 5, length_of_last_word(""Hello World"")
    assert_equal 4, length_of_last_word(""   fly me   to   the moon  "")
    assert_equal 6, length_of_last_word(""luffy is still joyboy"")
  end
end
"
0059,spiral-matrix-ii,"# frozen_string_literal: true

# 59. Spiral Matrix II
# https://leetcode.com/problems/spiral-matrix-ii
# Medium

=begin
Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.

Example 1:
Input: n = 3
Output: [[1,2,3],[8,9,4],[7,6,5]]

Example 2:
Input: n = 1
Output: [[1]]

Constraints:
1 <= n <= 20
=end

# @param {Integer} n
# @return {Integer[][]}
def generate_matrix(n)
  matrix = n.times.map { [nil] * n }

  top_i, bottom_i = 0, n - 1
  left_j, right_j = 0, n - 1

  count = 1

  while top_i <= bottom_i && left_j <= right_j
    (left_j...right_j + 1).each do |j|
      matrix[top_i][j] = count
      count += 1
    end

    (top_i + 1...bottom_i + 1).each do |i|
      matrix[i][right_j] = count
      count += 1
    end

    (right_j - 1).downto(left_j) do |j|
      matrix[bottom_i][j] = count
      count += 1
    end

    (bottom_i - 1).downto(top_i + 1) do |i|
      matrix[i][left_j] = count
      count += 1
    end

    top_i += 1
    bottom_i -= 1
    left_j += 1
    right_j -= 1
  end

  matrix
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_generate_matrix < Test::Unit::TestCase
  def test_
    assert_equal [[1, 2, 3], [8, 9, 4], [7, 6, 5]], generate_matrix(3)
    assert_equal [[1]], generate_matrix(1)
  end
end
"
0061,rotate-list,"# frozen_string_literal: true

# 61. Rotate List
# https://leetcode.com/problems/rotate-list
# Medium

=begin
Given the head of a linked list, rotate the list to the right by k places.

Example 1:
Input: head = [1,2,3,4,5], k = 2
Output: [4,5,1,2,3]

Example 2:
Input: head = [0,1,2], k = 4
Output: [2,0,1]

Constraints:
* The number of nodes in the list is in the range [0, 500].
* -100 <= Node.val <= 100
* 0 <= k <= 2 * 109
=end

# Definition for singly-linked list.
# class ListNode
#     attr_accessor :val, :next
#     def initialize(val = 0, _next = nil)
#         @val = val
#         @next = _next
#     end
# end
# @param {ListNode} head
# @param {Integer} k
# @return {ListNode}
def rotate_right(head, k)
  return head if head.nil? || head.next.nil? || k == 0

  # Calculate the length of the linked list
  length = 1
  old_tail = head
  while old_tail.next
    old_tail = old_tail.next
    length += 1
  end

  # Update k to be the effective number of rotations needed
  k %= length
  return head if k == 0

  # Find the new tail node (length - k - 1) and the new head node (length - k)
  new_tail = head
  (length - k - 1).times { new_tail = new_tail.next }
  new_head = new_tail.next

  # Update the next pointers of the new tail and the old tail
  new_tail.next = nil
  old_tail.next = head

  new_head
end
"
0062,unique-paths,"# frozen_string_literal: true

# 62. Unique Paths
# https://leetcode.com/problems/unique-paths
# Medium

=begin

There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.

Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.

The test cases are generated so that the answer will be less than or equal to 2 * 109.

### Example 1:
Input: m = 3, n = 7
Output: 28

### Example 2:
Input: m = 3, n = 2
Output: 3
Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -> Down -> Down
2. Down -> Down -> Right
3. Down -> Right -> Down

### Constraints:
* 1 <= m, n <= 100

=end

# @param {Integer} m
# @param {Integer} n
# @return {Integer}
def unique_paths(m, n)
  dp = Array.new(m) { Array.new(n) }
  m.times do |i|
    n.times do |j|
      if i == 0 || j == 0
        dp[i][j] = 1
      else
        dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
      end
    end
  end
  dp[-1][-1]
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_unique_paths < Test::Unit::TestCase
  def test_
    assert_equal 28, unique_paths(3, 7)
    assert_equal 3, unique_paths(3, 2)
  end
end
"
0063,unique-paths-ii,"# frozen_string_literal: true

# 63. Unique Paths II
# https://leetcode.com/problems/unique-paths-ii
# Medium

=begin
You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.

An obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle.

Return the number of possible unique paths that the robot can take to reach the bottom-right corner.

The testcases are generated so that the answer will be less than or equal to 2 * 109.

Example 1:
Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
Output: 2
Explanation: There is one obstacle in the middle of the 3x3 grid above.
There are two ways to reach the bottom-right corner:
1. Right -> Right -> Down -> Down
2. Down -> Down -> Right -> Right

Example 2:
Input: obstacleGrid = [[0,1],[0,0]]
Output: 1

Constraints:
m == obstacleGrid.length
n == obstacleGrid[i].length
1 <= m, n <= 100
obstacleGrid[i][j] is 0 or 1.
=end

# @param {Integer[][]} obstacle_grid
# @return {Integer}
# @param {Integer[][]} obstacle_grid
# @return {Integer}
def unique_paths_with_obstacles(obstacle_grid)
  hight = obstacle_grid.count
  width = obstacle_grid[0].count

  return 0 if hight * width == 0 || obstacle_grid[0][0] == 1

  obstacle_grid[0][0] = 1

  (1...hight).each do |y|
    obstacle_grid[y][0] = obstacle_grid[y - 1][0] * (1 - obstacle_grid[y][0])
  end

  (1...width).each do |x|
    obstacle_grid[0][x] = obstacle_grid[0][x - 1] * (1 - obstacle_grid[0][x])
  end

  (1...hight).each do |y|
    (1...width).each do |x|
      obstacle_grid[y][x] = (obstacle_grid[y][x - 1] + obstacle_grid[y - 1][x]) * (1 - obstacle_grid[y][x])
    end
  end

  obstacle_grid[hight - 1][width - 1]
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_unique_paths_with_obstacles < Test::Unit::TestCase
  def test_
    assert_equal 2, unique_paths_with_obstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]])
    assert_equal 1, unique_paths_with_obstacles([[0, 1], [0, 0]])
  end
end
"
0064,minimum-path-sum,"# frozen_string_literal: true

# 64. Minimum Path Sum
# https://leetcode.com/problems/minimum-path-sum

=begin

Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.

Note: You can only move either down or right at any point in time.

### Example 1:
Input: grid = [[1,3,1],[1,5,1],[4,2,1]]
Output: 7
Explanation: Because the path 1  3  1  1  1 minimizes the sum.

### Example 2:
Input: grid = [[1,2,3],[4,5,6]]
Output: 12

### Constraints:
* m == grid.length
* n == grid[i].length
* 1 <= m, n <= 200
* 0 <= grid[i][j] <= 100

=end

# Runtime 72 ms
# Memory 212.3 MB
# @param {Integer[][]} grid
# @return {Integer}
def min_path_sum(grid)
  acc = [0] + [Float::INFINITY] * (grid[0].size - 1)

  grid.each { |row|
    left = Float::INFINITY
    acc.map!.with_index { |n, i| left = row[i] + (left < n ? left : n) }
  }

  acc.last
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_min_path_sum < Test::Unit::TestCase
  def test_
    assert_equal 7, min_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]])
    # assert_equal 12, min_path_sum([[1,2,3],[4,5,6]])
  end
end
"
0066,plus-one,"# frozen_string_literal: true

# 66. Plus One
# https://leetcode.com/problems/plus-one

=begin

You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.
Increment the large integer by one and return the resulting array of digits.

# Constraints:

* 1 <= digits.length <= 100
* 0 <= digits[i] <= 9
* digits does not contain any leading 0's.
=end

# @param {Integer[]} digits
# @return {Integer[]}
def plus_one(digits)
  carryover, pointer = 1, -1

  while carryover.positive?
    break digits.unshift(carryover) if digits[pointer].nil?

    sum = digits[pointer] + carryover
    carryover = sum / 10
    digits[pointer] = sum % 10
    pointer -= 1
  end

  digits
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_plus_one < Test::Unit::TestCase
  def test_
    assert_equal [1, 2, 4], plus_one([1, 2, 3])
    assert_equal [4, 3, 2, 2], plus_one([4, 3, 2, 1])
    assert_equal [1, 0], plus_one([9])
  end
end
"
0067,add-binary,"# frozen_string_literal: true

# 67. Add Binary
# https://leetcode.com/problems/add-binary

# @param {String} a
# @param {String} b
# @return {String}
def add_binary1(a, b)
  (a.to_i(2) + b.to_i(2)).to_s(2)
end

# @param {String} a
# @param {String} b
# @return {String}
def add_binary2(a, b)
  a_len = -(a.size)
  b_len = -(b.size)

  i, carry, res = -1, 0, """"

  while i >= a_len || i >= b_len
    a_bit = i >= a_len ? a[i].to_i : 0
    b_bit = i >= b_len ? b[i].to_i : 0

    sum = a_bit + b_bit + carry
    res = (sum % 2).to_s + res
    carry = sum / 2

    i -= 1
  end

  carry > 0 ? ""1"" + res : res
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_add_binary1 < Test::Unit::TestCase
  def test_
    assert_equal ""100"", add_binary1(""11"", ""1"")
    assert_equal ""10101"", add_binary1(""1010"", ""1011"")

    assert_equal ""100"", add_binary2(""11"", ""1"")
    assert_equal ""10101"", add_binary2(""1010"", ""1011"")
  end
end

require ""benchmark""

a = ""1010111010101010101111100101010100110000101011101101011""
b = ""100010101000100111011101010101000011100101011110101""
Benchmark.bm do |x|
  x.report { add_binary1(a, b) }
  x.report { add_binary2(a, b) }
end

# user     system      total        real
# 0.000013   0.000002   0.000015 (  0.000009)
# 0.000053   0.000011   0.000064 (  0.000064)
"
0068,text-justification,"# frozen_string_literal: true

# 68. Text Justification
# https://leetcode.com/problems/text-justification
# Hard

=begin
Given an array of strings words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.

You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters.

Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.

For the last line of text, it should be left-justified, and no extra space is inserted between words.

Note:

A word is defined as a character sequence consisting of non-space characters only.
Each word's length is guaranteed to be greater than 0 and not exceed maxWidth.
The input array words contains at least one word.

Example 1:
Input: words = [""This"", ""is"", ""an"", ""example"", ""of"", ""text"", ""justification.""], maxWidth = 16
Output:
[
   ""This    is    an"",
   ""example  of text"",
   ""justification.  ""
]

Example 2:
Input: words = [""What"",""must"",""be"",""acknowledgment"",""shall"",""be""], maxWidth = 16
Output:
[
  ""What   must   be"",
  ""acknowledgment  "",
  ""shall be        ""
]
Explanation: Note that the last line is ""shall be    "" instead of ""shall     be"", because the last line must be left-justified instead of fully-justified.
Note that the second line is also left-justified because it contains only one word.

Example 3:
Input: words = [""Science"",""is"",""what"",""we"",""understand"",""well"",""enough"",""to"",""explain"",""to"",""a"",""computer."",""Art"",""is"",""everything"",""else"",""we"",""do""], maxWidth = 20
Output:
[
  ""Science  is  what we"",
  ""understand      well"",
  ""enough to explain to"",
  ""a  computer.  Art is"",
  ""everything  else  we"",
  ""do                  ""
]
=end

# @param {String[]} words
# @param {Integer} max_width
# @return {String[]}
def full_justify(words, max_width)
  v, line = [], []
  words.each do |word|
    if (line + [word]).join("" "").size > max_width
      v.push(join_line(line, max_width))
      line = []
    end
    line.push(word)
  end
  v.push(join_line(line, max_width, true))
end

def join_line(line, max_width, last = false)
  return line.join("" "") + "" "" * (max_width - line.join("" "").size) if (line.size == 1) || (last == true)
  space, extra = (max_width - line.join.size).divmod(line.size - 1)
  line[0..extra].join("" "" * (space + 1)) + "" "" * space + line[extra + 1..-1].join("" "" * space)
end
"
0069,sqrtx,"# frozen_string_literal: true

# 69. Sqrt(x)
# https://leetcode.com/problems/sqrtx

# @param {Integer} x
# @return {Integer}
def my_sqrt(x)
  return 0 if x.zero?
  return 1 if x < 4

  prev = 2
  cur = x / 2
  while (prev - cur).abs > 1
    return cur if cur * cur == x

    prev = cur
    cur = (cur + x / cur) / 2
  end
  cur * cur > x ? (cur - 1) : cur
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_my_sqrt < Test::Unit::TestCase
  def test_
    assert_equal 2, my_sqrt(4)
    assert_equal 2, my_sqrt(8)
  end
end
"
0070,climbing-stairs,"# frozen_string_literal: true

# 70. Climbing Stairs
# https://leetcode.com/problems/climbing-stairs

# @param {Integer} n
# @return {Integer}
def climb_stairs(n)
  fib = { 0 => 0, 1 => 1, 2 => 2 }
  fib.default_proc = ->(f, n) { f[n] = f[n - 1] + f[n - 2] }
  fib[n]
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_climb_stairs < Test::Unit::TestCase
  def test_
    assert_equal 2, climb_stairs(2)
    assert_equal 3, climb_stairs(3)
  end
end
"
0071,simplify-path,"# frozen_string_literal: true

# 71. Simplify Path
# https://leetcode.com/problems/simplify-path/
# Medium

=begin
Given a string path, which is an absolute path (starting with a slash '/') to a file or directory in a Unix-style file system, convert it to the simplified canonical path.

In a Unix-style file system, a period '.' refers to the current directory, a double period '..' refers to the directory up a level, and any multiple consecutive slashes (i.e. '//') are treated as a single slash '/'. For this problem, any other format of periods such as '...' are treated as file/directory names.

The canonical path should have the following format:

The path starts with a single slash '/'.
Any two directories are separated by a single slash '/'.
The path does not end with a trailing '/'.
The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period '.' or double period '..')
Return the simplified canonical path.

### Example 1:
Input: path = ""/home/""
Output: ""/home""
Explanation: Note that there is no trailing slash after the last directory name.

### Example 2:
Input: path = ""/../""
Output: ""/""
Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.

### Example 3:
Input: path = ""/home//foo/""
Output: ""/home/foo""
Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one.

### Constraints:
1 <= path.length <= 3000
path consists of English letters, digits, period '.', slash '/' or '_'.
path is a valid absolute Unix path.
=end

# @param {String} path
# @return {String}
# @param {String} path
# @return {String}
def simplify_path(path)
  a = path.split(""/"")
  stack = []

  a.length.times do |i|
    next if a[i] == ""."" || a[i] == """"

    if a[i] == ""..""
      stack.pop unless stack.empty?
    else
      stack << a[i]
    end
  end

  ""/"" + stack.join(""/"")
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_simplify_path < Test::Unit::TestCase
  def test_
    assert_equal ""/home"", simplify_path(""/home/"")
    assert_equal(""/"", simplify_path(""/../""))
    assert_equal(""/home/foo"", simplify_path(""/home//foo/""))
  end
end
"
0072,edit-distance,"# frozen_string_literal: true

# 72. Edit Distance
# https://leetcode.com/problems/edit-distance
# Hard

# @param {String} word1
# @param {String} word2
# @return {Integer}
def min_distance(word1, word2)
  n = word2.length
  curr = (0..n).to_a

  word1.length.times do |i|
    prev, curr = curr, [i + 1] + [0] * n

    n.times do |j|
      curr[j + 1] = word1[i] == word2[j] ? prev[j] : [curr[j], prev[j], prev[j + 1]].min + 1
    end
  end

  curr[n]
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_min_distance < Test::Unit::TestCase
  def test_
    assert_equal 3, min_distance(""horse"", ""ros"")
    assert_equal 5, min_distance(""intention"", ""execution"")
  end
end
"
0073,set-matrix-zeroes,"# frozen_string_literal: true

# 73. Set Matrix Zeroes
# https://leetcode.com/problems/set-matrix-zeroes
# Medium

=begin
Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.

You must do it in place.

Example 1:
Input: matrix = [[1,1,1],[1,0,1],[1,1,1]]
Output: [[1,0,1],[0,0,0],[1,0,1]]

Example 2:
Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]

Constraints:
m == matrix.length
n == matrix[0].length
1 <= m, n <= 200
-231 <= matrix[i][j] <= 231 - 1
=end

# @param {Integer[][]} matrix
# @return {Void} Do not return anything, modify matrix in-place instead.
def set_zeroes(matrix)
  rows = Array.new(matrix.size, false)
  columns = Array.new(matrix[0].size, false)

  (0...matrix.size).each do |i|
    (0...matrix[0].size).each do |j|
      if matrix[i][j].zero?
        rows[i] = true
        columns[j] = true
      end
    end
  end

  (0...matrix.size).each do |i|
    (0...matrix[0].size).each do |j|
      matrix[i][j] = 0 if rows[i] || columns[j]
    end
  end
end
"
0074,search-a-2d-matrix,"# frozen_string_literal: true

# 74. Search a 2D Matrix
# https://leetcode.com/problems/search-a-2d-matrix
# Medium

=begin
You are given an m x n integer matrix matrix with the following two properties:

Each row is sorted in non-decreasing order.
The first integer of each row is greater than the last integer of the previous row.
Given an integer target, return true if target is in matrix or false otherwise.

You must write a solution in O(log(m * n)) time complexity.

### Example 1:
Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
Output: true

### Example 2:
Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
Output: false

Constraints:
* m == matrix.length
* n == matrix[i].length
* 1 <= m, n <= 100
* -104 <= matrix[i][j], target <= 104
=end

# @param {Integer[][]} matrix
# @param {Integer} target
# @return {Boolean}
def search_matrix(matrix, target)
  m, n = matrix.size, matrix[0].size
  i = (0...m * n).bsearch { |i| matrix[i / n][i % n] >= target }
  !!i && matrix[i / n][i % n] == target
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_search_matrix < Test::Unit::TestCase
  def test_
    assert_equal true, search_matrix([[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]], 3)
    assert_equal false, search_matrix([[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]], 13)
  end
end
"
0076,minimum-window-substring,"# frozen_string_literal: true

# 76. Minimum Window Substring
# https://leetcode.com/problems/minimum-window-substring/
# Hard

=begin
Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string """".

The testcases will be generated such that the answer is unique.

Example 1:
Input: s = ""ADOBECODEBANC"", t = ""ABC""
Output: ""BANC""
Explanation: The minimum window substring ""BANC"" includes 'A', 'B', and 'C' from string t.

Example 2:
Input: s = ""a"", t = ""a""
Output: ""a""
Explanation: The entire string s is the minimum window.

Example 3:
Input: s = ""a"", t = ""aa""
Output: """"
Explanation: Both 'a's from t must be included in the window.
Since the largest window of s only has one 'a', return empty string.

Constraints:
* m == s.length
* n == t.length
* 1 <= m, n <= 105
* s and t consist of uppercase and lowercase English letters.
=end

# @param {String} s
# @param {String} t
# @return {String}
def min_window(s, t)
  h = Hash.new
  t.each_char do |c|
    h[c] = h[c] ? h[c] + 1 : 1
  end
  max = s.size + 1
  i, j = 0, 0
  c = 0
  res = """"
  while j < s.size
    if c != t.size
      if h[s[j]]
        c += 1 if h[s[j]] > 0
        h[s[j]] -= 1
      end
      j += 1
    end

    while c == t.size
      if h[s[i]]
        c -= 1 if h[s[i]] >= 0
        h[s[i]] += 1
        if j - i < max
          max = j - i
          res = s[i...j]
        end
      end
      i += 1
    end
  end
  res
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_min_window < Test::Unit::TestCase
  def test_
    assert_equal ""BANC"", min_window(""ADOBECODEBANC"", ""ABC"")
    assert_equal ""a"", min_window(""a"", ""a"")
    assert_equal """", min_window(""a"", ""aa"")
  end
end
"
0077,combinations,"# frozen_string_literal: true

# 77. Combinations
# https://leetcode.com/problems/combinations
# Medium

=begin
Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].

You may return the answer in any order.

Example 1:
Input: n = 4, k = 2
Output: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
Explanation: There are 4 choose 2 = 6 total combinations.
Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.

Example 2:
Input: n = 1, k = 1
Output: [[1]]
Explanation: There is 1 choose 1 = 1 total combination.

Constraints:
* 1 <= n <= 20
* 1 <= k <= n
=end

# @param {Integer} n
# @param {Integer} k
# @return {Integer[][]}
def combine(n, k)
  return (1..n).map { |i| [i] } if k == 1

  i = n
  result = []

  while i > 1
    result += combine(i - 1, k - 1).map { |tuple| tuple + [i] }
    i -= 1
  end

  result
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_combine < Test::Unit::TestCase
  def test_
    assert_equal [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]].sort, combine(4, 2).sort
    assert_equal [[1]], combine(1, 1)
  end
end
"
0079,word-search,"# frozen_string_literal: true

# 79. Word Search
# https://leetcode.com/problems/word-search
# Medium

=begin
Given an m x n grid of characters board and a string word, return true if word exists in the grid.

The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.

Example 1:
Input: board = [[""A"",""B"",""C"",""E""],[""S"",""F"",""C"",""S""],[""A"",""D"",""E"",""E""]], word = ""ABCCED""
Output: true

Example 2:
Input: board = [[""A"",""B"",""C"",""E""],[""S"",""F"",""C"",""S""],[""A"",""D"",""E"",""E""]], word = ""SEE""
Output: true

Example 3:
Input: board = [[""A"",""B"",""C"",""E""],[""S"",""F"",""C"",""S""],[""A"",""D"",""E"",""E""]], word = ""ABCB""
Output: false

Constraints:
* m == board.length
* n = board[i].length
* 1 <= m, n <= 6
* 1 <= word.length <= 15
* board and word consists of only lowercase and uppercase English letters.
=end

# @param {Character[][]} board
# @param {String} word
# @return {Boolean}
def dfs(board, word, i, j)
  return true if word == """"
  return false if i < 0 || j < 0 || i >= board.length || j >= board[0].length || board[i][j] != word[0]
  pom = board[i][j]
  board[i][j] = ""#""
  word = word[1..-1]
  return true if dfs(board, word, i - 1, j)
  return true if dfs(board, word, i, j - 1)
  return true if dfs(board, word, i + 1, j)
  return true if dfs(board, word, i, j + 1)
  board[i][j] = pom
  false
end

def exist(board, word)
  set1 = board.flatten.to_set
  set2 = word.split("""").to_set
  return false if !(set1 >= set2)
  (0...board.length).each do |i|
    (0...board[0].length).each do |j|
      return true if dfs(board, word, i, j)
    end
  end
  false
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_exist < Test::Unit::TestCase
  def test_
    assert_equal true, exist([[""A"", ""B"", ""C"", ""E""], [""S"", ""F"", ""C"", ""S""], [""A"", ""D"", ""E"", ""E""]], ""ABCCED"")
    assert_equal true, exist([[""A"", ""B"", ""C"", ""E""], [""S"", ""F"", ""C"", ""S""], [""A"", ""D"", ""E"", ""E""]], ""SEE"")
    assert_equal false, exist([[""A"", ""B"", ""C"", ""E""], [""S"", ""F"", ""C"", ""S""], [""A"", ""D"", ""E"", ""E""]], ""ABCB"")
  end
end
"
0080,remove-duplicates-from-sorted-array-ii,"# frozen_string_literal: true

# 80. Remove Duplicates from Sorted Array II
# https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii
# Medium

=begin
Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.

Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.

Return k after placing the final result in the first k slots of nums.

Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.

Custom Judge:

The judge will test your solution with the following code:

int[] nums = [...]; // Input array
int[] expectedNums = [...]; // The expected answer with correct length

int k = removeDuplicates(nums); // Calls your implementation

assert k == expectedNums.length;
for (int i = 0; i < k; i++) {
    assert nums[i] == expectedNums[i];
}
If all assertions pass, then your solution will be accepted.

Example 1:
Input: nums = [1,1,1,2,2,3]
Output: 5, nums = [1,1,2,2,3,_]
Explanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).

Example 2:
Input: nums = [0,0,1,1,1,1,2,3,3]
Output: 7, nums = [0,0,1,1,2,3,3,_,_]
Explanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).

Constraints:
1 <= nums.length <= 3 * 104
-104 <= nums[i] <= 104
nums is sorted in non-decreasing order.
=end

# @param {Integer[]} nums
# @return {Integer}
def remove_duplicates(nums)
  nums.each_with_object([0]) do |num, a|
    if a[0] < 2 || num > nums[a[0] - 2]
      a[0] += 1
      nums[a[0] - 1] = num
    end
  end.then(&:first)
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_remove_duplicates < Test::Unit::TestCase
  def test_
    assert_equal 5, remove_duplicates([1, 1, 1, 2, 2, 3])
    assert_equal 7, remove_duplicates([0, 0, 1, 1, 1, 1, 2, 3, 3])
  end
end
"
0081,search-in-rotated-sorted-array-ii,"# frozen_string_literal: true

# 81. Search in Rotated Sorted Array II
# Medium
# https://leetcode.com/problems/search-in-rotated-sorted-array-ii

=begin
There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values).
Before being passed to your function, nums is rotated at an unknown pivot index k (0 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4].
Given the array nums after the rotation and an integer target, return true if target is in nums, or false if it is not in nums.
You must decrease the overall operation steps as much as possible.

Example 1:
Input: nums = [2,5,6,0,0,1,2], target = 0
Output: true

Example 2:
Input: nums = [2,5,6,0,0,1,2], target = 3
Output: false

Constraints:
* 1 <= nums.length <= 5000
* -104 <= nums[i] <= 104
* nums is guaranteed to be rotated at some pivot.
* -104 <= target <= 104
=end

# @param {Integer[]} nums
# @param {Integer} target
# @return {Boolean}
def search(nums, target)
  left = 0
  right = nums.length - 1

  while left <= right do
    mid = (left + right) / 2
    return true if nums[mid] == target

    if nums[left] < nums[mid]
      if nums[left] <= target && target < nums[mid]
        right = mid - 1
      else
        left = mid + 1
      end
    elsif nums[left] > nums[mid]
      if nums[mid] < target && target <= nums[right]
        left = mid + 1
      else
        right = mid - 1
      end
    else
      left += 1
    end
  end
  false
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_search < Test::Unit::TestCase
  def test_
    assert_equal true, search([2, 5, 6, 0, 0, 1, 2], 0)
    assert_equal false, search([2, 5, 6, 0, 0, 1, 2], 3)
  end
end
"
0082,remove-duplicates-from-sorted-list-ii,"# frozen_string_literal: true

# 82. Remove Duplicates from Sorted List II
# https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii
# Medium

=begin
Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.

Example 1:
Input: head = [1,2,3,3,4,4,5]
Output: [1,2,5]

Example 2:
Input: head = [1,1,1,2,3]
Output: [2,3]

Constraints:
* The number of nodes in the list is in the range [0, 300].
* -100 <= Node.val <= 100
* The list is guaranteed to be sorted in ascending order.
=end

# Definition for singly-linked list.
# class ListNode
#     attr_accessor :val, :next
#     def initialize(val = 0, _next = nil)
#         @val = val
#         @next = _next
#     end
# end
# @param {ListNode} head
# @return {ListNode}
def delete_duplicates(head)
  dummy = ListNode.new(-101, head)
  prev = dummy
  current = head

  while current
    if current.next && current.val == current.next.val
      while current.next && current.val == current.next.val
        current = current.next
      end
      prev.next = current.next
    else
      prev = current
    end
    current = current.next
  end

  dummy.next
end
"
0086,partition-list,"# frozen_string_literal: true

# 86. Partition List
# https://leetcode.com/problems/partition-list
# Medium

=begin
Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.

You should preserve the original relative order of the nodes in each of the two partitions.

Example 1:
Input: head = [1,4,3,2,5,2], x = 3
Output: [1,2,2,4,3,5]

Example 2:
Input: head = [2,1], x = 2
Output: [1,2]

Constraints:
* The number of nodes in the list is in the range [0, 200].
* -100 <= Node.val <= 100
* -200 <= x <= 200
=end

# Definition for singly-linked list.
# class ListNode
#     attr_accessor :val, :next
#     def initialize(val = 0, _next = nil)
#         @val = val
#         @next = _next
#     end
# end
# @param {ListNode} head
# @param {Integer} x
# @return {ListNode}
def partition(head, x)
  # Create dummy nodes for before and after lists
  before = ListNode.new(0)
  after = ListNode.new(0)

  # Initialize pointers for before and after lists
  before_ptr = before
  after_ptr = after

  # Iterate through the linked list
  while head
    if head.val < x
      # Append the node to the before list
      before_ptr.next = head
      before_ptr = before_ptr.next
    else
      # Append the node to the after list
      after_ptr.next = head
      after_ptr = after_ptr.next
    end

    # Move to the next node in the original list
    head = head.next
  end

  # Connect the before list with the after list
  before_ptr.next = after.next

  # Set the last node of the after list to nil
  after_ptr.next = nil

  # Return the new head of the partitioned list
  before.next
end
"
0087,scramble-string,"# frozen_string_literal: true

# 87. Scramble String
# https://leetcode.com/problems/scramble-string

=begin

We can scramble a string s to get a string t using the following algorithm:

If the length of the string is 1, stop.
If the length of the string is > 1, do the following:
* Split the string into two non-empty substrings at a random index, i.e., if the string is s, divide it to x and y where s = x + y.
* Randomly decide to swap the two substrings or to keep them in the same order. i.e., after this step, s may become s = x + y or s = y + x.
* Apply step 1 recursively on each of the two substrings x and y.
Given two strings s1 and s2 of the same length, return true if s2 is a scrambled string of s1, otherwise, return false.

### Example 1:
Input: s1 = ""great"", s2 = ""rgeat""
Output: true
Explanation: One possible scenario applied on s1 is:
""great"" --> ""gr/eat"" // divide at random index.
""gr/eat"" --> ""gr/eat"" // random decision is not to swap the two substrings and keep them in order.
""gr/eat"" --> ""g/r / e/at"" // apply the same algorithm recursively on both substrings. divide at random index each of them.
""g/r / e/at"" --> ""r/g / e/at"" // random decision was to swap the first substring and to keep the second substring in the same order.
""r/g / e/at"" --> ""r/g / e/ a/t"" // again apply the algorithm recursively, divide ""at"" to ""a/t"".
""r/g / e/ a/t"" --> ""r/g / e/ a/t"" // random decision is to keep both substrings in the same order.
The algorithm stops now, and the result string is ""rgeat"" which is s2.
As one possible scenario led s1 to be scrambled to s2, we return true.

### Example 2:
Input: s1 = ""abcde"", s2 = ""caebd""
Output: false

### Example 3:
Input: s1 = ""a"", s2 = ""a""
Output: true

### Constraints:
* s1.length == s2.length
* 1 <= s1.length <= 30
* s1 and s2 consist of lowercase English letters.

=end

# @param {String} s1
# @param {String} s2
# @return {Boolean}
def is_scramble1(s1, s2)
  return true if s1 == s2

  len = s1.length
  count = Array.new(26, 0)
  (0...len).each do |i|
    count[s1[i].ord - 97] += 1
    count[s2[i].ord - 97] -= 1
  end

  (0...26).each do |i|
    return false if count[i] != 0
  end

  (1..len - 1).each do |i|
    return true if is_scramble1(s1[0...i], s2[0...i]) && is_scramble1(s1[i..-1], s2[i..-1])
    return true if is_scramble1(s1[0...i], s2[len - i..-1]) && is_scramble1(s1[i..-1], s2[0...len - i])
  end

  false
end

# Runtime: 157 ms
# Memory: 211 MB
# @param {String} s1
# @param {String} s2
# @return {Boolean}
def is_scramble2(s1, s2)
  z = s1.size
  @s1 = s1
  @s2 = s2
  @_scramble = Array.new(z) { Array.new(z) { [] } }
  scramble?(0, 0, z)
end

def scramble?(a_i, b_i, z)
  cache = @_scramble[a_i][b_i]

  if cache[z].nil?
    cache[z] =
      if z == 1
        @s1[a_i] == @s2[b_i]
      else
        (1..z - 1).any? { |cut|
          rem = z - cut
          scramble?(a_i, b_i, cut) && scramble?(a_i + cut, b_i + cut, rem) ||
            scramble?(a_i, b_i + rem, cut) && scramble?(a_i + cut, b_i, rem)
        }
      end
  else
    cache[z]
  end
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_is_scramble < Test::Unit::TestCase
  def test_
    assert_equal true, is_scramble1(""great"", ""rgeat"")
    assert_equal false, is_scramble1(""abcde"", ""caebd"")
    assert_equal true, is_scramble1(""a"", ""a"")

    assert_equal true, is_scramble2(""great"", ""rgeat"")
    assert_equal false, is_scramble2(""abcde"", ""caebd"")
    assert_equal true, is_scramble2(""a"", ""a"")
  end
end

# ********************#
#     Benchmark       #
# ********************#

require ""benchmark""

s1 = ""eebaacbcbcadaaedceaaacadccd""
s2 = ""eadcaacabaddaceacbceaabeccd""
Benchmark.bm do |x|
  x.report(""is_scramble2: "") { is_scramble2(s1, s2) }
  # x.report(""is_scramble1: "") { is_scramble1(s1, s2) }
end

# user     system      total        real
# is_scramble2:   0.019557   0.000188   0.019745 (  0.021551)
# is_scramble1: TLE
"
0088,merge-sorted-array,"# frozen_string_literal: true

# 88. Merge Sorted Array
# https://leetcode.com/problems/merge-sorted-array
# Easy

=begin
You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.

Merge nums1 and nums2 into a single array sorted in non-decreasing order.

The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.

Example 1:
Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
Output: [1,2,2,3,5,6]
Explanation: The arrays we are merging are [1,2,3] and [2,5,6].
The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.

Example 2:
Input: nums1 = [1], m = 1, nums2 = [], n = 0
Output: [1]
Explanation: The arrays we are merging are [1] and [].
The result of the merge is [1].

Example 3:
Input: nums1 = [0], m = 0, nums2 = [1], n = 1
Output: [1]
Explanation: The arrays we are merging are [] and [1].
The result of the merge is [1].
Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.

Constraints:

nums1.length == m + n
nums2.length == n
0 <= m, n <= 200
1 <= m + n <= 200
-109 <= nums1[i], nums2[j] <= 109
=end

# @param {Integer[]} nums1
# @param {Integer} m
# @param {Integer[]} nums2
# @param {Integer} n
# @return {Void} Do not return anything, modify nums1 in-place instead.
def merge(nums1, m, nums2, n)
  i = nums1.length - 1
  m -= 1
  n -= 1

  while i >= 0 && n >= 0
    if m >= 0 && nums1[m] > nums2[n]
      nums1[i] = nums1[m]
      m -= 1
    else
      nums1[i] = nums2[n]
      n -= 1
    end
    i -= 1
  end
end
"
0091,decode-ways,"# frozen_string_literal: true

# 91. Decode Ways
# https://leetcode.com/problems/decode-ways

# @param {String} s
# @return {Integer}
def num_decodings(s)
  i1, i2 = 1, 1
  for i in 1..s.length do
    count = s[i - 1, 1] != ""0"" ? i1 : 0
    count += i2 if s[i - 2, 2].between?(""10"", ""26"") && i > 1
    i2 = i1
    i1 = count
    end
  count
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_num_decodings < Test::Unit::TestCase
  def test_
    assert_equal 2, num_decodings(""12"")
    assert_equal 3, num_decodings(""226"")
    assert_equal 0, num_decodings(""06"")
  end
end
"
0092,reverse-linked-list-ii,"# frozen_string_literal: true

# 92. Reverse Linked List II
# https://leetcode.com/problems/reverse-linked-list-ii
# Medium

=begin
Given the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the reversed list.

Example 1:
Input: head = [1,2,3,4,5], left = 2, right = 4
Output: [1,4,3,2,5]

Example 2:
Input: head = [5], left = 1, right = 1
Output: [5]

Constraints:
* The number of nodes in the list is n.
* 1 <= n <= 500
* -500 <= Node.val <= 500
* 1 <= left <= right <= n
=end

# Definition for singly-linked list.
# class ListNode
#     attr_accessor :val, :next
#     def initialize(val = 0, _next = nil)
#         @val = val
#         @next = _next
#     end
# end
# @param {ListNode} head
# @param {Integer} left
# @param {Integer} right
# @return {ListNode}
def reverse_between(head, left, right)
  dummy = ListNode.new(0)
  dummy.next = head
  prev = dummy

  (left - 1).times do
    prev = prev.next
  end

  start = prev.next
  then_node = start.next

  (right - left).times do
    start.next = then_node.next
    then_node.next = prev.next
    prev.next = then_node
    then_node = start.next
  end

  dummy.next
end
"
0094,binary-tree-inorder-traversal,"# 94. Binary Tree Inorder Traversal
# Easy
# https://leetcode.com/problems/binary-tree-inorder-traversal

=begin
Given the root of a binary tree, return the inorder traversal of its nodes' values.

Example 1:
Input: root = [1,null,2,3]
Output: [1,3,2]

Example 2:
Input: root = []
Output: []

Example 3:
Input: root = [1]
Output: [1]

Constraints:
The number of nodes in the tree is in the range [0, 100].
-100 <= Node.val <= 100
=end

# frozen_string_literal: true

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root
# @return {Integer[]}
def inorder_traversal(root)
  ret = []
  stack = [root]
  while true
    top = stack[-1]
    if !top&.left.nil?
      stack << top.left
    else
      t = stack.pop
      t = stack.pop if t.nil?
      break if t.nil?
      ret << t.val
      stack << t.right
    end
  end
  ret
end
"
0095,unique-binary-search-trees-ii,"# frozen_string_literal: true

# 95. Unique Binary Search Trees II
# Medium
# https://leetcode.com/problems/unique-binary-search-trees-ii

=begin
Given an integer n, return all the structurally unique BST's (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order.

Example 1:
Input: n = 3
Output: [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]

Example 2:
Input: n = 1
Output: [[1]]

Constraints:
* 1 <= n <= 8
=end

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {Integer} n
# @return {TreeNode[]}
def generate(start_val, end_val)
  return [nil] if start_val > end_val

  result = []
  (start_val..end_val).each do |i|
    left_trees = generate(start_val, i - 1)
    right_trees = generate(i + 1, end_val)

    left_trees.each do |l|
      right_trees.each do |r|
        node = TreeNode.new(i)
        node.left = l
        node.right = r
        result << node
      end
    end
  end
  result
end

def generate_trees(n)
  return [] if n == 0
  generate(1, n)
end
"
0097,interleaving-string,"# frozen_string_literal: true

# 97. Interleaving String
# https://leetcode.com/problems/interleaving-string
# Medium

=begin
Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2.

An interleaving of two strings s and t is a configuration where s and t are divided into n and m substrings respectively, such that:

s = s1 + s2 + ... + sn
t = t1 + t2 + ... + tm
|n - m| <= 1
The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...
Note: a + b is the concatenation of strings a and b.

Example 1:
Input: s1 = ""aabcc"", s2 = ""dbbca"", s3 = ""aadbbcbcac""
Output: true
Explanation: One way to obtain s3 is:
Split s1 into s1 = ""aa"" + ""bc"" + ""c"", and s2 into s2 = ""dbbc"" + ""a"".
Interleaving the two splits, we get ""aa"" + ""dbbc"" + ""bc"" + ""a"" + ""c"" = ""aadbbcbcac"".
Since s3 can be obtained by interleaving s1 and s2, we return true.

Example 2:
Input: s1 = ""aabcc"", s2 = ""dbbca"", s3 = ""aadbbbaccc""
Output: false
Explanation: Notice how it is impossible to interleave s2 with any other string to obtain s3.

Example 3:
Input: s1 = """", s2 = """", s3 = """"
Output: true

Constraints:
0 <= s1.length, s2.length <= 100
0 <= s3.length <= 200
s1, s2, and s3 consist of lowercase English letters.
=end

# @param {String} s1
# @param {String} s2
# @param {String} s3
# @return {Boolean}
def is_interleave(s1, s2, s3)
  return false if s1.length + s2.length != s3.length

  row = [true] * (s2.length + 1)
  (1...row.length).each do |j|
    row[j] = row[j - 1] && s2[j - 1] == s3[j - 1]
  end

  s1.length.times do |i|
    row[0] = row[0] && s1[i] == s3[i]
    (1...row.length).each do |j|
      row[j] = (row[j] && s1[i] == s3[i + j]) || (row[j - 1] && s2[j - 1] == s3[i + j])
    end
  end

  row[-1]
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_is_interleave < Test::Unit::TestCase
  def test_
    assert_equal true, is_interleave(""aabcc"", ""dbbca"", ""aadbbcbcac"")
    assert_equal false, is_interleave(""aabcc"", ""dbbca"", ""aadbbbaccc"")
    assert_equal true, is_interleave("""", """", """")
  end
end
"
0098,validate-binary-search-tree,"# frozen_string_literal: true

# 98. Validate Binary Search Tree
# https://leetcode.com/problems/validate-binary-search-tree

=begin

Given the root of a binary tree, determine if it is a valid binary search tree (BST).

A valid BST is defined as follows:

* The left subtree of a node contains only nodes with keys less than the node's key.
* The right subtree of a node contains only nodes with keys greater than the node's key.
* Both the left and right subtrees must also be binary search trees.

### Example 1:
Input: root = [2,1,3]
Output: true

### Example 2:
Input: root = [5,1,4,null,null,3,6]
Output: false
Explanation: The root node's value is 5 but its right child's value is 4.

### Constraints:
* The number of nodes in the tree is in the range [1, 104].
* -231 <= Node.val <= 231 - 1

=end

# Runtime: 83 ms
# Memory: 211.7 MB
# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root
# @return {Boolean}
def is_valid_bst(root, min = -Float::INFINITY, max = Float::INFINITY)
  !root ||
    min < root.val &&
    root.val < max &&
    is_valid_bst(root.left, min, root.val) &&
    is_valid_bst(root.right, root.val, max)
end
"
0100,same-tree,"# frozen_string_literal: true

# 100. Same Tree
# https://leetcode.com/problems/same-tree/
# Easy

=begin
Given the roots of two binary trees p and q, write a function to check if they are the same or not.

Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.

Example 1:
Input: p = [1,2,3], q = [1,2,3]
Output: true

Example 2:
Input: p = [1,2], q = [1,null,2]
Output: false

Example 3:
Input: p = [1,2,1], q = [1,1,2]
Output: false
=end

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} p
# @param {TreeNode} q
# @return {Boolean}
def is_same_tree(p, q)
  return true if p.nil? && q.nil?
  return false if p.nil? || q.nil? || p.val != q.val

  p.val == q.val && is_same_tree(p.left, q.left) && is_same_tree(p.right, q.right)
end
"
0101,symmetric-tree,"# frozen_string_literal: true

# 101. Symmetric Tree
# https://leetcode.com/problems/symmetric-tree

=begin

Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).

### Constraints:

* The number of nodes in the tree is in the range [1, 1000].
* -100 <= Node.val <= 100

=end

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root
# @return {Boolean}
def is_symmetric(root)
  return true unless root

  symmetric_trees?(root.left, root.right)
end

def symmetric_trees?(node1, node2)
  return true if node1.nil? && node2.nil?
  return false if node1&.val != node2&.val

  symmetric_trees?(node1.left, node2.right) && symmetric_trees?(node1.right, node2.left)
end
"
0102,binary-tree-level-order-traversal,"# frozen_string_literal: true

# 102. Binary Tree Level Order Traversal
# https://leetcode.com/problems/binary-tree-level-order-traversal

=begin

Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).

### Example 1:
Input: root = [3,9,20,null,null,15,7]
Output: [[3],[9,20],[15,7]]

### Example 2:
Input: root = [1]
Output: [[1]]

### Example 3:
Input: root = []
Output: []

### Constraints:
* The number of nodes in the tree is in the range [0, 2000].
* -1000 <= Node.val <= 1000

=end

# Runtime: 103 ms
# Memory: 211.2 MB
# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root
# @return {Integer[][]}
def level_order(root)
  return [] unless root

  result = []
  deque = [[root, 1]]

  until deque.empty?
    n, d = deque.shift
    result << [] if d > result.count
    result[d - 1] << n.val
    deque << [n.left, d + 1] if n.left
    deque << [n.right, d + 1] if n.right
  end

  result
end
"
0103,binary-tree-zigzag-level-order-traversal,"# frozen_string_literal: true

# 103. Binary Tree Zigzag Level Order Traversal
# https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root
# @return {Integer[][]}
def zigzag_level_order(root)
  return [] if root.nil?

  res = []
  stack = [root]
  count = 1
  until stack.empty?
    res << stack.map(&:val)
    count += 1
    arr = []
    stack.size.times do
      current = stack.pop
      if count.even?
        arr.push(current.right) if current.right
        arr.push(current.left) if current.left
      else
        arr.push(current.left) if current.left
        arr.push(current.right) if current.right
      end
    end
    stack = arr
  end

  res
end
"
0104,maximum-depth-of-binary-tree,"# frozen_string_literal: true

# 104. Maximum Depth of Binary Tree
# https://leetcode.com/problems/maximum-depth-of-binary-tree

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root
# @return {Integer}
def max_depth(root)
  root ? 1 + [max_depth(root.left), max_depth(root.right)].max : 0
end
"
0105,construct-binary-tree-from-preorder-and-inorder-traversal,"# frozen_string_literal: true

# 105. Construct Binary Tree from Preorder and Inorder Traversal
# https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal
# Medium

=begin
Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.

Example 1:
Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]

Example 2:
Input: preorder = [-1], inorder = [-1]
Output: [-1]

Constraints:
* 1 <= preorder.length <= 3000
* inorder.length == preorder.length
* -3000 <= preorder[i], inorder[i] <= 3000
* preorder and inorder consist of unique values.
* Each value of inorder also appears in preorder.
* preorder is guaranteed to be the preorder traversal of the tree.
* inorder is guaranteed to be the inorder traversal of the tree.
=end

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {Integer[]} preorder
# @param {Integer[]} inorder
# @return {TreeNode}
def build_tree(preorder, inorder)
  return nil if preorder.empty? || inorder.empty?

  root_val = preorder.shift
  root_index = inorder.index(root_val)

  root = TreeNode.new(root_val)
  root.left = build_tree(preorder, inorder[0...root_index])
  root.right = build_tree(preorder, inorder[root_index + 1..-1])

  root
end
"
0106,construct-binary-tree-from-inorder-and-postorder-traversal,"# frozen_string_literal: true

# 106. Construct Binary Tree from Inorder and Postorder Traversal
# https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal

=begin

Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.

### Constraints:

* 1 <= inorder.length <= 3000
* postorder.length == inorder.length
* -3000 <= inorder[i], postorder[i] <= 3000
* inorder and postorder consist of unique values.
* Each value of postorder also appears in inorder.
* inorder is guaranteed to be the inorder traversal of the tree.
* postorder is guaranteed to be the postorder traversal of the tree.

=end

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {Integer[]} inorder
# @param {Integer[]} postorder
# @return {TreeNode}
def build_tree(inorder, postorder)
  return nil if inorder.empty? || postorder.empty?

  current = postorder.pop
  root = TreeNode.new(current)
  mid = inorder.index(current)

  left_inorder = inorder[0...mid]
  right_inorder = inorder[mid + 1..-1]

  left_postorder = postorder.first(left_inorder.length)
  right_postorder = postorder.last(right_inorder.length)

  root.left = build_tree(left_inorder, left_postorder)
  root.right = build_tree(right_inorder, right_postorder)

  root
end
"
0108,convert-sorted-array-to-binary-search-tree,"# frozen_string_literal: true

# 108. Convert Sorted Array to Binary Search Tree
# https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree
# Easy

=begin

Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.

### Example 1:
Input: nums = [-10,-3,0,5,9]
Output: [0,-3,9,-10,null,5]
Explanation: [0,-10,5,null,-3,null,9] is also accepted:

### Example 2:
Input: nums = [1,3]
Output: [3,1]
Explanation: [1,null,3] and [3,1] are both height-balanced BSTs.

### Constraints:
* 1 <= nums.length <= 104
* -104 <= nums[i] <= 104
* nums is sorted in a strictly increasing order.

=end

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {Integer[]} nums
# @return {TreeNode}
def sorted_array_to_bst(nums, l = 0, r = nums.size, m = (l + r) / 2)
  TreeNode.new(nums[m], sorted_array_to_bst(nums, l, m), sorted_array_to_bst(nums, m + 1, r)) if l < r
end
"
0109,convert-sorted-list-to-binary-search-tree,"# frozen_string_literal: true

# 109. Convert Sorted List to Binary Search Tree
# https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree

=begin

Given the head of a singly linked list where elements are sorted in ascending order, convert it to a
height-balanced binary search tree.

# Constraints:

* The number of nodes in head is in the range [0, 2 * 104].
* -105 <= Node.val <= 105

=end

# Definition for singly-linked list.
# class ListNode
#     attr_accessor :val, :next
#     def initialize(val = 0, _next = nil)
#         @val = val
#         @next = _next
#     end
# end
# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {ListNode} head
# @return {TreeNode}
def sorted_list_to_bst(head)
  a = []
  while head
    a << head.val
    head = head.next
  end
  f = -> i, j do
    return nil if i >= j
    m = (i + j) / 2
    TreeNode.new a[m], f.(i, m), f.(m + 1, j)
  end
  f.(0, a.size)
end
"
0110,balanced-binary-tree,"# frozen_string_literal: true

# 110. Balanced Binary Tree
# https://leetcode.com/problems/balanced-binary-tree/
# Easy

=begin

Given a binary tree, determine if it is height-balanced.

### Example 1:
Input: root = [3,9,20,null,null,15,7]
Output: true

### Example 2:
Input: root = [1,2,2,3,3,null,null,4,4]
Output: false

### Example 3:
Input: root = []
Output: true

### Constraints:
* The number of nodes in the tree is in the range [0, 5000].
* -104 <= Node.val <= 104

=end

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root
# @return {Boolean}
def is_balanced(root)
  balanced_height(root, 0) >= 0
end

def balanced_height(root, height)
  return height unless root

  l = balanced_height(root.left, height + 1)
  r = balanced_height(root.right, height + 1)

  return -1 if l == -1 || r == -1 || (l - r).abs > 1

  [l, r].max
end
"
0111,minimum-depth-of-binary-tree,"# frozen_string_literal: true

# 111. Minimum Depth of Binary Tree
# Easy
# https://leetcode.com/problems/minimum-depth-of-binary-tree

=begin
Given a binary tree, find its minimum depth.
The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.
Note: A leaf is a node with no children.

Example 1:
Input: root = [3,9,20,null,null,15,7]
Output: 2

Example 2:
Input: root = [2,null,3,null,4,null,5,null,6]
Output: 5

Constraints:
* The number of nodes in the tree is in the range [0, 105].
* -1000 <= Node.val <= 1000
=end

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root
# @return {Integer}
def min_depth(root)
  return 0 if root.nil?
  return 1 + min_depth(root.right) if root.left.nil?
  return 1 + min_depth(root.left) if root.right.nil?
  1 + [min_depth(root.left), min_depth(root.right)].min
end
"
0112,path-sum,"# frozen_string_literal: true

# 112. Path Sum
# https://leetcode.com/problems/path-sum
# Easy

=begin
Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.

A leaf is a node with no children.

Example 1:
Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
Output: true
Explanation: The root-to-leaf path with the target sum is shown.

Example 2:
Input: root = [1,2,3], targetSum = 5
Output: false
Explanation: There two root-to-leaf paths in the tree:
(1 --> 2): The sum is 3.
(1 --> 3): The sum is 4.
There is no root-to-leaf path with sum = 5.

Example 3:
Input: root = [], targetSum = 0
Output: false
Explanation: Since the tree is empty, there are no root-to-leaf paths.

Constraints:
* The number of nodes in the tree is in the range [0, 5000].
* -1000 <= Node.val <= 1000
* -1000 <= targetSum <= 1000
=end

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root
# @param {Integer} target_sum
# @return {Boolean}
def has_path_sum(root, target_sum)
  return false if root.nil?

  if root.val == target_sum && root.left.nil? && root.right.nil?
    return true
  end

  has_path_sum(root.left, target_sum - root.val) || has_path_sum(root.right, target_sum - root.val)
end
"
0113,path-sum-ii,"# frozen_string_literal: true

# 113. Path Sum II
# https://leetcode.com/problems/path-sum-ii

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root
# @param {Integer} target_sum
# @return {Integer[][]}
def path_sum(root, target_sum, path = [])
  return [] if root.nil?

  target_sum -= root.val
  return [path + [root.val]] if root.left.nil? && root.right.nil? && target_sum.zero?

  path_sum(root.left, target_sum, path + [root.val]) +
    path_sum(root.right, target_sum, path + [root.val])
end

# **************** #
#       TEST       #
# **************** #

# TODO: Write tests
"
0114,flatten-binary-tree-to-linked-list,"# frozen_string_literal: true

# 114. Flatten Binary Tree to Linked List
# https://leetcode.com/problems/flatten-binary-tree-to-linked-list
# Medium

=begin
Given the root of a binary tree, flatten the tree into a ""linked list"":

The ""linked list"" should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null.
The ""linked list"" should be in the same order as a pre-order traversal of the binary tree.

Example 1:
Input: root = [1,2,5,3,4,null,6]
Output: [1,null,2,null,3,null,4,null,5,null,6]

Example 2:
Input: root = []
Output: []

Example 3:
Input: root = [0]
Output: [0]

Constraints:
* The number of nodes in the tree is in the range [0, 2000].
* -100 <= Node.val <= 100
=end

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root
# @return {Void} Do not return anything, modify root in-place instead.
def flatten(root)
  last = root
  q = []
  q.push(last) if root
  while ! q.empty?
    el = q.pop
    r, l = el.right, el.left
    el.right, el.left = nil, nil
    if el != last
      last.right = el
      last.left = nil
      last = last.right
    end
    q.push(r) if r
    q.push(l) if l
  end
  root
end
"
0117,populating-next-right-pointers-in-each-node-ii,"# frozen_string_literal: true

# 117. Populating Next Right Pointers in Each Node II
# https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii
# Medium

=begin
Given a binary tree

struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.

Initially, all next pointers are set to NULL.

Example 1:
Input: root = [1,2,3,4,5,null,7]
Output: [1,#,2,3,#,4,5,7,#]
Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level.

Example 2:
Input: root = []
Output: []


Constraints:
* The number of nodes in the tree is in the range [0, 6000].
* -100 <= Node.val <= 100
=end

# Definition for a Node.
# class Node
#     attr_accessor :val, :left, :right, :next
#     def initialize(val)
#         @val = val
#         @left, @right, @next = nil, nil, nil
#     end
# end

# @param {Node} root
# @return {Node}
def connect(root)
  queue = [root]

  until queue.empty?
    new_queue = []
    prev_node = nil

    until queue.empty?
      node = queue.shift

      prev_node.next = node if prev_node && node != prev_node
      prev_node = node

      new_queue << node.left if node && node.left
      new_queue << node.right if node && node.right
    end

    queue = new_queue
  end

  root
end
"
0118,pascals-triangle,"# frozen_string_literal: true

# 118. Pascal's Triangle
# Easy
# https://leetcode.com/problems/pascals-triangle

=begin
Given an integer numRows, return the first numRows of Pascal's triangle.
In Pascal's triangle, each number is the sum of the two numbers directly above it as shown:

Example 1:
Input: numRows = 5
Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]

Example 2:
Input: numRows = 1
Output: [[1]]

Constraints:
* 1 <= numRows <= 30
=end

# @param {Integer} num_rows
# @return {Integer[][]}
def generate(num_rows)
  result = [[1]]

  (num_rows - 1).times do
    prev_row = result.last
    row = [1]

    0.upto(prev_row.size - 2) do |i|
      row << prev_row[i] + prev_row[i + 1]
    end

    row << 1
    result << row
  end

  result
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_generate < Test::Unit::TestCase
  def test_
    assert_equal [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]], generate(5)
    assert_equal [[1]], generate(1)
  end
end
"
0119,pascals-triangle-ii,"# frozen_string_literal: true

# 119. Pascal's Triangle II
# Easy
# https://leetcode.com/problems/pascals-triangle-ii

=begin
Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal's triangle.
In Pascal's triangle, each number is the sum of the two numbers directly above it as shown:

Example 1:
Input: rowIndex = 3
Output: [1,3,3,1]

Example 2:
Input: rowIndex = 0
Output: [1]

Example 3:
Input: rowIndex = 1
Output: [1,1]

Constraints:
0 <= rowIndex <= 33
=end

# @param {Integer} row_index
# @return {Integer[]}
def get_row(row_index)
  return [1] if row_index == 0

  ans = [1]
  temp = 1
  for i in 1...row_index do
    temp = temp * (row_index - i + 1) / i
    ans << temp
  end
  ans << 1
  ans
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_get_row < Test::Unit::TestCase
  def test_
    assert_equal [1, 3, 3, 1], get_row(3)
    assert_equal [1], get_row(0)
    assert_equal [1, 1], get_row(1)
  end
end
"
0120,triangle,"# frozen_string_literal: true

# 120. Triangle
# https://leetcode.com/problems/triangle
# Medium

=begin
Given a triangle array, return the minimum path sum from top to bottom.

For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.

Example 1:
Input: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
Output: 11
Explanation: The triangle looks like:
   2
  3 4
 6 5 7
4 1 8 3
The minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).

Example 2:
Input: triangle = [[-10]]
Output: -10

Constraints:
1 <= triangle.length <= 200
triangle[0].length == 1
triangle[i].length == triangle[i - 1].length + 1
-104 <= triangle[i][j] <= 104
=end

# @param {Integer[][]} triangle
# @return {Integer}
def minimum_total(triangle)
  cost, last_cost = nil, nil
  triangle.size.times do |i|
    cost = triangle[triangle.size - i - 1]
    cost.size.times { |j| cost[j] += [last_cost[j], last_cost[j + 1]].min } if i > 0
    last_cost = cost
  end
  cost.first
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_minimum_total < Test::Unit::TestCase
  def test_
    assert_equal 11, minimum_total([[2], [3, 4], [6, 5, 7], [4, 1, 8, 3]])
    assert_equal(-10, minimum_total([[-10]]))
  end
end
"
0121,best-time-to-buy-and-sell-stock,"# frozen_string_literal: true

# 121. Best Time to Buy and Sell Stock
# https://leetcode.com/problems/best-time-to-buy-and-sell-stock

# @param {Integer[]} prices
# @return {Integer}
def max_profit(prices)
  min, max_prof = prices[0], 0
  prices.each.each do |p|
    min = [min, p].min
    max_prof = [max_prof, p - min].max
  end

  max_prof
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_max_profit < Test::Unit::TestCase
  def test_
    assert_equal 5, max_profit([7, 1, 5, 3, 6, 4])
    assert_equal 0, max_profit([7, 6, 4, 3, 1])
  end
end
"
0122,best-time-to-buy-and-sell-stock-ii,"# frozen_string_literal: true

# 122. Best Time to Buy and Sell Stock II
# https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii
# Medium

=begin
You are given an integer array prices where prices[i] is the price of a given stock on the ith day.

On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.

Find and return the maximum profit you can achieve.

Example 1:
Input: prices = [7,1,5,3,6,4]
Output: 7
Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.
Total profit is 4 + 3 = 7.

Example 2:
Input: prices = [1,2,3,4,5]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
Total profit is 4.

Example 3:
Input: prices = [7,6,4,3,1]
Output: 0
Explanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.

Constraints:
1 <= prices.length <= 3 * 104
0 <= prices[i] <= 104
=end

# @param {Integer[]} prices
# @return {Integer}
def max_profit(prices)
  prices.each_cons(2).reduce(0) { |s, (a, b)| b > a ? s + b - a : s }
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_max_profit < Test::Unit::TestCase
  def test_
    assert_equal 7, max_profit([7, 1, 5, 3, 6, 4])
    assert_equal 4, max_profit([1, 2, 3, 4, 5])
    assert_equal 0, max_profit([7, 6, 4, 3, 1])
  end
end
"
0123,best-time-to-buy-and-sell-stock-iii,"# frozen_string_literal: true

# 123. Best Time to Buy and Sell Stock III
# https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii
# Hard

=begin
You are given an array prices where prices[i] is the price of a given stock on the ith day.

Find the maximum profit you can achieve. You may complete at most two transactions.

Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).

Example 1:
Input: prices = [3,3,5,0,0,3,1,4]
Output: 6
Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.
Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.

Example 2:
Input: prices = [1,2,3,4,5]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.

Example 3:
Input: prices = [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.

Constraints:
1 <= prices.length <= 105
0 <= prices[i] <= 105
=end

# @param {Integer[]} prices
# @return {Integer}
def max_profit(prices)
  cost1 = cost2 = 100000
  profit1 = profit2 = temp = 0
  prices.each do |price|
    cost1   = price if cost1 > price
    profit1 = temp  if profit1 < temp = price - cost1
    cost2   = temp  if cost2 > temp = price - profit1
    profit2 = temp  if profit2 < temp = price - cost2
  end
  profit2
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_max_profit < Test::Unit::TestCase
  def test_
    assert_equal 6, max_profit([3, 3, 5, 0, 0, 3, 1, 4])
    assert_equal 4, max_profit([1, 2, 3, 4, 5])
    assert_equal 0, max_profit([7, 6, 4, 3, 1])
  end
end
"
0124,binary-tree-maximum-path-sum,"# frozen_string_literal: true

# 124. Binary Tree Maximum Path Sum
# https://leetcode.com/problems/binary-tree-maximum-path-sum
# Hard

=begin
A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.

The path sum of a path is the sum of the node's values in the path.

Given the root of a binary tree, return the maximum path sum of any non-empty path.

Example 1:
Input: root = [1,2,3]
Output: 6
Explanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.

Example 2:
Input: root = [-10,9,20,null,null,15,7]
Output: 42
Explanation: The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.

Constraints:
* The number of nodes in the tree is in the range [1, 3 * 104].
* -1000 <= Node.val <= 1000
=end

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root
# @return {Integer}
def max_path_sum(root)
  res = -Float::INFINITY
  dfs = -> node do
    return 0 unless node
    val = node.val
    max_left = dfs.(node.left)
    max_right = dfs.(node.right)
    path_node_max = val + max_left + max_right
    res = [res, path_node_max].max
    [ 0, val + max_left, val + max_right ].max
  end

  dfs.(root)
  res
end
"
0125,valid-palindrome,"# frozen_string_literal: true

# 125. Valid Palindrome
# https://leetcode.com/problems/valid-palindrome
# Easy

=begin
A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.

Given a string s, return true if it is a palindrome, or false otherwise.

Example 1:
Input: s = ""A man, a plan, a canal: Panama""
Output: true
Explanation: ""amanaplanacanalpanama"" is a palindrome.

Example 2:
Input: s = ""race a car""
Output: false
Explanation: ""raceacar"" is not a palindrome.

Example 3:
Input: s = "" ""
Output: true
Explanation: s is an empty string """" after removing non-alphanumeric characters.
Since an empty string reads the same forward and backward, it is a palindrome.

Constraints:
1 <= s.length <= 2 * 105
s consists only of printable ASCII characters.
=end

# @param {String} s
# @return {Boolean}
def is_palindrome(s)
  filtered_s = s.gsub(/[^a-bA-Z0-9]/i, """").downcase
  left, right = 0, filtered_s.size - 1

  while left < right
    return false if filtered_s[left] != filtered_s[right]
    left += 1
    right -= 1
  end

  true
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_is_palindrome < Test::Unit::TestCase
  def test_
    assert_equal true, is_palindrome(""A man, a plan, a canal: Panama"")
    assert_equal false, is_palindrome(""race a car"")
    assert_equal true, is_palindrome("""")
  end
end
"
0127,word-ladder,"# frozen_string_literal: true

# 127. Word Ladder
# https://leetcode.com/problems/word-ladder
# Hard

=begin
A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:
* Every adjacent pair of words differs by a single letter.
* Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.
* sk == endWord
Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.

Example 1:
Input: beginWord = ""hit"", endWord = ""cog"", wordList = [""hot"",""dot"",""dog"",""lot"",""log"",""cog""]
Output: 5
Explanation: One shortest transformation sequence is ""hit"" -> ""hot"" -> ""dot"" -> ""dog"" -> cog"", which is 5 words long.

Example 2:
Input: beginWord = ""hit"", endWord = ""cog"", wordList = [""hot"",""dot"",""dog"",""lot"",""log""]
Output: 0
Explanation: The endWord ""cog"" is not in wordList, therefore there is no valid transformation sequence.

Constraints:
* 1 <= beginWord.length <= 10
* endWord.length == beginWord.length
* 1 <= wordList.length <= 5000
* wordList[i].length == beginWord.length
* beginWord, endWord, and wordList[i] consist of lowercase English letters.
* beginWord != endWord
* All the words in wordList are unique.
=end

# @param {String} begin_word
# @param {String} end_word
# @param {String[]} word_list
# @return {Integer}
def ladder_length(begin_word, end_word, word_list)
  word_set = Set.new(word_list)
  return 0 unless word_set.include?(end_word)

  queue = [[begin_word, 1]]
  visited = Set.new([begin_word])

  while !queue.empty?
    word, steps = queue.shift

    word.length.times do |i|
      (""a""..""z"").each do |char|
        next_word = word[0...i] + char + word[i + 1..-1]

        if next_word == end_word
          return steps + 1
        end

        if word_set.include?(next_word) && !visited.include?(next_word)
          queue.push([next_word, steps + 1])
          visited.add(next_word)
        end
      end
    end
  end

  0
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_ladder_length < Test::Unit::TestCase
  def test_
    assert_equal 5, ladder_length(""hit"", ""cog"", [""hot"", ""dot"", ""dog"", ""lot"", ""log"", ""cog""])
    assert_equal 0, ladder_length(""hit"", ""cog"", [""hot"", ""dot"", ""dog"", ""lot"", ""log""])
  end
end
"
0128,longest-consecutive-sequence,"# frozen_string_literal: true

# 128. Longest Consecutive Sequence
# https://leetcode.com/problems/longest-consecutive-sequence
# Medium

=begin
Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.

You must write an algorithm that runs in O(n) time.

Example 1:
Input: nums = [100,4,200,1,3,2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.

Example 2:
Input: nums = [0,3,7,2,5,8,4,6,0,1]
Output: 9

Constraints:
0 <= nums.length <= 105
-109 <= nums[i] <= 109
=end

# @param {Integer[]} nums
# @return {Integer}
def longest_consecutive(nums)
  return 0 if nums.empty?
  nums.sort.uniq.each_cons(2).inject([1, 1]) { |(maxl, curl), (v1, v2)|
    (v1 + 1 == v2) ? [[maxl, curl + 1].max, curl + 1] : [maxl, 1]
  }.first
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_longest_consecutive < Test::Unit::TestCase
  def test_
    assert_equal 4, longest_consecutive([100, 4, 200, 1, 3, 2])
    assert_equal 9, longest_consecutive([0, 3, 7, 2, 5, 8, 4, 6, 0, 1])
  end
end
"
0129,sum-root-to-leaf-numbers,"# frozen_string_literal: true

# 129. Sum Root to Leaf Numbers
# https://leetcode.com/problems/sum-root-to-leaf-numbers

=begin

You are given the root of a binary tree containing digits from 0 to 9 only.

Each root-to-leaf path in the tree represents a number.

* For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.
Return the total sum of all root-to-leaf numbers. Test cases are generated so that the answer will fit in a 32-bit integer.

A leaf node is a node with no children.

### Constraints:

* The number of nodes in the tree is in the range [1, 1000].
* 0 <= Node.val <= 9
* The depth of the tree will not exceed 10.

=end

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root
# @return {Integer}
def sum_numbers(root, n = 0)
  n, l, r = n * 10 + root.val, root.left, root.right
  !l && !r ? n :
    (l ? sum_numbers(l, n) : 0) +
    (r ? sum_numbers(r, n) : 0)
end
"
0130,surrounded-regions,"# frozen_string_literal: true

# 130. Surrounded Regions
# https://leetcode.com/problems/surrounded-regions
# Medium

=begin
Given an m x n matrix board containing 'X' and 'O', capture all regions that are 4-directionally surrounded by 'X'.

A region is captured by flipping all 'O's into 'X's in that surrounded region.

Example 1:
Input: board = [[""X"",""X"",""X"",""X""],[""X"",""O"",""O"",""X""],[""X"",""X"",""O"",""X""],[""X"",""O"",""X"",""X""]]
Output: [[""X"",""X"",""X"",""X""],[""X"",""X"",""X"",""X""],[""X"",""X"",""X"",""X""],[""X"",""O"",""X"",""X""]]
Explanation: Notice that an 'O' should not be flipped if:
- It is on the border, or
- It is adjacent to an 'O' that should not be flipped.
The bottom 'O' is on the border, so it is not flipped.
The other three 'O' form a surrounded region, so they are flipped.

Example 2:
Input: board = [[""X""]]
Output: [[""X""]]

Constraints:
m == board.length
n == board[i].length
1 <= m, n <= 200
board[i][j] is 'X' or 'O'.
=end

# @param {Character[][]} board
# @return {Void} Do not return anything, modify board in-place instead.
def solve(board)
  return if board.empty?

  rows = board.length
  cols = board[0].length

  # Iterate through the border cells
  (0...rows).each do |row|
    dfs(board, row, 0)
    dfs(board, row, cols - 1)
  end

  (0...cols).each do |col|
    dfs(board, 0, col)
    dfs(board, rows - 1, col)
  end

  # Iterate through the entire board and flip the cells
  (0...rows).each do |row|
    (0...cols).each do |col|
      if board[row][col] == ""O""
        board[row][col] = ""X""
      elsif board[row][col] == ""T""
        board[row][col] = ""O""
      end
    end
  end

  board
end

def dfs(board, row, col)
  return if row < 0 || row >= board.length || col < 0 || col >= board[0].length || board[row][col] != ""O""

  board[row][col] = ""T""
  dfs(board, row - 1, col)
  dfs(board, row + 1, col)
  dfs(board, row, col - 1)
  dfs(board, row, col + 1)
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_solve < Test::Unit::TestCase
  def test_
    assert_equal [[""X"", ""X"", ""X"", ""X""], [""X"", ""X"", ""X"", ""X""], [""X"", ""X"", ""X"", ""X""], [""X"", ""O"", ""X"", ""X""]], solve([[""X"", ""X"", ""X"", ""X""], [""X"", ""O"", ""O"", ""X""], [""X"", ""X"", ""O"", ""X""], [""X"", ""O"", ""X"", ""X""]])
    assert_equal [[""X""]], solve([[""X""]])
  end
end
"
0133,clone-graph,"# frozen_string_literal: true

# 133. Clone Graph
# https://leetcode.com/problems/clone-graph

=begin

Given a reference of a node in a connected undirected graph.

Return a deep copy (clone) of the graph.

Each node in the graph contains a value (int) and a list (List[Node]) of its neighbors.

class Node {
    public int val;
    public List<Node> neighbors;
}

Test case format:

For simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on. The graph is represented in the test case using an adjacency list.

An adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.

The given node will always be the first node with val = 1. You must return the copy of the given node as a reference to the cloned graph.

### Example 1:
Input: adjList = [[2,4],[1,3],[2,4],[1,3]]
Output: [[2,4],[1,3],[2,4],[1,3]]
Explanation: There are 4 nodes in the graph.
1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).
2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).
3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).
4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).

### Example 2:
Input: adjList = [[]]
Output: [[]]
Explanation: Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.

### Example 3:
Input: adjList = []
Output: []
Explanation: This an empty graph, it does not have any nodes.

### Constraints:
* The number of nodes in the graph is in the range [0, 100].
* 1 <= Node.val <= 100
* Node.val is unique for each node.
* There are no repeated edges and no self-loops in the graph.
* The Graph is connected and all nodes can be visited starting from the given node.

=end

# Definition for a Node.
# class Node
#     attr_accessor :val, :neighbors
#     def initialize(val = 0, neighbors = nil)
#		  @val = val
#		  neighbors = [] if neighbors.nil?
#         @neighbors = neighbors
#     end
# end

# @param {Node} node
# @return {Node}
def cloneGraph(node)
  return nil if node.nil?
  cnode = Node.new(node.val)
  dfs(node, cnode, {})
  cnode
end

def dfs(node, cnode, visited)
  return if node.nil? || visited[node.val]
  visited[node.val] = cnode
  node.neighbors.each { |nei|
    c_nei = visited[nei.val] || Node.new(nei.val)
    cnode.neighbors << c_nei
    dfs(nei, c_nei, visited)
  }
end
"
0134,gas-station,"# frozen_string_literal: true

# 134. Gas Station
# https://leetcode.com/problems/gas-station
# Medium

=begin
There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i].

You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations.

Given two integer arrays gas and cost, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique

Example 1:
Input: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
Output: 3
Explanation:
Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 4. Your tank = 4 - 1 + 5 = 8
Travel to station 0. Your tank = 8 - 2 + 1 = 7
Travel to station 1. Your tank = 7 - 3 + 2 = 6
Travel to station 2. Your tank = 6 - 4 + 3 = 5
Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.
Therefore, return 3 as the starting index.

Example 2:
Input: gas = [2,3,4], cost = [3,4,3]
Output: -1
Explanation:
You can't start at station 0 or 1, as there is not enough gas to travel to the next station.
Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 0. Your tank = 4 - 3 + 2 = 3
Travel to station 1. Your tank = 3 - 3 + 3 = 3
You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.
Therefore, you can't travel around the circuit once no matter where you start.

Constraints:
n == gas.length == cost.length
1 <= n <= 105
0 <= gas[i], cost[i] <= 104
=end

# @param {Integer[]} gas
# @param {Integer[]} cost
# @return {Integer}
def can_complete_circuit(gas, cost)
  if gas.empty? ||
      cost.empty? ||
      gas.sum < cost.sum

    return -1
  end

  balance = 0
  result = 0

  gas.count.times do |i|
    balance += gas[i] - cost[i]
    if balance < 0
      balance = 0
      result = i + 1
    end
  end

  result
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_can_complete_circuit < Test::Unit::TestCase
  def test_
    assert_equal 3, can_complete_circuit([1, 2, 3, 4, 5], [3, 4, 5, 1, 2])
    assert_equal(-1, can_complete_circuit([2, 3, 4], [3, 4, 3]))
  end
end
"
0135,candy,"# frozen_string_literal: true

# 135. Candy
# https://leetcode.com/problems/candy
# Hard

=begin
There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings.

You are giving candies to these children subjected to the following requirements:

Each child must have at least one candy.
Children with a higher rating get more candies than their neighbors.
Return the minimum number of candies you need to have to distribute the candies to the children.

Example 1:
Input: ratings = [1,0,2]
Output: 5
Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.

Example 2:
Input: ratings = [1,2,2]
Output: 4
Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.
The third child gets 1 candy because it satisfies the above two conditions.

Constraints:
n == ratings.length
1 <= n <= 2 * 104
0 <= ratings[i] <= 2 * 104
=end

# @param {Integer[]} ratings
# @return {Integer}
def candy(ratings)
  left2right = Array.new(ratings.size, 1)
  right2left = Array.new(ratings.size, 1)
  (1...ratings.size).each do |i|
    if ratings[i] > ratings[i - 1]
      left2right[i] = left2right[i - 1] + 1
    end
  end
  (0...ratings.size - 1).reverse_each do |i|
    if ratings[i] > ratings[i + 1]
      right2left[i] = right2left[i + 1] + 1
    end
  end
  sum = 0
  (0...ratings.size).each do |i|
    sum += left2right[i] > right2left[i] ? left2right[i] : right2left[i]
  end
  sum
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_candy < Test::Unit::TestCase
  def test_
    assert_equal 5, candy([1, 0, 2])
    assert_equal 4, candy([1, 2, 2])
  end
end
"
0136,single-number,"# frozen_string_literal: true

# 136. Single Number
# https://leetcode.com/problems/single-number
# Easy

=begin
Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.

You must implement a solution with a linear runtime complexity and use only constant extra space.

Example 1:
Input: nums = [2,2,1]
Output: 1

Example 2:
Input: nums = [4,1,2,1,2]
Output: 4

Example 3:
Input: nums = [1]
Output: 1

Constraints:
1 <= nums.length <= 3 * 104
-3 * 104 <= nums[i] <= 3 * 104
Each element in the array appears twice except for one element which appears only once.
=end

# @param {Integer[]} nums
# @return {Integer}
def single_number(nums)
  nums.reduce(&:^)
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_single_number < Test::Unit::TestCase
  def test_
    assert_equal 1, single_number([2, 2, 1])
    assert_equal 4, single_number([4, 1, 2, 1, 2])
    assert_equal 1, single_number([1])
  end
end
"
0137,single-number-ii,"# frozen_string_literal: true

# 137. Single Number II
# https://leetcode.com/problems/single-number-ii
# Medium

=begin
Given an integer array nums where every element appears three times except for one, which appears exactly once. Find the single element and return it.

You must implement a solution with a linear runtime complexity and use only constant extra space.

Example 1:
Input: nums = [2,2,3,2]
Output: 3

Example 2:
Input: nums = [0,1,0,1,0,1,99]
Output: 99

Constraints:
1 <= nums.length <= 3 * 104
-231 <= nums[i] <= 231 - 1
Each element in nums appears exactly three times except for one element which appears once.
=end

# @param {Integer[]} nums
# @return {Integer}
def single_number(nums)
  one = 0
  two = 0

  nums.each do |num|
    one = (one ^ num) & ~two
    two = (two ^ num) & ~one
  end

  one
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_single_number < Test::Unit::TestCase
  def test_
    assert_equal 3, single_number([2, 2, 3, 2])
    assert_equal 99, single_number([0, 1, 0, 1, 0, 1, 99])
  end
end
"
0138,copy-list-with-random-pointer,"# frozen_string_literal: true

# 138. Copy List with Random Pointer
# https://leetcode.com/problems/copy-list-with-random-pointer
# Medium

=begin
A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null.

Construct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list.

For example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y.

Return the head of the copied linked list.

The linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:

* val: an integer representing Node.val
* random_index: the index of the node (range from 0 to n-1) that the random pointer points to, or null if it does not point to any node.
Your code will only be given the head of the original linked list.

Example 1:
Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]

Example 2:
Input: head = [[1,1],[2,1]]
Output: [[1,1],[2,1]]

Example 3:
Input: head = [[3,null],[3,0],[3,null]]
Output: [[3,null],[3,0],[3,null]]

Constraints:
* 0 <= n <= 1000
* -104 <= Node.val <= 104
* Node.random is null or is pointing to some node in the linked list.
=end

# Definition for Node.
# class Node
#     attr_accessor :val, :next, :random
#     def initialize(val = 0)
#         @val = val
#		  @next = nil
#		  @random = nil
#     end
# end

# @param {Node} node
# @return {Node}
def copyRandomList(head)
  return nil if head.nil?

  # Create a hash map to store the mapping between original nodes and copied nodes
  node_map = {}

  # Create a new head for the copied list
  new_head = Node.new(head.val)
  node_map[head] = new_head

  # Initialize pointers for the original list and the copied list
  original_node = head
  copied_node = new_head

  # Iterate through the original list
  while original_node
    # Update the next pointer of the copied node
    if original_node.next
      unless node_map[original_node.next]
        node_map[original_node.next] = Node.new(original_node.next.val)
      end
      copied_node.next = node_map[original_node.next]
    end

    # Update the random pointer of the copied node
    if original_node.random
      unless node_map[original_node.random]
        node_map[original_node.random] = Node.new(original_node.random.val)
      end
      copied_node.random = node_map[original_node.random]
    end

    # Move the pointers to the next nodes
    original_node = original_node.next
    copied_node = copied_node.next
  end

  new_head
end
"
0139,word-break,"# frozen_string_literal: true

# 139. Word Break
# https://leetcode.com/problems/word-break
# Medium

=begin
Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.

Note that the same word in the dictionary may be reused multiple times in the segmentation.

Example 1:
Input: s = ""leetcode"", wordDict = [""leet"",""code""]
Output: true
Explanation: Return true because ""leetcode"" can be segmented as ""leet code"".

Example 2:
Input: s = ""applepenapple"", wordDict = [""apple"",""pen""]
Output: true
Explanation: Return true because ""applepenapple"" can be segmented as ""apple pen apple"".
Note that you are allowed to reuse a dictionary word.

Example 3:
Input: s = ""catsandog"", wordDict = [""cats"",""dog"",""sand"",""and"",""cat""]
Output: false

Constraints:
1 <= s.length <= 300
1 <= wordDict.length <= 1000
1 <= wordDict[i].length <= 20
s and wordDict[i] consist of only lowercase English letters.
All the strings of wordDict are unique.
=end

# @param {String} s
# @param {String[]} word_dict
# @return {Boolean}
def word_break(s, word_dict)
  word_dict_set = Set.new(word_dict)

  queue = [0]
  s_length = s.length
  word_lengths = word_dict.map(&:length)
  visited = [0] * s_length

  until queue.empty?
    start = queue.shift
    word_lengths.each do |word_length|
      if word_dict_set.include?(s[start...start + word_length])
        if start + word_length == s_length
          return true
        end

        if visited[start + word_length] == 0
          queue << start + word_length
          visited[start + word_length] = 1
        end
      end
    end
  end

  false
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_word_break < Test::Unit::TestCase
  def test_
    assert_equal true, word_break(""leetcode"", [""leet"", ""code""])
    assert_equal true, word_break(""applepenapple"", [""apple"", ""pen""])
    assert_equal false, word_break(""catsandog"", [""cats"", ""dog"", ""sand"", ""and"", ""cat""])
  end
end
"
0141,linked-list-cycle,"# frozen_string_literal: true

# 141. Linked List Cycle
# https://leetcode.com/problems/linked-list-cycle
# Easy

=begin
Given head, the head of a linked list, determine if the linked list has a cycle in it.

There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.

Return true if there is a cycle in the linked list. Otherwise, return false.

Example 1:
Input: head = [3,2,0,-4], pos = 1
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).

Example 2:
Input: head = [1,2], pos = 0
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 0th node.

Example 3:
Input: head = [1], pos = -1
Output: false
Explanation: There is no cycle in the linked list.

Constraints:
The number of the nodes in the list is in the range [0, 104].
-105 <= Node.val <= 105
pos is -1 or a valid index in the linked-list.
=end

# Definition for singly-linked list.
# class ListNode
#     attr_accessor :val, :next
#     def initialize(val)
#         @val = val
#         @next = nil
#     end
# end

# @param {ListNode} head
# @return {Boolean}
def hasCycle(head)
  tortoise = head
  hare = head

  while hare != nil && hare.next != nil
    tortoise = tortoise.next
    hare = hare.next.next

    return true if tortoise == hare
  end

  false
end
"
0142,linked-list-cycle-ii,"# frozen_string_literal: true

# 142. Linked List Cycle II
# https://leetcode.com/problems/linked-list-cycle-ii

=begin

Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.
There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter.
Do not modify the linked list.

Constraints:

* The number of the nodes in the list is in the range [0, 104].
* -105 <= Node.val <= 105
* pos is -1 or a valid index in the linked-list.

=end

# Definition for singly-linked list.
# class ListNode
#     attr_accessor :val, :next
#     def initialize(val)
#         @val = val
#         @next = nil
#     end
# end

# @param {ListNode} head
# @return {ListNode}
def detectCycle(head)
  hash = {}
  pos = 0
  tmp = head
  while tmp
    if hash[tmp]
      return tmp
    else
      hash[tmp] = pos
    end

    pos += 1
    tmp = tmp.next
  end
end
"
0146,lru-cache,"# frozen_string_literal: true

# 146. LRU Cache
# https://leetcode.com/problems/lru-cache
# Medium

=begin
Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.

Implement the LRUCache class:

LRUCache(int capacity) Initialize the LRU cache with positive size capacity.
int get(int key) Return the value of the key if the key exists, otherwise return -1.
void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.
The functions get and put must each run in O(1) average time complexity.

Example 1:
Input
[""LRUCache"", ""put"", ""put"", ""get"", ""put"", ""get"", ""put"", ""get"", ""get"", ""get""]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
Output
[null, null, null, 1, null, -1, null, -1, 3, 4]
Explanation
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // cache is {1=1}
lRUCache.put(2, 2); // cache is {1=1, 2=2}
lRUCache.get(1);    // return 1
lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}
lRUCache.get(2);    // returns -1 (not found)
lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}
lRUCache.get(1);    // return -1 (not found)
lRUCache.get(3);    // return 3
lRUCache.get(4);    // return 4

Constraints:
1 <= capacity <= 3000
0 <= key <= 104
0 <= value <= 105
At most 2 * 105 calls will be made to get and put.
=end

class LRUCache
  # Initialize your data structure here
  # @param {Integer} capacity
  def initialize(capacity)
    @capacity = capacity
    @elems = {}
  end

  # @param {Integer} key
  # @return {Integer}
  def get(key)
    val = @elems.delete key
    if val
      @elems[key] = val
    else
      -1
    end
  end

  # @param {Integer} key
  # @param {Integer} value
  # @return {Void}
  def put(key, value)
    @elems.delete key
    @elems[key] = value
    @elems.delete @elems.first.first if @elems.size > @capacity
  end
end

# Your LRUCache object will be instantiated and called as such:
# obj = LRUCache.new(capacity)
# param_1 = obj.get(key)
# obj.put(key, value)
"
0148,sort-list,"# frozen_string_literal: true

# 148. Sort List
# https://leetcode.com/problems/sort-list
# Medium

# Definition for singly-linked list.
# class ListNode
#     attr_accessor :val, :next
#     def initialize(val = 0, _next = nil)
#         @val = val
#         @next = _next
#     end
# end
# @param {ListNode} head
# @return {ListNode}
def sort_list(head)
  return nil if head.nil?
  array = []
  tmp = head
  while tmp
    array.push(tmp)
    tmp = tmp.next
  end
  # As a rule against bugs.
  # Take list node - nil pointers.
  array.each { |x| x.next = nil }
  array.sort! { |a, b| a.val <=> b.val }
  (0...(array.size - 1)).each do |i|
    array[i].next = array[i + 1]
  end
  array[0]
end
"
0149,max-points-on-a-line,"# frozen_string_literal: true

# 149. Max Points on a Line
# https://leetcode.com/problems/max-points-on-a-line
# Hard

=begin
Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.

Example 1:
Input: points = [[1,1],[2,2],[3,3]]
Output: 3

Example 2:
Input: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]
Output: 4

Constraints:
1 <= points.length <= 300
points[i].length == 2
-104 <= xi, yi <= 104
All the points are unique.
=end

# @param {Integer[][]} points
# @return {Integer}
def max_points(points)
  (points[0...-1].each_with_index.collect { |p, idx|
    points[idx + 1..-1].collect { |p1|
      dx = p.first - p1.first
      dx.zero? ? Float::INFINITY : Rational(p.last - p1.last, dx)
    }.tally.values.max
  }.max || 0) + 1
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_max_points < Test::Unit::TestCase
  def test_
    assert_equal 3, max_points([[1, 1], [2, 2], [3, 3]])
    assert_equal 4, max_points([[1, 1], [3, 2], [5, 3], [4, 1], [2, 3], [1, 4]])
  end
end
"
0150,evaluate-reverse-polish-notation,"# frozen_string_literal: true

# 150. Evaluate Reverse Polish Notation
# https://leetcode.com/problems/evaluate-reverse-polish-notation
# Medium

=begin
You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.

Evaluate the expression. Return an integer that represents the value of the expression.

Note that:

The valid operators are '+', '-', '*', and '/'.
Each operand may be an integer or another expression.
The division between two integers always truncates toward zero.
There will not be any division by zero.
The input represents a valid arithmetic expression in a reverse polish notation.
The answer and all the intermediate calculations can be represented in a 32-bit integer.

Example 1:
Input: tokens = [""2"",""1"",""+"",""3"",""*""]
Output: 9
Explanation: ((2 + 1) * 3) = 9

Example 2:
Input: tokens = [""4"",""13"",""5"",""/"",""+""]
Output: 6
Explanation: (4 + (13 / 5)) = 6

Example 3:
Input: tokens = [""10"",""6"",""9"",""3"",""+"",""-11"",""*"",""/"",""*"",""17"",""+"",""5"",""+""]
Output: 22
Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
=end

# @param {String[]} tokens
# @return {Integer}
def eval_rpn(tokens)
  t = tokens.pop
  return t.to_i if !(op = ""+-*/"".index t)
  b, a = eval_rpn(tokens), eval_rpn(tokens)
  [a + b, a - b, a * b, a.fdiv(b)][op].to_i
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_eval_rpn < Test::Unit::TestCase
  def test_
    assert_equal 9, eval_rpn([""2"", ""1"", ""+"", ""3"", ""*""])
    assert_equal 6, eval_rpn([""4"", ""13"", ""5"", ""/"", ""+""])
    assert_equal 22, eval_rpn([""10"", ""6"", ""9"", ""3"", ""+"", ""-11"", ""*"", ""/"", ""*"", ""17"", ""+"", ""5"", ""+""])
  end
end
"
0151,reverse-words-in-a-string,"# frozen_string_literal: true

# 151. Reverse Words in a String
# https://leetcode.com/problems/reverse-words-in-a-string
# Medium

=begin
Given an input string s, reverse the order of the words.

A word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.

Return a string of the words in reverse order concatenated by a single space.

Note that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.

Example 1:
Input: s = ""the sky is blue""
Output: ""blue is sky the""

Example 2:
Input: s = ""  hello world  ""
Output: ""world hello""
Explanation: Your reversed string should not contain leading or trailing spaces.

Example 3:
Input: s = ""a good   example""
Output: ""example good a""
Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.


Constraints:
* 1 <= s.length <= 104
* s contains English letters (upper-case and lower-case), digits, and spaces ' '.
* There is at least one word in s.
=end

# @param {String} s
# @return {String}
def reverse_words(s)
  s.split("" "").reverse.join("" "")
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_length_of_longest_substring < Test::Unit::TestCase
  def test_
    assert_equal ""blue is sky the"", reverse_words(""the sky is blue"")
    assert_equal ""world hello"", reverse_words(""  hello world  "")
    assert_equal ""example good a"", reverse_words(""a good   example"")
  end
end
"
0152,maximum-product-subarray,"# frozen_string_literal: true

# 152. Maximum Product Subarray
# https://leetcode.com/problems/maximum-product-subarray/
# Medium

=begin
Given an integer array nums, find a subarray that has the largest product, and return the product.

The test cases are generated so that the answer will fit in a 32-bit integer.

Example 1:
Input: nums = [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.

Example 2:
Input: nums = [-2,0,-1]
Output: 0
Explanation: The result cannot be 2, because [-2,-1] is not a subarray.

Constraints:
1 <= nums.length <= 2 * 104
-10 <= nums[i] <= 10
The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.
=end

# @param {Integer[]} nums
# @return {Integer}
def max_product(nums)
  min = max = 1
  res = nums[0]
  nums.each do |n|
    min, max = [n, min * n, max * n].minmax
    res = [res, max].max
  end
  res
end
"
0153,find-minimum-in-rotated-sorted-array,"# frozen_string_literal: true

# https://leetcode.com/problems/find-minimum-in-rotated-sorted-array
# 153. Find Minimum in Rotated Sorted Array
# Medium

=begin
Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:

[4,5,6,7,0,1,2] if it was rotated 4 times.
[0,1,2,4,5,6,7] if it was rotated 7 times.
Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].

Given the sorted rotated array nums of unique elements, return the minimum element of this array.

You must write an algorithm that runs in O(log n) time.

Example 1:
Input: nums = [3,4,5,1,2]
Output: 1
Explanation: The original array was [1,2,3,4,5] rotated 3 times.

Example 2:
Input: nums = [4,5,6,7,0,1,2]
Output: 0
Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.

Example 3:
Input: nums = [11,13,15,17]
Output: 11
Explanation: The original array was [11,13,15,17] and it was rotated 4 times.

Constraints:
* n == nums.length
* 1 <= n <= 5000
* -5000 <= nums[i] <= 5000
* All the integers of nums are unique.
* nums is sorted and rotated between 1 and n times.
=end

# @param {Integer[]} nums
# @return {Integer}
def find_min(nums)
  left = 0
  right = nums.length - 1

  while left < right
    mid = left + (right - left) / 2

    if nums[mid] > nums[right]
      left = mid + 1
    else
      right = mid
    end
  end

  nums[left]
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_find_min < Test::Unit::TestCase
  def test_
    assert_equal 1, find_min([3, 4, 5, 1, 2])
    assert_equal 0, find_min([4, 5, 6, 7, 0, 1, 2])
    assert_equal 11, find_min([11, 13, 15, 17])
  end
end
"
0155,min-stack,"# frozen_string_literal: true

# 155. Min Stack
# https://leetcode.com/problems/min-stack/
# Medium

=begin
Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.

Implement the MinStack class:

* MinStack() initializes the stack object.
* void push(int val) pushes the element val onto the stack.
* void pop() removes the element on the top of the stack.
* int top() gets the top element of the stack.
* int getMin() retrieves the minimum element in the stack.
* You must implement a solution with O(1) time complexity for each function.

Example 1:
Input
[""MinStack"",""push"",""push"",""push"",""getMin"",""pop"",""top"",""getMin""]
[[],[-2],[0],[-3],[],[],[],[]]

Output
[null,null,null,null,-3,null,0,-2]

Explanation
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin(); // return -3
minStack.pop();
minStack.top();    // return 0
minStack.getMin(); // return -2

Constraints:
-231 <= val <= 231 - 1
Methods pop, top and getMin operations will always be called on non-empty stacks.
At most 3 * 104 calls will be made to push, pop, top, and getMin.

=end

class MinStack
  def initialize
    @mins, @stack = [], []
  end

  def push(x)
    @stack.push x
    @mins.push x if @mins.empty? || (x <= @mins.last)
  end

  def pop
    @mins.pop if @stack.pop == @mins.last
  end

  def top
    @stack.last
  end

  def get_min
    @mins.last
  end
end
"
0162,find-peak-element,"# frozen_string_literal: true

# 162. Find Peak Element
# https://leetcode.com/problems/find-peak-element
# Medium

=begin
A peak element is an element that is strictly greater than its neighbors.

Given a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.

You may imagine that nums[-1] = nums[n] = -. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.

You must write an algorithm that runs in O(log n) time.

Example 1:
Input: nums = [1,2,3,1]
Output: 2
Explanation: 3 is a peak element and your function should return the index number 2.

Example 2:
Input: nums = [1,2,1,3,5,6,4]
Output: 5
Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.

Constraints:
1 <= nums.length <= 1000
-231 <= nums[i] <= 231 - 1
nums[i] != nums[i + 1] for all valid i.
=end

# @param {Integer[]} nums
# @return {Integer}
def find_peak_element(nums)
  # n = nums.size - 1
  # (0..n).bsearch { |i| i == n || nums[i] > nums[i + 1] }
  (0...(nums << -10**15).length).bsearch { nums[_1] > nums[_1 + 1] }
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_find_peak_element < Test::Unit::TestCase
  def test_
    assert_equal 2, find_peak_element([1, 2, 3, 1])
    assert_equal 5, find_peak_element([1, 2, 1, 3, 5, 6, 4])
  end
end
"
0167,two-sum-ii-input-array-is-sorted,"# frozen_string_literal: true

# 167. Two Sum II - Input Array Is Sorted
# https://leetcode.com/problems/two-sum-ii-input-array-is-sorted
# Medium

=begin
Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 <= numbers.length.

Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.

The tests are generated such that there is exactly one solution. You may not use the same element twice.

Your solution must use only constant extra space.

Example 1:
Input: numbers = [2,7,11,15], target = 9
Output: [1,2]
Explanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2].

Example 2:
Input: numbers = [2,3,4], target = 6
Output: [1,3]
Explanation: The sum of 2 and 4 is 6. Therefore index1 = 1, index2 = 3. We return [1, 3].

Example 3:
Input: numbers = [-1,0], target = -1
Output: [1,2]
Explanation: The sum of -1 and 0 is -1. Therefore index1 = 1, index2 = 2. We return [1, 2].

Constraints:
2 <= numbers.length <= 3 * 104
-1000 <= numbers[i] <= 1000
numbers is sorted in non-decreasing order.
-1000 <= target <= 1000
The tests are generated such that there is exactly one solution.
=end

# @param {Integer[]} numbers
# @param {Integer} target
# @return {Integer[]}
def two_sum(numbers, target)
  hash = {}

  numbers.each_with_index do |num, i|
    return hash[target - num] + 1, i + 1 if hash[target - num]
    hash[num] = i
  end
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_two_sum < Test::Unit::TestCase
  def test_
    assert_equal [1, 2], two_sum([2, 7, 11, 15], 9)
    assert_equal [1, 3], two_sum([2, 3, 4], 6)
    assert_equal [1, 2], two_sum([-1, 0], -1)
  end
end
"
0168,excel-sheet-column-title,"# frozen_string_literal: true

# 168. Excel Sheet Column Title
# Easy
# https://leetcode.com/problems/excel-sheet-column-title

=begin
Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet.

For example:
A -> 1
B -> 2
C -> 3
...
Z -> 26
AA -> 27
AB -> 28
...

Example 1:
Input: columnNumber = 1
Output: ""A""

Example 2:
Input: columnNumber = 28
Output: ""AB""

Example 3:
Input: columnNumber = 701
Output: ""ZY""

Constraints:
* 1 <= columnNumber <= 231 - 1
=end

# @param {Integer} column_number
# @return {String}
def convert_to_title(column_number)
  result = """"

  while column_number > 0
    column_number -= 1
    result = (column_number % 26 + 65).chr + result
    column_number /= 26
  end

  result
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_convert_to_title < Test::Unit::TestCase
  def test_
    assert_equal ""A"", convert_to_title(1)
    assert_equal ""AB"", convert_to_title(28)
    assert_equal ""ZY"", convert_to_title(701)
  end
end
"
0169,majority-element,"# frozen_string_literal: true

# 169. Majority Element
# https://leetcode.com/problems/majority-element
# Easy

=begin
Given an array nums of size n, return the majority element.

The majority element is the element that appears more than n / 2 times. You may assume that the majority element always exists in the array.

Example 1:
Input: nums = [3,2,3]
Output: 3

Example 2:
Input: nums = [2,2,1,1,1,2,2]
Output: 2

Constraints:
n == nums.length
1 <= n <= 5 * 104
-109 <= nums[i] <= 109
=end

# @param {Integer[]} nums
# @return {Integer}
def majority_element(nums)
  candidate = nil
  count = 0

  nums.each do |ele|
    candidate = ele if count == 0

    if candidate == ele
      count += 1
    else
      count -= 1
    end
  end

  count = 0
  nums.each do |ele|
    count += 1 if ele == candidate
  end

  count > nums.count / 2 ? candidate : nil
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_majority_element < Test::Unit::TestCase
  def test_
    assert_equal 3, majority_element([3, 2, 3])
    assert_equal 2, majority_element([2, 2, 1, 1, 1, 2, 2])
  end
end
"
0172,factorial-trailing-zeroes,"# frozen_string_literal: true

# 172. Factorial Trailing Zeroes
# https://leetcode.com/problems/factorial-trailing-zeroes
# Medium

=begin
Given an integer n, return the number of trailing zeroes in n!.

Note that n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1.

Example 1:
Input: n = 3
Output: 0
Explanation: 3! = 6, no trailing zero.

Example 2:
Input: n = 5
Output: 1
Explanation: 5! = 120, one trailing zero.

Example 3:
Input: n = 0
Output: 0

Constraints:
0 <= n <= 104
=end

# @param {Integer} n
# @return {Integer}
def trailing_zeroes(n)
  (n / 5).zero? ? 0 : n / 5 + trailing_zeroes(n / 5)
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_trailing_zeroes < Test::Unit::TestCase
  def test_
    assert_equal 0, trailing_zeroes(3)
    assert_equal 1, trailing_zeroes(5)
    assert_equal 0, trailing_zeroes(0)
  end
end
"
0173,binary-search-tree-iterato,"# frozen_string_literal: true

# 173. Binary Search Tree Iterator
# https://leetcode.com/problems/binary-search-tree-iterator
# Medium

=begin

Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST):

* BSTIterator(TreeNode root) Initializes an object of the BSTIterator class. The root of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.
* boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false.
* int next() Moves the pointer to the right, then returns the number at the pointer.
Notice that by initializing the pointer to a non-existent smallest number, the first call to next() will return the smallest element in the BST.

You may assume that next() calls will always be valid. That is, there will be at least a next number in the in-order traversal when next() is called.

### Example 1:
Input
[""BSTIterator"", ""next"", ""next"", ""hasNext"", ""next"", ""hasNext"", ""next"", ""hasNext"", ""next"", ""hasNext""]
[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]
Output
[null, 3, 7, true, 9, true, 15, true, 20, false]

Explanation
BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);
bSTIterator.next();    // return 3
bSTIterator.next();    // return 7
bSTIterator.hasNext(); // return True
bSTIterator.next();    // return 9
bSTIterator.hasNext(); // return True
bSTIterator.next();    // return 15
bSTIterator.hasNext(); // return True
bSTIterator.next();    // return 20
bSTIterator.hasNext(); // return False

### Constraints:
* The number of nodes in the tree is in the range [1, 105].
* 0 <= Node.val <= 106
* At most 105 calls will be made to hasNext, and next.

=end

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
class BSTIterator
=begin
    :type root: TreeNode
=end
  def initialize(root)
    @stack = [root]
  end

=begin
    :rtype: Integer
=end
  def next
    find_next
  end


=begin
    :rtype: Boolean
=end
  def has_next
    !@stack.empty?
  end

  private
    def find_next
      current = @stack.pop
      return current if current.is_a?(Integer)
      @stack += [current.right, current.val, current.left].compact
      find_next
    end
end

# Your BSTIterator object will be instantiated and called as such:
# obj = BSTIterator.new(root)
# param_1 = obj.next()
# param_2 = obj.has_next()
"
0188,best-time-to-buy-and-sell-stock-iv,"# frozen_string_literal: true

# 188. Best Time to Buy and Sell Stock IV
# https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv
# Hard

=begin
You are given an integer array prices where prices[i] is the price of a given stock on the ith day, and an integer k.

Find the maximum profit you can achieve. You may complete at most k transactions: i.e. you may buy at most k times and sell at most k times.

Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).

Example 1:
Input: k = 2, prices = [2,4,1]
Output: 2
Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.

Example 2:
Input: k = 2, prices = [3,2,6,5,0,3]
Output: 7
Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.

Constraints:
1 <= k <= 100
1 <= prices.length <= 1000
0 <= prices[i] <= 1000
=end

# @param {Integer} k
# @param {Integer[]} prices
# @return {Integer}
def max_profit(k, prices)
  return 0 if prices.count < 2

  n = prices.count
  if k > n / 2
    differences = (1..prices.count - 1).reduce([]) { |ar, i| ar << (prices[i] - prices[i - 1]) }
    return differences.select { |num| num > 0 }.reduce(:+) || 0
  end

  d = Array.new(k + 1) { Array.new(n + 1) { 0 } }
  (1..k).each do |i|
    tmp_max = d[i - 1][0] - prices[0]

    (1..n - 1).each do |j|
      d[i][j] = [ d[i][j - 1], prices[j] + tmp_max ].max
      tmp_max = [ tmp_max, d[i - 1][j] - prices[j] ].max
    end
  end

  d[k][n - 1]
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_max_profit < Test::Unit::TestCase
  def test_
    assert_equal 2, max_profit(2, [2, 4, 1])
    assert_equal 7, max_profit(2, [3, 2, 6, 5, 0, 3])
  end
end
"
0189,rotate-array,"# frozen_string_literal: true

# 189. Rotate Array
# https://leetcode.com/problems/rotate-array
# Medium

=begin
Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.

Example 1:
Input: nums = [1,2,3,4,5,6,7], k = 3
Output: [5,6,7,1,2,3,4]
Explanation:
rotate 1 steps to the right: [7,1,2,3,4,5,6]
rotate 2 steps to the right: [6,7,1,2,3,4,5]
rotate 3 steps to the right: [5,6,7,1,2,3,4]

Example 2:
Input: nums = [-1,-100,3,99], k = 2
Output: [3,99,-1,-100]
Explanation:
rotate 1 steps to the right: [99,-1,-100,3]
rotate 2 steps to the right: [3,99,-1,-100]

Constraints:
1 <= nums.length <= 105
-231 <= nums[i] <= 231 - 1
0 <= k <= 105
=end

# @param {Integer[]} nums
# @param {Integer} k
# @return {Void} Do not return anything, modify nums in-place instead.
def rotate(nums, k)
  k %= nums.size
  nums[0...k], nums[k..-1] = nums[-k..-1], nums[0...nums.size - k]
end
"
0190,reverse-bits,"# frozen_string_literal: true

# 190. Reverse Bits
# https://leetcode.com/problems/reverse-bits
# Easy

=begin
Reverse bits of a given 32 bits unsigned integer.

Note:

Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.
In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 2 above, the input represents the signed integer -3 and the output represents the signed integer -1073741825.

Example 1:
Input: n = 00000010100101000001111010011100
Output:    964176192 (00111001011110000010100101000000)
Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.

Example 2:
Input: n = 11111111111111111111111111111101
Output:   3221225471 (10111111111111111111111111111111)
Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111.

Constraints:
The input must be a binary string of length 32
=end

# @param {Integer} n, a positive integer
# @return {Integer}
def reverse_bits(n)
  result = 0
  32.times do |i|
    result = (result << 1) | (n & 1)
    n >>= 1
  end
  result
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_reverse_bits < Test::Unit::TestCase
  def test_
    assert_equal 964176192, reverse_bits(0b00000010100101000001111010011100)
    assert_equal 3221225471, reverse_bits(0b11111111111111111111111111111101)
  end
end
"
0191,number-of-1-bits,"# frozen_string_literal: true

# 191. Number of 1 Bits
# https://leetcode.com/problems/number-of-1-bits
# Easy

=begin
Write a function that takes the binary representation of an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight).

Note:
Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.
In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 3, the input represents the signed integer. -3.

Example 1:
Input: n = 00000000000000000000000000001011
Output: 3
Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits.

Example 2:
Input: n = 00000000000000000000000010000000
Output: 1
Explanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit.

Example 3:
Input: n = 11111111111111111111111111111101
Output: 31
Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one '1' bits.

Constraints:
The input must be a binary string of length 32.
=end

# @param {Integer} n, a positive integer
# @return {Integer}
def hamming_weight(n)
  count = 0
  while n > 0
    count += n & 1
    n >>= 1
  end
  count
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_hamming_weight < Test::Unit::TestCase
  def test_
    assert_equal 3, hamming_weight(00000000000000000000000000001011)
    assert_equal 1, hamming_weight(00000000000000000000000010000000)
    assert_equal 31, hamming_weight(11111111111111111111111111111101)
  end
end
"
0198,house-robber,"# frozen_string_literal: true

# 198. House Robber
# https://leetcode.com/problems/house-robber/
# Medium

=begin

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.

### Example 1:
Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.

### Example 2:
Input: nums = [2,7,9,3,1]
Output: 12
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
Total amount you can rob = 2 + 9 + 1 = 12.

### Constraints:
* 1 <= nums.length <= 100
* 0 <= nums[i] <= 400

=end

# @param {Integer[]} nums
# @return {Integer}
def rob(nums)
  a = b = 0
  nums.each { |n| a, b = (a > n + b ? a : n + b), a }
  a
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_rob < Test::Unit::TestCase
  def test_
    assert_equal 4, rob([1, 2, 3, 1])
    assert_equal 12, rob([2, 7, 9, 3, 1])
  end
end
"
0199,binary-tree-right-side-view,"# frozen_string_literal: true

# 199. Binary Tree Right Side View
# https://leetcode.com/problems/binary-tree-right-side-view/
# Medium

=begin
Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.

Example 1:
Input: root = [1,2,3,null,5,null,4]
Output: [1,3,4]

Example 2:
Input: root = [1,null,3]
Output: [1,3]

Example 3:
Input: root = []
Output: []

Constraints:
The number of nodes in the tree is in the range [0, 100].
-100 <= Node.val <= 100

=end

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root
# @return {Integer[]}
def right_side_view(root)
  return [] unless root
  res = []
  queue = [root]

  until queue.empty?
    current = nil
    queue.size.times do
      current = queue.shift
      queue.push(current.left) if current.left
      queue.push(current.right) if current.right
    end
    res << current.val
  end
  res
end
"
0200,number-of-islands,"# frozen_string_literal: true

# 200. Number of Islands
# https://leetcode.com/problems/number-of-islands

=begin

Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.

An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

### Example 1:
Input: grid = [
  [""1"",""1"",""1"",""1"",""0""],
  [""1"",""1"",""0"",""1"",""0""],
  [""1"",""1"",""0"",""0"",""0""],
  [""0"",""0"",""0"",""0"",""0""]
]
Output: 1

### Example 2:
Input: grid = [
  [""1"",""1"",""0"",""0"",""0""],
  [""1"",""1"",""0"",""0"",""0""],
  [""0"",""0"",""1"",""0"",""0""],
  [""0"",""0"",""0"",""1"",""1""]
]
Output: 3

### Constraints:
* m == grid.length
* n == grid[i].length
* 1 <= m, n <= 300
* grid[i][j] is '0' or '1'.

=end

# Runtime: 180 ms
# Memory: 219.5 MB
# @param {Character[][]} grid
# @return {Integer}
def num_islands(grid)
  count = 0
  grid.size.times do |i|
    grid.first.size.times do |j|
      count += dfs(grid, i, j) if grid[i][j] == ""1""
    end
  end
  count
end

def dfs(grid, i, j)
  return 0 if i < 0 || j < 0 || i >= grid.size || j >= grid.first.size || grid[i][j] == ""0""
  grid[i][j] = ""0""
  dfs(grid, i - 1, j)
  dfs(grid, i + 1, j)
  dfs(grid, i, j - 1)
  dfs(grid, i, j + 1)
  1
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_num_islands < Test::Unit::TestCase
  def test_
    assert_equal 1, num_islands([[""1"", ""1"", ""1"", ""1"", ""0""], [""1"", ""1"", ""0"", ""1"", ""0""], [""1"", ""1"", ""0"", ""0"", ""0""], [""0"", ""0"", ""0"", ""0"", ""0""]])
    assert_equal 3, num_islands([[""1"", ""1"", ""0"", ""0"", ""0""], [""1"", ""1"", ""0"", ""0"", ""0""], [""0"", ""0"", ""1"", ""0"", ""0""], [""0"", ""0"", ""0"", ""1"", ""1""]  ])
  end
end
"
0201,bitwise-and-of-numbers-range,"# frozen_string_literal: true

# 201. Bitwise AND of Numbers Range
# https://leetcode.com/problems/bitwise-and-of-numbers-range
# Medium

=begin
Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.

Example 1:
Input: left = 5, right = 7
Output: 4

Example 2:
Input: left = 0, right = 0
Output: 0

Example 3:
Input: left = 1, right = 2147483647
Output: 0

Constraints:
0 <= left <= right <= 231 - 1
=end

# @param {Integer} left
# @param {Integer} right
# @return {Integer}
def range_bitwise_and(left, right)
  shift = 0
  while left != right
    left >>= 1
    right >>= 1
    shift += 1
  end
  left << shift
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_range_bitwise_and < Test::Unit::TestCase
  def test_
    assert_equal 4, range_bitwise_and(5, 7)
    assert_equal 0, range_bitwise_and(0, 0)
    assert_equal 0, range_bitwise_and(1, 2147483647)
  end
end
"
0202,happy-number,"# frozen_string_literal: true

# 202. Happy Number
# https://leetcode.com/problems/happy-number

=begin

Write an algorithm to determine if a number n is happy.

A happy number is a number defined by the following process:

Starting with any positive integer, replace the number by the sum of the squares of its digits.
Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.
Those numbers for which this process ends in 1 are happy.
Return true if n is a happy number, and false if not.


### Example 1:
Input: n = 19
Output: true
Explanation:
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1

### Example 2:
Input: n = 2
Output: false

### Constraints:
* 1 <= n <= 231 - 1

=end

# @param {Integer} n
# @return {Boolean}
def is_happy(n)
  touched = []
  res = n

  loop do
    res = res.digits.sum { |el| el * el }

    return false if touched.include?(res)
    return true if res == 1

    touched << res
  end
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_is_happy < Test::Unit::TestCase
  def test_
    assert_equal true, is_happy(19)
    assert_equal false, is_happy(2)
  end
end
"
0205,isomorphic-strings,"# frozen_string_literal: true

# 205. Isomorphic Strings
# https://leetcode.com/problems/isomorphic-strings

=begin

Given two strings s and t, determine if they are isomorphic.

Two strings s and t are isomorphic if the characters in s can be replaced to get t.

All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.

### Example 1:

Input: s = ""egg"", t = ""add""
Output: true

### Example 2:

Input: s = ""foo"", t = ""bar""
Output: false

### Example 3:

Input: s = ""paper"", t = ""title""
Output: true

### Constraints:

* 1 <= s.length <= 5 * 104
* t.length == s.length
* s and t consist of any valid ascii character.

=end

# Runtime 258 ms
# Memory 211.3 MB
# @param {String} s
# @param {String} t
# @return {Boolean}
def is_isomorphic(s, t)
  ms = {}
  mt = {}
  n = s.length
  i = 0

  while i < n && ms[s[i]] == mt[t[i]]
    ms[s[i]] = mt[t[i]] = i + 1
    i += 1
  end

  i == n
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_is_isomorphic < Test::Unit::TestCase
  def test_
    assert_equal true, is_isomorphic(""egg"", ""add"")
    assert_equal false, is_isomorphic(""foo"", ""bar"")
    assert_equal true, is_isomorphic(""paper"", ""title"")
  end
end
"
0206,reverse-linked-list,"# frozen_string_literal: true

# 206. Reverse Linked List
# https://leetcode.com/problems/reverse-linked-list

=begin

Given the head of a singly linked list, reverse the list, and return the reversed list.

### Example 1:
Input: head = [1,2,3,4,5]
Output: [5,4,3,2,1]

### Example 2:
Input: head = [1,2]
Output: [2,1]

### Example 3:
Input: head = []
Output: []

### Constraints:
* The number of nodes in the list is the range [0, 5000].
* -5000 <= Node.val <= 5000

=end

# Definition for singly-linked list.
# class ListNode
#     attr_accessor :val, :next
#     def initialize(val = 0, _next = nil)
#         @val = val
#         @next = _next
#     end
# end
# @param {ListNode} head
# @return {ListNode}
def reverse_list(head, prev = nil)
  while head
    head, head.next, prev = head.next, prev, head
  end
  prev
end
"
0207,course-schedule,"# frozen_string_literal: true

# 207. Course Schedule
# https://leetcode.com/problems/course-schedule
# Medium

=begin
There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.
* For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.
Return true if you can finish all courses. Otherwise, return false.

Example 1:
Input: numCourses = 2, prerequisites = [[1,0]]
Output: true
Explanation: There are a total of 2 courses to take.
To take course 1 you should have finished course 0. So it is possible.

Example 2:
Input: numCourses = 2, prerequisites = [[1,0],[0,1]]
Output: false
Explanation: There are a total of 2 courses to take.
To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.

Constraints:
* 1 <= numCourses <= 2000
* 0 <= prerequisites.length <= 5000
* prerequisites[i].length == 2
* 0 <= ai, bi < numCourses
* All the pairs prerequisites[i] are unique.
=end

# @param {Integer} num_courses
# @param {Integer[][]} prerequisites
# @return {Boolean}
def can_finish(num_courses, prerequisites)
  # Initialize the graph and indegree array
  graph = Array.new(num_courses) { [] }
  indegree = Array.new(num_courses, 0)

  # Build the graph and update the indegree array
  prerequisites.each do |prerequisite|
    course, prerequisite_course = prerequisite
    graph[prerequisite_course] << course
    indegree[course] += 1
  end

  # Initialize the queue with courses having indegree 0
  queue = []
  indegree.each_with_index do |degree, index|
    queue << index if degree == 0
  end

  # Process the courses in the queue
  while !queue.empty?
    current_course = queue.shift
    num_courses -= 1

    # Update the indegree of the neighboring courses
    graph[current_course].each do |neighboring_course|
      indegree[neighboring_course] -= 1

      # If the neighboring course has indegree 0, add it to the queue
      if indegree[neighboring_course] == 0
        queue << neighboring_course
      end
    end
  end

  # If all courses have been processed, return true, otherwise false
  num_courses == 0
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_can_finish < Test::Unit::TestCase
  def test_
    assert_equal true, can_finish(2, [[1, 0]])
    assert_equal false, can_finish(2, [[1, 0], [0, 1]])
  end
end
"
0208,implement-trie-prefix-tree,"# frozen_string_literal: true

# 208. Implement Trie (Prefix Tree)
# https://leetcode.com/problems/implement-trie-prefix-tree
# Medium

=begin

A trie (pronounced as ""try"") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.

Implement the Trie class:

* Trie() Initializes the trie object.
* void insert(String word) Inserts the string word into the trie.
* boolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.
* boolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise.

### Constraints:

* 1 <= word.length, prefix.length <= 2000
* word and prefix consist only of lowercase English letters.
* At most 3 * 104 calls in total will be made to insert, search, and startsWith.

=end

class Trie
  def initialize
    @t = [{}, false]
  end


=begin
  :type word: String
  :rtype: Void
=end
  def insert(word)
    t = @t
    word.bytes.each do
      t = (t.first()[_1] ||= [{}, false])
    end
    t[1] = true
  end


=begin
  :type word: String
  :rtype: Boolean
=end
  def search(word)
    starts_with(word) && @c.last
  end


=begin
  :type prefix: String
  :rtype: Boolean
=end
  def starts_with(prefix)
    (@c = @t; prefix.bytes).all? { @c = @c.first()[_1] }
  end
end

# Your Trie object will be instantiated and called as such:
# obj = Trie.new()
# obj.insert(word)
# param_2 = obj.search(word)
# param_3 = obj.starts_with(prefix)
"
0209,minimum-size-subarray-sum,"# frozen_string_literal: true

# 209. Minimum Size Subarray Sum
# https://leetcode.com/problems/minimum-size-subarray-sum
# Medium

=begin
Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.

Example 1:
Input: target = 7, nums = [2,3,1,2,4,3]
Output: 2
Explanation: The subarray [4,3] has the minimal length under the problem constraint.

Example 2:
Input: target = 4, nums = [1,4,4]
Output: 1

Example 3:
Input: target = 11, nums = [1,1,1,1,1,1,1,1]
Output: 0

Constraints:
1 <= target <= 109
1 <= nums.length <= 105
1 <= nums[i] <= 104
=end

# @param {Integer} target
# @param {Integer[]} nums
# @return {Integer}
def min_sub_array_len(target, nums)
  return 0 if nums.empty?
  min = nil
  i, j = 0, 0
  sum = nums[i]
  while j < nums.size
    if sum < target
      j += 1
      sum += nums[j] if j < nums.size
      next
    end
    if i == j
      return 1
    end
    length = j - i + 1
    min = length if min.nil?
    min = length if min > length
    i += 1
    sum -= nums[i - 1]
  end
  min || 0
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_min_sub_array_len < Test::Unit::TestCase
  def test_
    assert_equal 2, min_sub_array_len(7, [2, 3, 1, 2, 4, 3])
    assert_equal 1, min_sub_array_len(4, [1, 4, 4])
    assert_equal 0, min_sub_array_len(11, [1, 1, 1, 1, 1, 1, 1, 1])
  end
end
"
0210,course-schedule-ii,"# frozen_string_literal: true

# 210. Course Schedule II
# https://leetcode.com/problems/course-schedule-ii/
# Medium

=begin

There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.

* For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.
Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.

Example 1:
Input: numCourses = 2, prerequisites = [[1,0]]
Output: [0,1]
Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].

Example 2:
Input: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
Output: [0,2,1,3]
Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.
So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].

Example 3:
Input: numCourses = 1, prerequisites = []
Output: [0]


Constraints:
1 <= numCourses <= 2000
0 <= prerequisites.length <= numCourses * (numCourses - 1)
prerequisites[i].length == 2
0 <= ai, bi < numCourses
ai != bi
All the pairs [ai, bi] are distinct.

=end

# @param {Integer} num_courses
# @param {Integer[][]} prerequisites
# @return {Integer[]}
def find_order(num_courses, prerequisites)
  edges = Hash.new { |h, v| h[v] = [] }
  deg = [0] * num_courses
  prerequisites.each do |a, b|
    deg[a] += 1
    edges[b] << a
  end
  leaves = []
  deg.each_with_index { |d, v| leaves << v if d == 0 }
  res = leaves.dup
  # Exclude leaves (with corresponding edges) one by one.
  while v = leaves.shift
    num_courses -= 1
    edges[v].each do |u|
      deg[u] -= 1
      if deg[u] == 0
        leaves << u
        res << u
      end
    end
  end
  # no cycles if no more vertices
  num_courses == 0 ? res : []
end
"
0211,design-add-and-search-words-data-structure,"# frozen_string_literal: true

# 211. Design Add and Search Words Data Structure
# https://leetcode.com/problems/design-add-and-search-words-data-structure

=begin

Design a data structure that supports adding new words and finding if a string matches any previously added string.

Implement the WordDictionary class:

* WordDictionary() Initializes the object.
* void addWord(word) Adds word to the data structure, it can be matched later.
* bool search(word) Returns true if there is any string in the data structure that matches word or false otherwise. word may contain dots '.' where dots can be matched with any letter.

Constraints:

* 1 <= word.length <= 25
* word in addWord consists of lowercase English letters.
* word in search consist of '.' or lowercase English letters.
* There will be at most 3 dots in word for search queries.
* At most 104 calls will be made to addWord and search.

=end

class WordDictionary
  def initialize
    @d = {}
  end


=begin
  :type word: String
  :rtype: Void
=end
  def add_word(word)
    t = @d[word.size] ||= {}
    word.each_byte do |i|
      t = t[i] ||= {}
    end
  end


=begin
  :type word: String
  :rtype: Boolean
=end
  def search(word)
    @p, @z = word.bytes, (z = word.size) - 1
    dfs @d[z], 0
  end

  private
    def dfs(t, i)
      return false unless t
      c = @p[i]
      if i == @z
        return c == 46 || !!t[c]
      end
      i += 1
      c == 46 ?
          t.any? { dfs _1.last, i } :
          dfs(t[c], i)
    end
end

# Your WordDictionary object will be instantiated and called as such:
# obj = WordDictionary.new()
# obj.add_word(word)
# param_2 = obj.search(word)
"
0212,word-search-ii,"# frozen_string_literal: true

# 212. Word Search II
# https://leetcode.com/problems/word-search-ii
# Hard

=begin
Given an m x n board of characters and a list of strings words, return all words on the board.

Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.

Example 1:
Input: board = [[""o"",""a"",""a"",""n""],[""e"",""t"",""a"",""e""],[""i"",""h"",""k"",""r""],[""i"",""f"",""l"",""v""]], words = [""oath"",""pea"",""eat"",""rain""]
Output: [""eat"",""oath""]

Example 2:
Input: board = [[""a"",""b""],[""c"",""d""]], words = [""abcb""]
Output: []

Constraints:
* m == board.length
* n == board[i].length
* 1 <= m, n <= 12
* board[i][j] is a lowercase English letter.
* 1 <= words.length <= 3 * 104
* 1 <= words[i].length <= 10
* words[i] consists of lowercase English letters.
* All the strings of words are unique.
=end

# @param {Character[][]} board
# @param {String[]} words
# @return {String[]}
def find_words(board, words)
  res = []
  trie = {}

  words.each do |word|
    node = trie
    word.chars.each do |char|
      node[char] ||= {}
      node = node[char]
    end
    node[:word] = word
  end

  (0...board.size).each do |i|
    (0...board[0].size).each do |j|
      res += search(board, i, j, trie)
    end
  end

  res
end

def search(board, i, j, node)
  res = []

  char = board[i][j]
  char_node = node[char]

  return res if char_node.nil? || char_node.empty?

  if char_node.key?(:word)
    res << char_node[:word]
    char_node.delete(:word)
    if char_node.empty?
      node.delete(char)
      return res
    end
  end

  board[i][j] = :visited
  [[0, 1], [0, -1], [1, 0], [-1, 0]].map { |di, dj| [di + i, dj + j] }.each do |next_i, next_j|
    next if next_i < 0 || next_j < 0 || next_i >= board.size || next_j >= board[0].size

    next_char = board[next_i][next_j]
    next if next_char == :visited

    res += search(board, next_i, next_j, char_node)
    if char_node.empty?
      node.delete(char)
      break
    end
  end

  board[i][j] = char

  res
end


# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_find_words < Test::Unit::TestCase
  def test_
    assert_equal [""eat"", ""oath""].sort, find_words([[""o"", ""a"", ""a"", ""n""], [""e"", ""t"", ""a"", ""e""], [""i"", ""h"", ""k"", ""r""], [""i"", ""f"", ""l"", ""v""]], [""oath"", ""pea"", ""eat"", ""rain""]).sort
    assert_equal [], find_words([[""a"", ""b""], [""c"", ""d""]], [""abcb""])
  end
end
"
0215,kth-largest-element-in-an-array,"# frozen_string_literal: true

# 215. Kth Largest Element in an Array
# https://leetcode.com/problems/kth-largest-element-in-an-array
# Medium

=begin
Given an integer array nums and an integer k, return the kth largest element in the array.

Note that it is the kth largest element in the sorted order, not the kth distinct element.

You must solve it in O(n) time complexity.

Example 1:
Input: nums = [3,2,1,5,6,4], k = 2
Output: 5

Example 2:
Input: nums = [3,2,3,1,2,4,5,5,6], k = 4
Output: 4

Constraints:
1 <= k <= nums.length <= 105
-104 <= nums[i] <= 104
=end

# @param {Integer[]} nums
# @param {Integer} k
# @return {Integer}
def find_kth_largest(nums, k)
  nums.sort[-k]
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_find_kth_largest < Test::Unit::TestCase
  def test_
    assert_equal 5, find_kth_largest([3, 2, 1, 5, 6, 4], 2)
    assert_equal 4, find_kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4)
  end
end

# ********************#
#     Benchmark       #
# ********************#

require ""benchmark""

nums = [3, 2, 3, 1, 2, 4, 5, 5, 6]
k = 4
Benchmark.bm do |x|
  x.report(""find_kth_largest: "") { find_kth_largest(nums, k) }
end
"
0216,combination-sum-iii,"# frozen_string_literal: true

# 216. Combination Sum III
# https://leetcode.com/problems/combination-sum-iii
# Medium

=begin
Find all valid combinations of k numbers that sum up to n such that the following conditions are true:

Only numbers 1 through 9 are used.
Each number is used at most once.
Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.

Example 1:
Input: k = 3, n = 7
Output: [[1,2,4]]
Explanation:
1 + 2 + 4 = 7
There are no other valid combinations.

Example 2:
Input: k = 3, n = 9
Output: [[1,2,6],[1,3,5],[2,3,4]]
Explanation:
1 + 2 + 6 = 9
1 + 3 + 5 = 9
2 + 3 + 4 = 9
There are no other valid combinations.

Example 3:
Input: k = 4, n = 1
Output: []
Explanation: There are no valid combinations.
Using 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 > 1, there are no valid combination.

Constraints:
2 <= k <= 9
1 <= n <= 60
=end

# @param {Integer} k
# @param {Integer} n
# @return {Integer[][]}
def combination_sum3(k, n)
  [*(1..9)].combination(k).filter { _1.sum == n }
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_combination_sum3 < Test::Unit::TestCase
  def test_
    assert_equal [[1, 2, 4]], combination_sum3(3, 7)
    assert_equal [[1, 2, 6], [1, 3, 5], [2, 3, 4]], combination_sum3(3, 9)
    assert_equal [], combination_sum3(4, 1)
  end
end
"
0219,contains-duplicate-ii,"# frozen_string_literal: true

# 219. Contains Duplicate II
# https://leetcode.com/problems/contains-duplicate-ii
# Easy

=begin
Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k.

Example 1:
Input: nums = [1,2,3,1], k = 3
Output: true

Example 2:
Input: nums = [1,0,1,1], k = 1
Output: true

Example 3:
Input: nums = [1,2,3,1,2,3], k = 2
Output: false

Constraints:
1 <= nums.length <= 105
-109 <= nums[i] <= 109
0 <= k <= 105
=end

# @param {Integer[]} nums
# @param {Integer} k
# @return {Boolean}
def contains_nearby_duplicate(nums, k)
  hash = {}
  nums.each_with_index do |value, j|
    i = hash[value]
    if i && (j - i) <= k
      return true
    end
    hash[value] = j
  end
  false
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_contains_nearby_duplicate < Test::Unit::TestCase
  def test_
    assert_equal true, contains_nearby_duplicate([1, 2, 3, 1], 3)
    assert_equal true, contains_nearby_duplicate([1, 0, 1, 1], 1)
    assert_equal false, contains_nearby_duplicate([1, 2, 3, 1, 2, 3], 2)
  end
end
"
0221,maximal-square,"# frozen_string_literal: true

# 221. Maximal Square
# https://leetcode.com/problems/maximal-square
# Medium

=begin
Given an m x n binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.

Example 1:
Input: matrix = [[""1"",""0"",""1"",""0"",""0""],[""1"",""0"",""1"",""1"",""1""],[""1"",""1"",""1"",""1"",""1""],[""1"",""0"",""0"",""1"",""0""]]
Output: 4

Example 2:
Input: matrix = [[""0"",""1""],[""1"",""0""]]
Output: 1

Example 3:
Input: matrix = [[""0""]]
Output: 0

Constraints:
m == matrix.length
n == matrix[i].length
1 <= m, n <= 300
matrix[i][j] is '0' or '1'.
=end

# @param {Character[][]} matrix
# @return {Integer}
def maximal_square(matrix)
  dp = Array.new(matrix.size + 1) { Array.new(matrix[0].size + 1) }
  max = 0
  dp.size.times do |i|
    dp[0].size.times do |j|
      if i == 0 || j == 0 || matrix[i - 1][j - 1] == ""0""
        dp[i][j] = 0
      else
        dp[i][j] = 1 + [dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]].min
      end
      max = [max, dp[i][j]].max
    end
  end
  max**2
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_maximal_square < Test::Unit::TestCase
  def test_
    assert_equal 4, maximal_square([[""1"", ""0"", ""1"", ""0"", ""0""], [""1"", ""0"", ""1"", ""1"", ""1""], [""1"", ""1"", ""1"", ""1"", ""1""], [""1"", ""0"", ""0"", ""1"", ""0""]])
    assert_equal 1, maximal_square([[""0"", ""1""], [""1"", ""0""]])
    assert_equal 0, maximal_square([[""0""]])
  end
end
"
0222,count-complete-tree-nodes,"# frozen_string_literal: true

# 222. Count Complete Tree Nodes
# https://leetcode.com/problems/count-complete-tree-nodes
# Medium

=begin
Given the root of a complete binary tree, return the number of the nodes in the tree.

According to Wikipedia, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.

Design an algorithm that runs in less than O(n) time complexity.

Example 1:
Input: root = [1,2,3,4,5,6]
Output: 6

Example 2:
Input: root = []
Output: 0

Example 3:
Input: root = [1]
Output: 1

Constraints:
* The number of nodes in the tree is in the range [0, 5 * 104].
* 0 <= Node.val <= 5 * 104
* The tree is guaranteed to be complete.
=end

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root
# @return {Integer}
def count_nodes(root)
  return 0 unless root
  h = 0
  node = root
  h += 1 while node = node.left
  return 1 if h.zero?
  res = 2**h - 1
  h -= 1
  while h > 0
    node = root.left
    h.times { node = node.right }
    if node
      res += 2**h
      root = root.right
    else root = root.left
    end
    h -= 1
  end
  return res += 2 if root.right
  res += 1 if root.left
  res
end

require ""test/unit""
class Test_count_nodes < Test::Unit::TestCase
  def test_
    assert_equal 6, count_nodes(tree_parser [1, 2, 3, 4, 5, 6])
    assert_equal 0, count_nodes(tree_parser [])
    assert_equal 1, count_nodes(tree_parser [1])
  end
end

class TreeNode
  attr_accessor :val, :left, :right
  def initialize(val = 0, left = nil, right = nil)
    @val = val
    @left = left
    @right = right
  end
end

def tree_parser(arr)
  return nil unless arr && !arr.empty?
  root = TreeNode.new arr.shift
  queue = [root]
  until arr.empty?
    node = queue.shift
    (val = arr.shift).nil? ? nil : queue << node.left = TreeNode.new(val)
    (val = arr.shift).nil? ? nil : queue << node.right = TreeNode.new(val)
  end
  root
end
"
0224,basic-calculator,"# frozen_string_literal: true

# 224. Basic Calculator
# https://leetcode.com/problems/basic-calculator
# Hard

=begin
Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation.

Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().

Example 1:
Input: s = ""1 + 1""
Output: 2

Example 2:
Input: s = "" 2-1 + 2 ""
Output: 3

Example 3:
Input: s = ""(1+(4+5+2)-3)+(6+8)""
Output: 23

Constraints:
1 <= s.length <= 3 * 105
s consists of digits, '+', '-', '(', ')', and ' '.
s represents a valid expression.
'+' is not used as a unary operation (i.e., ""+1"" and ""+(2 + 3)"" is invalid).
'-' could be used as a unary operation (i.e., ""-1"" and ""-(2 + 3)"" is valid).
There will be no two consecutive operators in the input.
Every number and running calculation will fit in a signed 32-bit integer.
=end

# @param {String} s
# @return {Integer}
def calculate(s)
  last = s.size - 1
  total = 0
  sign = 1
  current = 0
  is_char = ->index { s[index].ord.between?(?0.ord, ?9.ord) }
  stack = []
  (0...s.size).each do |i|
    char = s[i]
    if ?+ == char
      sign = 1
    elsif ?- == char
      sign = -1
    elsif "" "" == char
    elsif ?( == char
      stack.push([total, sign])
      total = 0
      sign = 1
      current = 0
    elsif ?) == char
      prev_total, prev_sign = stack.pop()
      current = 0
      total = prev_total + prev_sign * total
      sign = 0
    elsif is_char[i]
      current = current * 10 + char.to_i
      if last == i || ! is_char[i + 1]
        total += sign * current
        current = 0
        sign = 0
      end
    end
  end
  total
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_calculate < Test::Unit::TestCase
  def test_
    assert_equal 2, calculate(""1 + 1"")
    assert_equal 3, calculate("" 2-1 + 2 "")
    assert_equal 23, calculate(""(1+(4+5+2)-3)+(6+8)"")
  end
end
"
0225,implement-stack-using-queues,"# frozen_string_literal: true

# 225. Implement Stack using Queues
# Easy
# https://leetcode.com/problems/implement-stack-using-queues

=begin
Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).

Implement the MyStack class:
* void push(int x) Pushes element x to the top of the stack.
* int pop() Removes the element on the top of the stack and returns it.
* int top() Returns the element on the top of the stack.
* boolean empty() Returns true if the stack is empty, false otherwise.

Notes:
You must use only standard operations of a queue, which means that only push to back, peek/pop from front, size and is empty operations are valid.
Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue's standard operations.

Example 1:
Input
[""MyStack"", ""push"", ""push"", ""top"", ""pop"", ""empty""]
[[], [1], [2], [], [], []]
Output
[null, null, null, 2, 2, false]
Explanation
MyStack myStack = new MyStack();
myStack.push(1);
myStack.push(2);
myStack.top(); // return 2
myStack.pop(); // return 2
myStack.empty(); // return False

Constraints:
* 1 <= x <= 9
* At most 100 calls will be made to push, pop, top, and empty.
* All the calls to pop and top are valid.
=end

class MyStack
  def initialize
    @stack = []
  end

  def push(x)
    @stack.push(x)
  end

  def pop
    @stack.pop()
  end

  def top
    @stack.last
  end

  def empty
    @stack.empty?
  end
end

# Your MyStack object will be instantiated and called as such:
# obj = MyStack.new()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.top()
# param_4 = obj.empty()
"
0226,invert-binary-tree,"# frozen_string_literal: true

# 226. Invert Binary Tree
# https://leetcode.com/problems/invert-binary-tree

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root
# @return {TreeNode}
def invert_tree(root)
  return if root.nil?
  root.left, root.right = invert_tree(root.right), invert_tree(root.left)
  root
end
"
0227,basic-calculator-ii,"# frozen_string_literal: true

# 227. Basic Calculator II
# https://leetcode.com/pcalculatelems/basic-calculator-ii
# Medium

=begin
Given a string s which represents an expression, evaluate this expression and return its value.

The integer division should truncate toward zero.

You may assume that the given expression is always valid. All intermediate results will be in the range of [-231, 231 - 1].

Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().

Example 1:
Input: s = ""3+2*2""
Output: 7

Example 2:
Input: s = "" 3/2 ""
Output: 1

Example 3:
Input: s = "" 3+5 / 2 ""
Output: 5

Constraints:
1 <= s.length <= 3 * 105
s consists of integers and operators ('+', '-', '*', '/') separated by some number of spaces.
s represents a valid expression.
All the integers in the expression are non-negative integers in the range [0, 231 - 1].
The answer is guaranteed to fit in a 32-bit integer.

=end

# @param {String} s
# @return {Integer}
def calculate(s)
  operators = Set.new(%w[+ - * /])
  digits = Set.new(""0""..""9"")

  num = 0
  presign = ""+""
  stack = []

  (s.delete("" "") + ""+"").each_char do |char|
    if digits.include?(char)
      num = num * 10 + char.to_i
    elsif operators.include?(char)
      stack << case presign
               when ""+"" ; num
               when ""-"" ; -num
               when ""*"" ; stack.pop * num
               when ""/"" ; (stack.pop.to_f / num).to_i
      end

      presign = char
      num = 0
    end
  end

  stack.sum
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_calculate < Test::Unit::TestCase
  def test_
    assert_equal 7, calculate(""3+2*2"")
    assert_equal 1, calculate("" 3/2 "")
    assert_equal 5, calculate("" 3+5 / 2 "")
  end
end
"
0228,summary-ranges,"# frozen_string_literal: true

# 228. Summary Ranges
# https://leetcode.com/problems/summary-ranges
# Easy

=begin
You are given a sorted unique integer array nums.

A range [a,b] is the set of all integers from a to b (inclusive).

Return the smallest sorted list of ranges that cover all the numbers in the array exactly. That is, each element of nums is covered by exactly one of the ranges, and there is no integer x such that x is in one of the ranges but not in nums.

Each range [a,b] in the list should be output as:

""a->b"" if a != b
""a"" if a == b

Example 1:
Input: nums = [0,1,2,4,5,7]
Output: [""0->2"",""4->5"",""7""]
Explanation: The ranges are:
[0,2] --> ""0->2""
[4,5] --> ""4->5""
[7,7] --> ""7""

Example 2:
Input: nums = [0,2,3,4,6,8,9]
Output: [""0"",""2->4"",""6"",""8->9""]
Explanation: The ranges are:
[0,0] --> ""0""
[2,4] --> ""2->4""
[6,6] --> ""6""
[8,9] --> ""8->9""

Constraints:
0 <= nums.length <= 20
-231 <= nums[i] <= 231 - 1
All the values of nums are unique.
nums is sorted in ascending order.
=end

# @param {Integer[]} nums
# @return {String[]}
def summary_ranges(nums)
  nums.each_with_index.group_by { |n, i| n - i }.map { |d, r| [r[0][0], r[-1][0]].uniq.join(""->"") }
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_summary_ranges < Test::Unit::TestCase
  def test_
    assert_equal [""0->2"", ""4->5"", ""7""], summary_ranges([0, 1, 2, 4, 5, 7])
    assert_equal [""0"", ""2->4"", ""6"", ""8->9""], summary_ranges([0, 2, 3, 4, 6, 8, 9])
  end
end
"
0229,majority-element-ii,"# frozen_string_literal: true

# 229. Majority Element II
# Medium
# https://leetcode.com/problems/majority-element-ii

=begin
Given an integer array of size n, find all elements that appear more than  n/3  times.

Example 1:
Input: nums = [3,2,3]
Output: [3]

Example 2:
Input: nums = [1]
Output: [1]

Example 3:
Input: nums = [1,2]
Output: [1,2]

Constraints:
1 <= nums.length <= 5 * 104
-109 <= nums[i] <= 109
=end

# @param {Integer[]} nums
# @return {Integer[]}
def majority_element(nums)
  candidate1, candidate2 = 0, 0
  count1, count2 = 0, 0

  nums.each do |num|
    if candidate1 == num
      count1 += 1
    elsif candidate2 == num
      count2 += 1
    elsif count1 == 0
      candidate1 = num
      count1 += 1
    elsif count2 == 0
      candidate2 = num
      count2 += 1
    else
      count1 -= 1
      count2 -= 1
    end
  end

  result = []
  [candidate1, candidate2].uniq.each do |candidate|
    result << candidate if nums.count(candidate) > (nums.count / 3)
  end

  result
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_majority_element < Test::Unit::TestCase
  def test_
    assert_equal [3], majority_element([3, 2, 3])
    assert_equal [1], majority_element([1])
    assert_equal [1, 2], majority_element([1, 2])
  end
end
"
0230,kth-smallest-element-in-a-bst,"# frozen_string_literal: true

# 230. Kth Smallest Element in a BST
# https://leetcode.com/problems/kth-smallest-element-in-a-bst
# Medium

=begin

Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.

### Example 1:
Input: root = [3,1,4,null,2], k = 1
Output: 1

### Example 2:
Input: root = [5,3,6,2,4,null,null,1], k = 3
Output: 3

### Constraints:
* The number of nodes in the tree is n.
* 1 <= k <= n <= 104
* 0 <= Node.val <= 104

=end

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root
# @param {Integer} k
# @return {Integer}
def kth_smallest(root, k)
  find = -> root { root && (find[root.left] or
                            (k -= 1) == 0 ? root.val :
                            find[root.right]) }
  find[root]
end
"
0232,implement-queue-using-stacks,"# frozen_string_literal: true

# 232. Implement Queue using Stacks
# https://leetcode.com/problems/implement-queue-using-stacks/
# Easy

=begin
Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).

Implement the MyQueue class:

* void push(int x) Pushes element x to the back of the queue.
* int pop() Removes the element from the front of the queue and returns it.
* int peek() Returns the element at the front of the queue.
* boolean empty() Returns true if the queue is empty, false otherwise.

Notes:
* You must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid.
* Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations.


Example 1:
Input
[""MyQueue"", ""push"", ""push"", ""peek"", ""pop"", ""empty""]
[[], [1], [2], [], [], []]
Output
[null, null, null, 1, 1, false]

Explanation
MyQueue myQueue = new MyQueue();
myQueue.push(1); // queue is: [1]
myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); // return 1
myQueue.pop(); // return 1, queue is [2]
myQueue.empty(); // return false


Constraints:
* 1 <= x <= 9
* At most 100 calls will be made to push, pop, peek, and empty.
* All the calls to pop and peek are valid.
=end

class MyQueue
  def initialize
    @in, @out = [], []
  end

  def push(x)
    @in << x
  end

  def pop
    peek
    @out.pop
  end

  def peek
    @out << @in.pop until @in.empty? if @out.empty?
    @out.last
  end

  def empty
    @in.empty? && @out.empty?
  end
end

# Your MyQueue object will be instantiated and called as such:
# obj = MyQueue.new()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.peek()
# param_4 = obj.empty()
"
0234,palindrome-linked-list,"# frozen_string_literal: true

# 234. Palindrome Linked List
# https://leetcode.com/problems/palindrome-linked-list

=begin

Given the head of a singly linked list, return true if it is a

### Example 1:
Input: head = [1,2,2,1]
Output: true

### Example 2:
Input: head = [1,2]
Output: false

### Constraints:
The number of nodes in the list is in the range [1, 105].
0 <= Node.val <= 9

=end

# Definition for singly-linked list.
# class ListNode
#     attr_accessor :val, :next
#     def initialize(val = 0, _next = nil)
#         @val = val
#         @next = _next
#     end
# end
# @param {ListNode} head
# @return {Boolean}
def is_palindrome(head)
  data = []
  current_node = head
  while !current_node.nil?
    data << current_node.val
    current_node = current_node.next
  end
  data == data.reverse
end
"
0235,lowest-common-ancestor-of-a-binary-search-tree,"# frozen_string_literal: true

# 235. Lowest Common Ancestor of a Binary Search Tree
# https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree

=begin

Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.

According to the definition of LCA on Wikipedia: The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).

### Example 1:
Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
Output: 6
Explanation: The LCA of nodes 2 and 8 is 6.

### Example 2:
Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
Output: 2
Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.

### Example 3:
Input: root = [2,1], p = 2, q = 1
Output: 2

### Constraints:
* The number of nodes in the tree is in the range [2, 105].
* -109 <= Node.val <= 109
* All Node.val are unique.
* p != q
* p and q will exist in the BST.

=end

# https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/submissions/924705622
# Runtime: 96 ms
# Memory: 212.4 MB
# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val)
#         @val = val
#         @left, @right = nil, nil
#     end
# end

# @param {TreeNode} root
# @param {TreeNode} p
# @param {TreeNode} q
# @return {TreeNode}
def lowest_common_ancestor(root, p, q)
  loop do
    case true
    when root.val > [p.val, q.val].max; root = root.left
    when root.val < [p.val, q.val].min; root = root.right
    else return root
    end
  end
end
"
0236,lowest-common-ancestor-of-a-binary-tree,"# frozen_string_literal: true

# 236. Lowest Common Ancestor of a Binary Tree
# https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree
# Medium

=begin
Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.

According to the definition of LCA on Wikipedia: The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).

Example 1:
Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
Output: 3
Explanation: The LCA of nodes 5 and 1 is 3.

Example 2:
Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
Output: 5
Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.

Example 3:
Input: root = [1,2], p = 1, q = 2
Output: 1

Constraints:
The number of nodes in the tree is in the range [2, 105].
-109 <= Node.val <= 109
All Node.val are unique.
p != q
p and q will exist in the tree.
=end

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val)
#         @val = val
#         @left, @right = nil, nil
#     end
# end

# @param {TreeNode} root
# @param {TreeNode} p
# @param {TreeNode} q
# @return {TreeNode}
def lowest_common_ancestor(root, p, q)
  return root if [nil, p, q].index root
  left = lowest_common_ancestor(root.left, p, q)
  right = lowest_common_ancestor(root.right, p, q)
  left && right ? root : left || right
end
"
0238,product-of-array-except-self,"# frozen_string_literal: true

# 238. Product of Array Except Self
# https://leetcode.com/problems/product-of-array-except-self
# Medium

=begin
Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].
The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.
You must write an algorithm that runs in O(n) time and without using the division operation.

Example 1:
Input: nums = [1,2,3,4]
Output: [24,12,8,6]

Example 2:
Input: nums = [-1,1,0,-3,3]
Output: [0,0,9,0,0]

Constraints:
* 2 <= nums.length <= 105
* -30 <= nums[i] <= 30
* The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.
=end

# @param {Integer[]} nums
# @return {Integer[]}
def product_except_self(nums)
  n = nums.size
  out = [1] * n
  left = right = 1
  1.upto(n - 1) { |i|
    out[i] *= left *= nums[i - 1]
    out[~i] *= right *= nums[-i]
  }
  out
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_length_of_longest_substring < Test::Unit::TestCase
  def test_
    assert_equal [24, 12, 8, 6], product_except_self([1, 2, 3, 4])
    assert_equal [0, 0, 9, 0, 0], product_except_self([-1, 1, 0, -3, 3])
  end
end
"
0239,sliding-window-maximum,"# frozen_string_literal: true

# 239. Sliding Window Maximum
# Hard
# https://leetcode.com/problems/sliding-window-maximum

=begin
You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.
Return the max sliding window.

Example 1:
Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [3,3,5,5,6,7]
Explanation:
Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7

Example 2:
Input: nums = [1], k = 1
Output: [1]

Constraints:
* 1 <= nums.length <= 105
* -104 <= nums[i] <= 104
* 1 <= k <= nums.length
=end

# @param {Integer[]} nums
# @param {Integer} k
# @return {Integer[]}
def max_sliding_window(nums, k)
  return [] if nums.empty?

  # Deque will store indexes of array elements
  deque = []

  # Start processing the first k elements
  (0...k).each do |i|
    # While the deque isn't empty and the current element is greater than the last element in the deque
    while !deque.empty? && nums[i] >= nums[deque.last]
      deque.pop
    end
    deque.push(i)
  end

  # Save the maximum element from the first k elements
  output = [nums[deque.first]]

  # Process rest of the elements
  (k...nums.size).each do |i|
    # Remove elements from the deque that are not within the sliding window
    while !deque.empty? && deque.first <= i - k
      deque.shift
    end

    # While the deque isn't empty and the current element is greater than the last element in the deque
    while !deque.empty? && nums[i] >= nums[deque.last]
      deque.pop
    end
    deque.push(i)

    # The first element in the deque is always the maximum element in the current sliding window
    output.push(nums[deque.first])
  end

  output
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_length_of_longest_substring < Test::Unit::TestCase
  def test_
    assert_equal [3, 3, 5, 5, 6, 7], max_sliding_window([1, 3, -1, -3, 5, 3, 6, 7], 3)
    assert_equal [1], max_sliding_window([1], 1)
  end
end
"
0242,valid-anagram,"# frozen_string_literal: true

# 242. Valid Anagram
# https://leetcode.com/problems/valid-anagram
# Easy

=begin
Given two strings s and t, return true if t is an anagram of s, and false otherwise.

An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

Example 1:
Input: s = ""anagram"", t = ""nagaram""
Output: true

Example 2:
Input: s = ""rat"", t = ""car""
Output: false

Constraints:
1 <= s.length, t.length <= 5 * 104
s and t consist of lowercase English letters.
=end

# @param {String} s
# @param {String} t
# @return {Boolean}
def is_anagram(s, t)
  counter = s.chars.reduce(Hash.new(0)) { |ha, ch| ha[ch] += 1; ha }

  t.chars.each do |ch|
    counter[ch] -= 1
    return false if counter[ch] < 0
  end

  counter.values.all?(&:zero?)
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_is_anagram < Test::Unit::TestCase
  def test_
    assert_equal true, is_anagram(""anagram"", ""nagaram"")
    assert_equal false, is_anagram(""rat"", ""car"")
  end
end
"
0258,add-digits,"# frozen_string_literal: true

# 258. Add Digits
# https://leetcode.com/problems/add-digits
# Easy

=begin
Given an integer num, repeatedly add all its digits until the result has only one digit, and return it.

Example 1:
Input: num = 38
Output: 2
Explanation: The process is
38 --> 3 + 8 --> 11
11 --> 1 + 1 --> 2
Since 2 has only one digit, return it.

Example 2:
Input: num = 0
Output: 0

Constraints:
0 <= num <= 231 - 1
=end

# @param {Integer} num
# @return {Integer}
def add_digits(num)
  num == 0 ? 0 : (num - 1) % 9 + 1
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_add_digits < Test::Unit::TestCase
  def test_
    assert_equal 2, add_digits(38)
    assert_equal 0, add_digits(0)
  end
end
"
0274,h-index,"# frozen_string_literal: true

# 274. H-Index
# https://leetcode.com/problems/h-index
# Medium

=begin
Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return the researcher's h-index.

According to the definition of h-index on Wikipedia: The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times.

Example 1:
Input: citations = [3,0,6,1,5]
Output: 3
Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively.
Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.

Example 2:
Input: citations = [1,3,1]
Output: 1

Constraints:
n == citations.length
1 <= n <= 5000
0 <= citations[i] <= 1000
=end

# @param {Integer[]} citations
# @return {Integer}
def h_index(citations)
  citations.sort.reverse.each_with_index.count(&:>)
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_h_index < Test::Unit::TestCase
  def test_
    assert_equal 3, h_index([3, 0, 6, 1, 5])
    assert_equal 1, h_index([1, 3, 1])
  end
end
"
0278,first-bad-version,"# frozen_string_literal: true

# 278. First Bad Version
# https://leetcode.com/problems/first-bad-version

=begin

You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.

Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.

You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.

### Example 1:
Input: n = 5, bad = 4
Output: 4
Explanation:
call isBadVersion(3) -> false
call isBadVersion(5) -> true
call isBadVersion(4) -> true
Then 4 is the first bad version.

### Example 2:
Input: n = 1, bad = 1
Output: 1

### Constraints:
* 1 <= bad <= n <= 231 - 1

=end

# The is_bad_version API is already defined for you.
# @param {Integer} version
# @return {boolean} whether the version is bad
# def is_bad_version(version):

# Runtime: 74 ms
# Memory: 211 MB
# @param {Integer} n
# @return {Integer}
def first_bad_version(n)
  (1..n).bsearch { |i| is_bad_version(i) }
end
"
0283,move-zeroes,"# frozen_string_literal: true

# 283. Move Zeroes
# https://leetcode.com/problems/move-zeroes
# Easy

=begin
Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.

Note that you must do this in-place without making a copy of the array.

Example 1:
Input: nums = [0,1,0,3,12]
Output: [1,3,12,0,0]

Example 2:
Input: nums = [0]
Output: [0]

Constraints:
* 1 <= nums.length <= 104
* -231 <= nums[i] <= 231 - 1
=end

# @param {Integer[]} nums
# @return {Void} Do not return anything, modify nums in-place instead.
def move_zeroes(nums)
  k = 0
  nums.length.times do |i|
    next if nums[i].zero?

    nums[k] = nums[i]
    k += 1
  end

  k.upto(nums.length - 1).each { |i| nums[i] = 0 }
end
"
0287,find-the-duplicate-number,"# frozen_string_literal: true

# 287. Find the Duplicate Number
# Medium
# https://leetcode.com/problems/find-the-duplicate-number

=begin
Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.
There is only one repeated number in nums, return this repeated number.
You must solve the problem without modifying the array nums and uses only constant extra space.

Example 1:
Input: nums = [1,3,4,2,2]
Output: 2

Example 2:
Input: nums = [3,1,3,4,2]
Output: 3


Constraints:
* 1 <= n <= 105
* nums.length == n + 1
* 1 <= nums[i] <= n
* All the integers in nums appear only once except for precisely one integer which appears two or more times.
=end

# @param {Integer[]} nums
# @return {Integer}
def find_duplicate(nums)
  left, right = 1, nums.max

  while left < right
    mid = (left + right) / 2

    count = nums.count { |x| x <= mid }

    if count > mid
      right = mid
    else
      left = mid + 1
    end
  end

  left
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_find_duplicate < Test::Unit::TestCase
  def test_
    assert_equal 2, find_duplicate([1, 3, 4, 2, 2])
    assert_equal 3, find_duplicate([3, 1, 3, 4, 2])
  end
end
"
0289,game-of-life,"# frozen_string_literal: true

# 289. Game of Life
# https://leetcode.com/problems/game-of-life
# Medium

=begin
According to Wikipedia's article: ""The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.""

The board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):

Any live cell with fewer than two live neighbors dies as if caused by under-population.
Any live cell with two or three live neighbors lives on to the next generation.
Any live cell with more than three live neighbors dies, as if by over-population.
Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.
The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the m x n grid board, return the next state.

Example 1:
Input: board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]
Output: [[0,0,0],[1,0,1],[0,1,1],[0,1,0]]

Example 2:
Input: board = [[1,1],[1,0]]
Output: [[1,1],[1,1]]

Constraints:
m == board.length
n == board[i].length
1 <= m, n <= 25
board[i][j] is 0 or 1.
=end

# @param {Integer[][]} board
# @return {Void} Do not return anything, modify board in-place instead.
def game_of_life(board)
  m, n = board.count, board[0].count

  m.times do |i|
    n.times do |j|
      [[i + 1, j - 1], [i + 1, j], [i + 1, j + 1], [i, j + 1]].each do |i2, j2|
        if (0...m).cover?(i2) && (0...n).cover?(j2)
          board[i2][j2] += (board[i][j] & 1) << 1
        end
      end
    end
  end

  (m - 1).downto(0) do |i|
    (n - 1).downto(0) do |j|
      [[i, j - 1], [i - 1, j - 1], [i - 1, j], [i - 1, j + 1]].each do |i2, j2|
        if (0...m).cover?(i2) && (0...n).cover?(j2)
          board[i2][j2] += (board[i][j] & 1) << 1
        end
      end

      board[i][j] = (5...8).cover?(board[i][j]) ? 1 : 0
    end
  end
end
"
0290,word-pattern,"# frozen_string_literal: true

# 290. Word Pattern
# https://leetcode.com/problems/word-pattern
# Easy

=begin
Given a pattern and a string s, find if s follows the same pattern.

Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.

Example 1:
Input: pattern = ""abba"", s = ""dog cat cat dog""
Output: true

Example 2:
Input: pattern = ""abba"", s = ""dog cat cat fish""
Output: false

Example 3:
Input: pattern = ""aaaa"", s = ""dog cat cat dog""
Output: false

Constraints:
1 <= pattern.length <= 300
pattern contains only lower-case English letters.
1 <= s.length <= 3000
s contains only lowercase English letters and spaces ' '.
s does not contain any leading or trailing spaces.
All the words in s are separated by a single space.
=end

# @param {String} pattern
# @param {String} s
# @return {Boolean}
def word_pattern(pattern, s)
  p1 = pattern.chars
  p2 = s.split "" ""
  return false if p1.size != p2.size
  hmap = {}

  p1.each_with_index do |c, idx|
    ptr = ""pat_#{c}""
    st = ""word_#{p2[idx]}""
    if hmap[ptr].nil? && hmap[st].nil?
      hmap[ptr] = idx
      hmap[st] = idx
    elsif !hmap[ptr].nil? && !hmap[st].nil? && hmap[ptr] == hmap[st]
      next
    else
      return false
    end
  end
  true
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_word_pattern < Test::Unit::TestCase
  def test_
    assert_equal true, word_pattern(""abba"", ""dog cat cat dog"")
    assert_equal false, word_pattern(""abba"", ""dog cat cat fish"")
    assert_equal false, word_pattern(""aaaa"", ""dog cat cat dog"")
  end
end
"
0295,find-median-from-data-stream,"# frozen_string_literal: true

# https://leetcode.com/problems/find-median-from-data-stream
# 295. Find Median from Data Stream
# Hard

=begin
The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.

For example, for arr = [2,3,4], the median is 3.
For example, for arr = [2,3], the median is (2 + 3) / 2 = 2.5.
Implement the MedianFinder class:

MedianFinder() initializes the MedianFinder object.
void addNum(int num) adds the integer num from the data stream to the data structure.
double findMedian() returns the median of all elements so far. Answers within 10-5 of the actual answer will be accepted.

Example 1:
Input
[""MedianFinder"", ""addNum"", ""addNum"", ""findMedian"", ""addNum"", ""findMedian""]
[[], [1], [2], [], [3], []]
Output
[null, null, null, 1.5, null, 2.0]
Explanation
MedianFinder medianFinder = new MedianFinder();
medianFinder.addNum(1);    // arr = [1]
medianFinder.addNum(2);    // arr = [1, 2]
medianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)
medianFinder.addNum(3);    // arr[1, 2, 3]
medianFinder.findMedian(); // return 2.0

Constraints:
* -105 <= num <= 105
* There will be at least one element in the data structure before calling findMedian.
* At most 5 * 10^4 calls will be made to addNum and findMedian.
=end

class MedianFinder
  def initialize
    @arr = []
  end


=begin
  :type num: Integer
  :rtype: Void
=end
  def add_num(num)
    idx = @arr.bsearch_index { |x| x > num } || @arr.length
    @arr.insert(idx, num)
  end


=begin
  :rtype: Float
=end
  def find_median
    n = @arr.length
    m = n / 2
    n.odd? ? @arr[m] : (@arr[m - 1] + @arr[m]) / 2.0
  end
end

# Your MedianFinder object will be instantiated and called as such:
# obj = MedianFinder.new()
# obj.add_num(num)
# param_2 = obj.find_median()
"
0299,bulls-and-cows,"# frozen_string_literal: true

# 299. Bulls and Cows
# https://leetcode.com/problems/bulls-and-cows

=begin

You are playing the Bulls and Cows game with your friend.

You write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:

The number of ""bulls"", which are digits in the guess that are in the correct position.
The number of ""cows"", which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls.
Given the secret number secret and your friend's guess guess, return the hint for your friend's guess.

The hint should be formatted as ""xAyB"", where x is the number of bulls and y is the number of cows. Note that both secret and guess may contain duplicate digits.

### Example 1:
Input: secret = ""1807"", guess = ""7810""
Output: ""1A3B""
Explanation: Bulls are connected with a '|' and cows are underlined:
""1807""
  |
""7810""

### Example 2:
Input: secret = ""1123"", guess = ""0111""
Output: ""1A1B""
Explanation: Bulls are connected with a '|' and cows are underlined:
""1123""        ""1123""
  |      or     |
""0111""        ""0111""
Note that only one of the two unmatched 1s is counted as a cow since the non-bull digits can only be rearranged to allow one 1 to be a bull.

### Constraints:
1 <= secret.length, guess.length <= 1000
secret.length == guess.length
secret and guess consist of digits only.

=end

# @param {String} secret
# @param {String} guess
# @return {String}
def get_hint(secret, guess)
  bulls = secret.chars.each_with_index.count do |char, index|
    char == guess[index]
  end

  both = secret.chars.tally.each.sum do |char, count|
    [guess.count(char), count].min
  end

  ""#{bulls}A#{both - bulls}B""
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_get_hint < Test::Unit::TestCase
  def test_
    assert_equal ""1A3B"", get_hint(""1807"", ""7810"")
    assert_equal ""1A1B"", get_hint(""1123"", ""0111"")
  end
end
"
0300,longest-increasing-subsequence,"# frozen_string_literal: true

# 300. Longest Increasing Subsequence
# https://leetcode.com/problems/longest-increasing-subsequence
# Medium

=begin
Given an integer array nums, return the length of the longest strictly increasing subsequence.

Example 1:
Input: nums = [10,9,2,5,3,7,101,18]
Output: 4
Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.

Example 2:
Input: nums = [0,1,0,3,2,3]
Output: 4

Example 3:
Input: nums = [7,7,7,7,7,7,7]
Output: 1

Constraints:
1 <= nums.length <= 2500
-104 <= nums[i] <= 104
=end

# @param {Integer[]} nums
# @return {Integer}
def length_of_lis(nums)
  tails = Array.new
  k = 0
  nums.each do |num|
    start, finish = 0, k
    while start != finish
      mid = (start + finish) / 2
      if tails[mid] < num
        start = mid + 1
      else
        finish = mid
      end
    end
    tails[start] = num
    k += 1 if start == k
  end
  k
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_length_of_lis < Test::Unit::TestCase
  def test_
    assert_equal 4, length_of_lis([10, 9, 2, 5, 3, 7, 101, 18])
    assert_equal 4, length_of_lis([0, 1, 0, 3, 2, 3])
    assert_equal 1, length_of_lis([7, 7, 7, 7, 7, 7, 7])
  end
end
"
0316,remove-duplicate-letters,"# frozen_string_literal: true

# 316. Remove Duplicate Letters
# Medium
# https://leetcode.com/problems/remove-duplicate-letters

=begin
Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is
the smallest in lexicographical order among all possible results.

Example 1:
Input: s = ""bcabc""
Output: ""abc""

Example 2:
Input: s = ""cbacdcbc""
Output: ""acdb""

Constraints:
1 <= s.length <= 104
s consists of lowercase English letters.
=end

# @param {String} s
# @return {String}
def remove_duplicate_letters(s)
  count_hash = Hash.new { |h, k| h[k] = 0 }
  stack = []
  selected_set = Set.new

  s.each_char do |char|
    count_hash[char] += 1
  end

  s.each_char do |char|
    count_hash[char] -= 1
    unless selected_set.include?(char)
      while !stack.empty? && count_hash[stack.last] > 0 && stack.last > char
        selected_set.delete(stack.pop)
      end

      stack << char
      selected_set << char
    end
  end

  stack.join
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_length_of_longest_substring < Test::Unit::TestCase
  def test_
    assert_equal ""abc"", remove_duplicate_letters(""bcabc"")
    assert_equal ""acdb"", remove_duplicate_letters(""cbacdcbc"")
  end
end
"
0319,bulb-switcher,"# frozen_string_literal: true

# 319. Bulb Switcher
# https://leetcode.com/problems/bulb-switcher
# Medium

=begin
There are n bulbs that are initially off. You first turn on all the bulbs, then you turn off every second bulb.

On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb.

Return the number of bulbs that are on after n rounds.

Example 1:
Input: n = 3
Output: 1
Explanation: At first, the three bulbs are [off, off, off].
After the first round, the three bulbs are [on, on, on].
After the second round, the three bulbs are [on, off, on].
After the third round, the three bulbs are [on, off, off].
So you should return 1 because there is only one bulb is on.

Example 2:
Input: n = 0
Output: 0

Example 3:
Input: n = 1
Output: 1

Constraints:
0 <= n <= 109
=end

# @param {Integer} n
# @return {Integer}
def bulb_switch(n)
  Integer.sqrt(n)
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_two_sum < Test::Unit::TestCase
  def test_
    assert_equal 1, bulb_switch(3)
    assert_equal 0, bulb_switch(0)
    assert_equal 1, bulb_switch(1)
  end
end
"
0322,coin-change,"# frozen_string_literal: true

# 322. Coin Change
# https://leetcode.com/problems/coin-change/
# Medium

=begin

You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.

Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.

You may assume that you have an infinite number of each kind of coin.

Example 1:
Input: coins = [1,2,5], amount = 11
Output: 3
Explanation: 11 = 5 + 5 + 1

Example 2:
Input: coins = [2], amount = 3
Output: -1

Example 3:
Input: coins = [1], amount = 0
Output: 0

Constraints:
1 <= coins.length <= 12
1 <= coins[i] <= 231 - 1
0 <= amount <= 104

=end

# @param {Integer[]} coins
# @param {Integer} amount
# @return {Integer}
INF = Float::INFINITY

def coin_change(coins, amount)
  dp = [INF] * (amount + 1)
  dp[0] = 0

  (1..amount).each do |i|
    coins.each do |j|
      if i - j >= 0 && dp[i - j] < INF
        dp[i] = [dp[i], 1 + dp[i - j]].min
      end
    end
  end

  dp[-1] < INF ? dp[-1] : -1
end
"
0328,odd-even-linked-list,"# frozen_string_literal: true

# 328. Odd Even Linked List
# https://leetcode.com/problems/odd-even-linked-list
# Medium

=begin
Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list.

The first node is considered odd, and the second node is even, and so on.

Note that the relative order inside both the even and odd groups should remain as it was in the input.

You must solve the problem in O(1) extra space complexity and O(n) time complexity.

Example 1:
Input: head = [1,2,3,4,5]
Output: [1,3,5,2,4]

Example 2:
Input: head = [2,1,3,5,6,4,7]
Output: [2,3,6,7,1,5,4]

Constraints:
* The number of nodes in the linked list is in the range [0, 104].
* -106 <= Node.val <= 106

=end

# Definition for singly-linked list.
# class ListNode
#     attr_accessor :val, :next
#     def initialize(val = 0, _next = nil)
#         @val = val
#         @next = _next
#     end
# end
# @param {ListNode} head
# @return {ListNode}
def odd_even_list(head)
  return nil if head.nil?

  odd_head = head
  odd = head
  even = head.next
  even_head = head.next

  while even && even.next
    odd.next = odd.next.next
    odd = odd.next
    even.next = even.next.next
    even = even.next
  end

  odd.next = even_head
  odd_head
end
"
0332,reconstruct-itinerary,"# frozen_string_literal: true

# 332. Reconstruct Itinerary
# Hard
# https://leetcode.com/problems/reconstruct-itinerary

=begin
You are given a list of airline tickets where tickets[i] = [fromi, toi] represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.
All of the tickets belong to a man who departs from ""JFK"", thus, the itinerary must begin with ""JFK"". If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.
For example, the itinerary [""JFK"", ""LGA""] has a smaller lexical order than [""JFK"", ""LGB""].
You may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.

Example 1:
Input: tickets = [[""MUC"",""LHR""],[""JFK"",""MUC""],[""SFO"",""SJC""],[""LHR"",""SFO""]]
Output: [""JFK"",""MUC"",""LHR"",""SFO"",""SJC""]

Example 2:
Input: tickets = [[""JFK"",""SFO""],[""JFK"",""ATL""],[""SFO"",""ATL""],[""ATL"",""JFK""],[""ATL"",""SFO""]]
Output: [""JFK"",""ATL"",""JFK"",""SFO"",""ATL"",""SFO""]
Explanation: Another possible reconstruction is [""JFK"",""SFO"",""ATL"",""JFK"",""ATL"",""SFO""] but it is larger in lexical order.

Constraints:
* 1 <= tickets.length <= 300
* tickets[i].length == 2
* fromi.length == 3
* toi.length == 3
* fromi and toi consist of uppercase English letters.
* fromi != toi
=end

# @param {String[][]} tickets
# @return {String[]}
def find_itinerary(tickets)
  graph = Hash.new { |hash, key| hash[key] = [] }

  # Build the graph.
  tickets.each do |from, to|
    graph[from] << to
  end

  # Sort each adjacency list in reverse lexical order.
  graph.each_value { |neighbors| neighbors.sort!.reverse! }

  # DFS.
  itinerary = []
  stack = [""JFK""]

  while !stack.empty?
    airport = stack.last
    if graph[airport].empty?
      # If no outgoing edge, add to itinerary.
      itinerary << stack.pop
    else
      # Otherwise, visit the next unvisited neighbor.
      stack << graph[airport].pop
    end
  end

  # Reverse the itinerary to get the final path.
  itinerary.reverse
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_find_itinerary < Test::Unit::TestCase
  def test_
    assert_equal [""JFK"", ""MUC"", ""LHR"", ""SFO"", ""SJC""], find_itinerary([[""MUC"", ""LHR""], [""JFK"", ""MUC""], [""SFO"", ""SJC""], [""LHR"", ""SFO""]])
    assert_equal [""JFK"", ""ATL"", ""JFK"", ""SFO"", ""ATL"", ""SFO""], find_itinerary([[""JFK"", ""SFO""], [""JFK"", ""ATL""], [""SFO"", ""ATL""], [""ATL"", ""JFK""], [""ATL"", ""SFO""]])
  end
end
"
0334,increasing-triplet-subsequence,"# frozen_string_literal: true

# 334. Increasing Triplet Subsequence
# https://leetcode.com/problems/increasing-triplet-subsequence
# Medium

=begin
Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. If no such indices exists, return false.

Example 1:
Input: nums = [1,2,3,4,5]
Output: true
Explanation: Any triplet where i < j < k is valid.

Example 2:
Input: nums = [5,4,3,2,1]
Output: false
Explanation: No triplet exists.

Example 3:
Input: nums = [2,1,5,0,4,6]
Output: true
Explanation: The triplet (3, 4, 5) is valid because nums[3] == 0 < nums[4] == 4 < nums[5] == 6.

Constraints:
* 1 <= nums.length <= 5 * 105
* -231 <= nums[i] <= 231 - 1
=end

# @param {Integer[]} nums
# @return {Boolean}
def increasing_triplet(nums)
  min = Float::INFINITY
  mid = Float::INFINITY
  nums.each do |x|
    next min = x if x <= min
    next mid = x if x <= mid
    return true
  end
  false
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_increasing_triplet < Test::Unit::TestCase
  def test_
    assert_equal true, increasing_triplet([1, 2, 3, 4, 5])
    assert_equal false, increasing_triplet([5, 4, 3, 2, 1])
    assert_equal true, increasing_triplet([2, 1, 5, 0, 4, 6])
  end
end
"
0338,counting-bits,"# frozen_string_literal: true

# 338. Counting Bits
# https://leetcode.com/problems/counting-bits
# Easy

=begin
Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i.

Example 1:
Input: n = 2
Output: [0,1,1]
Explanation:
0 --> 0
1 --> 1
2 --> 10

Example 2:
Input: n = 5
Output: [0,1,1,2,1,2]
Explanation:
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101

Constraints:
0 <= n <= 105
=end

# @param {Integer} n
# @return {Integer[]}
def count_bits(n)
  result = [0]
  (0..n).each { |i|
    result[i] = result[i / 2] + (i % 2)
  }
  result
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_count_bits < Test::Unit::TestCase
  def test_
    assert_equal [0, 1, 1], count_bits(2)
    assert_equal [0, 1, 1, 2, 1, 2], count_bits(5)
  end
end
"
0341,flatten-nested-list-iterator,"# frozen_string_literal: true

# 341. Flatten Nested List Iterator
# Medium
# https://leetcode.com/problems/flatten-nested-list-iterator

=begin
You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it.

Implement the NestedIterator class:
* NestedIterator(List<NestedInteger> nestedList) Initializes the iterator with the nested list nestedList.
* int next() Returns the next integer in the nested list.
* boolean hasNext() Returns true if there are still some integers in the nested list and false otherwise.
Your code will be tested with the following pseudocode:
```
initialize iterator with nestedList
res = []
while iterator.hasNext()
    append iterator.next() to the end of res
return res
```
If res matches the expected flattened list, then your code will be judged as correct.

Example 1:
Input: nestedList = [[1,1],2,[1,1]]
Output: [1,1,2,1,1]
Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].

Example 2:
Input: nestedList = [1,[4,[6]]]
Output: [1,4,6]
Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].

Constraints:
1 <= nestedList.length <= 500
The values of the integers in the nested list is in the range [-106, 106].
=end

# This is the interface that allows for creating nested lists.
# You should not implement it, or speculate about its implementation
#
# class NestedInteger
#    def is_integer()
#        """"""
#        Return true if this NestedInteger holds a single integer, rather than a nested list.
#        @return {Boolean}
#        """"""
#
#    def get_integer()
#        """"""
#        Return the single integer that this NestedInteger holds, if it holds a single integer
#        Return nil if this NestedInteger holds a nested list
#        @return {Integer}
#        """"""
#
#    def get_list()
#        """"""
#        Return the nested list that this NestedInteger holds, if it holds a nested list
#        Return nil if this NestedInteger holds a single integer
#        @return {NestedInteger[]}
#        """"""

class NestedIterator
  # @param {NestedInteger[]} nested_list
  def initialize(nested_list)
    # p nested_list.class
    @a = []
    nested_list.each do |x|
      fill(x)
    end
    # p @a
    @i = -1
  end
  def fill(x)
    # p x.class
    if x.is_integer()
      # p ""this is integer.""
      # p [x.get_integer().class,x.get_integer()]
      @a.push(x.get_integer())
    else
      # p ""this is a list.""
      x.get_list().each do |el|
        fill(el)
      end
    end
  end

  # @return {Boolean}
  def has_next
    (@i + 1).between?(0, @a.size - 1)
  end

  # @return {Integer}
  def next
    @i += 1
    @a[@i]
  end
end

# Your NestedIterator will be called like this:
# i, v = NestedIterator.new(nested_list), []
# while i.has_next()
#    v << i.next
# end
"
0342,power-of-four,"# frozen_string_literal: true

# 342. Power of Four
# Easy
# https://leetcode.com/problems/power-of-four

=begin
Given an integer n, return true if it is a power of four. Otherwise, return false.
An integer n is a power of four, if there exists an integer x such that n == 4^x.

Example 1:
Input: n = 16
Output: true

Example 2:
Input: n = 5
Output: false

Example 3:
Input: n = 1
Output: true

Constraints:
-231 <= n <= 231 - 1
=end

# @param {Integer} n
# @return {Boolean}
def is_power_of_four(n)
  return true if n == 1
  four = 1
  while four < n
    four *= 4
  end
  four == n ? true : false
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_is_power_of_four < Test::Unit::TestCase
  def test_
    assert_equal true, is_power_of_four(16)
    assert_equal false, is_power_of_four(5)
    assert_equal true, is_power_of_four(1)
  end
end
"
0343,integer-break,"# frozen_string_literal: true

# 343. Integer Break
# Medium
# https://leetcode.com/problems/integer-break

=begin
Given an integer n, break it into the sum of k positive integers, where k >= 2, and maximize the product of those integers.
Return the maximum product you can get.

Example 1:
Input: n = 2
Output: 1
Explanation: 2 = 1 + 1, 1  1 = 1.

Example 2:
Input: n = 10
Output: 36
Explanation: 10 = 3 + 3 + 4, 3  3  4 = 36.

Constraints:
2 <= n <= 58
=end

# @param {Integer} n
# @return {Integer}
def integer_break(n)
  n < 4 ? n - 1 : 3**((n - 2) / 3) * ((n - 2) % 3 + 2)
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_integer_break < Test::Unit::TestCase
  def test_
    assert_equal 1, integer_break(2)
    assert_equal 36, integer_break(10)
  end
end
"
0344,reverse-string,"# frozen_string_literal: true

# 344. Reverse String
# https://leetcode.com/problems/reverse-string

# @param {Character[]} s
# @return {Void} Do not return anything, modify s in-place instead.
def reverse_string(s)
  s.reverse!
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_reverse_string < Test::Unit::TestCase
  def test_
    assert_equal %w[o l l e h], reverse_string(%w[h e l l o])
    assert_equal %w[h a n n a H], reverse_string(%w[H a n n a h])
  end
end
"
0345,reverse-vowels-of-a-string,"# frozen_string_literal: true

# 345. Reverse Vowels of a String
# https://leetcode.com/problems/reverse-vowels-of-a-string
# Easy

=begin
Given a string s, reverse only all the vowels in the string and return it.

The vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both lower and upper cases, more than once.

Example 1:
Input: s = ""hello""
Output: ""holle""

Example 2:
Input: s = ""leetcode""
Output: ""leotcede""

Constraints:
* 1 <= s.length <= 3 * 105
* s consist of printable ASCII characters.
=end

# @param {String} s
# @return {String}
def reverse_vowels(s)
  vowels = s.scan(/[aeiou]/i)
  s.gsub(/[aeiou]/i) { vowels.pop }
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_reverse_vowels < Test::Unit::TestCase
  def test_
    assert_equal ""holle"", reverse_vowels(""hello"")
    assert_equal ""leotcede"", reverse_vowels(""leetcode"")
  end
end
"
0347,top-k-frequent-elements,"# frozen_string_literal: true

# 347. Top K Frequent Elements
# https://leetcode.com/problems/top-k-frequent-elements
# Medium

=begin
Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.

Example 1:
Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]

Example 2:
Input: nums = [1], k = 1
Output: [1]

Constraints:
1 <= nums.length <= 105
-104 <= nums[i] <= 104
k is in the range [1, the number of unique elements in the array].
It is guaranteed that the answer is unique.
=end

# @param {Integer[]} nums
# @param {Integer} k
# @return {Integer[]}
def top_k_frequent(nums, k)
  nums.tally.sort_by { |_, v| -v }.first(k).to_h.keys
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_top_k_frequent < Test::Unit::TestCase
  def test_
    assert_equal [1, 2], top_k_frequent([1, 1, 1, 2, 2, 3], 2)
    assert_equal [1], top_k_frequent([1], 1)
  end
end
"
0373,find-k-pairs-with-smallest-sums,"# frozen_string_literal: true

# https://leetcode.com/problems/find-k-pairs-with-smallest-sums
# 373. Find K Pairs with Smallest Sums
# Medium

# TODO: Resolve TLE

=begin
You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k.

Define a pair (u, v) which consists of one element from the first array and one element from the second array.

Return the k pairs (u1, v1), (u2, v2), ..., (uk, vk) with the smallest sums.

Example 1:
Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3
Output: [[1,2],[1,4],[1,6]]
Explanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]

Example 2:
Input: nums1 = [1,1,2], nums2 = [1,2,3], k = 2
Output: [[1,1],[1,1]]
Explanation: The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]

Example 3:
Input: nums1 = [1,2], nums2 = [3], k = 3
Output: [[1,3],[2,3]]
Explanation: All possible pairs are returned from the sequence: [1,3],[2,3]

Constraints:
* 1 <= nums1.length, nums2.length <= 105
* -109 <= nums1[i], nums2[i] <= 109
* nums1 and nums2 both are sorted in ascending order.
* 1 <= k <= 104
=end

# @param {Integer[]} nums1
# @param {Integer[]} nums2
# @param {Integer} k
# @return {Integer[][]}
def k_smallest_pairs(a, b, k)
  queue = a.map.with_index { [_1 + b[0], _2, 0] }
  result = []
  k.times do
    break unless (_, a_i, b_i = queue.shift)
    result << [a[a_i], b[b_i]]
    b_i += 1
    next unless b_i < b.size
    sum = a[a_i] + b[b_i]
    i = queue.bsearch_index { |q_sum, _, _| sum < q_sum } || queue.size
    queue.insert(i, [sum, a_i, b_i])
  end
  result
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_k_smallest_pairs < Test::Unit::TestCase
  def test_
    assert_equal [[1, 2], [1, 4], [1, 6]], k_smallest_pairs([1, 7, 11], [2, 4, 6], 3)
    assert_equal [[1, 1], [1, 1]], k_smallest_pairs([1, 1, 2], [1, 2, 3], 2)
    assert_equal [[1, 3], [2, 3]], k_smallest_pairs([1, 2], [3], 3)
  end
end
"
0374,guess-number-higher-or-lower,"# frozen_string_literal: true

# 374. Guess Number Higher or Lower
# https://leetcode.com/problems/guess-number-higher-or-lower
# Easy

=begin
We are playing the Guess Game. The game is as follows:

I pick a number from 1 to n. You have to guess which number I picked.

Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.

You call a pre-defined API int guess(int num), which returns three possible results:

-1: Your guess is higher than the number I picked (i.e. num > pick).
1: Your guess is lower than the number I picked (i.e. num < pick).
0: your guess is equal to the number I picked (i.e. num == pick).
Return the number that I picked.

Example 1:
Input: n = 10, pick = 6
Output: 6

Example 2:
Input: n = 1, pick = 1
Output: 1

Example 3:
Input: n = 2, pick = 1
Output: 1

Constraints:
1 <= n <= 231 - 1
1 <= pick <= n
=end

# The guess API is already defined for you.
# @param num, your guess
# @return -1 if num is higher than the picked number
#          1 if num is lower than the picked number
#          otherwise return 0
# def guess(num)

def guessNumber(n)
  l, h = 1, n
  while l <= h
    m = l + (h - l) / 2
    ans = guess(m)
    if 0 == ans
      return m
    elsif -1 == ans
      h = m - 1
    else
      l = m + 1
    end
  end
end
"
0377,combination-sum-iv,"# frozen_string_literal: true

# 377. Combination Sum IV
# Medium
# https://leetcode.com/problems/combination-sum-iv

=begin
Given an array of distinct integers nums and a target integer target, return the number of possible combinations that add up to target.
The test cases are generated so that the answer can fit in a 32-bit integer.

Example 1:
Input: nums = [1,2,3], target = 4
Output: 7
Explanation:
The possible combination ways are:
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
Note that different sequences are counted as different combinations.

Example 2:
Input: nums = [9], target = 3
Output: 0

Constraints:
* 1 <= nums.length <= 200
* 1 <= nums[i] <= 1000
* All the elements of nums are unique.
* 1 <= target <= 1000
=end

# @param {Integer[]} nums
# @param {Integer} target
# @return {Integer}
def combination_sum4(nums, target)
  a = [1] + [0] * target

  (1..target).each do |i|
    nums.each do |num|
      a[i] += a[i - num] if num <= i
    end
  end

  a.last
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_combination_sum4 < Test::Unit::TestCase
  def test_
    assert_equal 7, combination_sum4([1, 2, 3], 4)
    assert_equal 0, combination_sum4([9], 3)
  end
end
"
0380,insert-delete-getrandom-o1,"# frozen_string_literal: true

# 380. Insert Delete GetRandom O(1)
# https://leetcode.com/problems/insert-delete-getrandom-o1
# Medium

=begin
Implement the RandomizedSet class:

RandomizedSet() Initializes the RandomizedSet object.
bool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise.
bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise.
int getRandom() Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned.
You must implement the functions of the class such that each function works in average O(1) time complexity.

Example 1:
Input
[""RandomizedSet"", ""insert"", ""remove"", ""insert"", ""getRandom"", ""remove"", ""insert"", ""getRandom""]
[[], [1], [2], [2], [], [1], [2], []]
Output
[null, true, false, true, 2, true, false, 2]

Explanation
RandomizedSet randomizedSet = new RandomizedSet();
randomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.
randomizedSet.remove(2); // Returns false as 2 does not exist in the set.
randomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].
randomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.
randomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].
randomizedSet.insert(2); // 2 was already in the set, so return false.
randomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.

Constraints:
-231 <= val <= 231 - 1
At most 2 * 105 calls will be made to insert, remove, and getRandom.
There will be at least one element in the data structure when getRandom is called.
=end

class RandomizedSet
  def initialize
    @size = 0
    @hash = Hash.new
    @rev = Array.new
  end

  def insert(val)
    return false if @hash[val]
    @hash[val] = @size
    @rev[@size] = val
    @size += 1
    true
  end

  def remove(val)
    del = @hash.delete val
    return false unless del
    @size -= 1
    unless del == @size
      last = @rev[@size]
      @rev[del] = last
      @hash[last] = del
    end
    true
  end

  def get_random
    @rev[ rand @size ]
  end
end

# Your RandomizedSet object will be instantiated and called as such:
# obj = RandomizedSet.new()
# param_1 = obj.insert(val)
# param_2 = obj.remove(val)
# param_3 = obj.get_random()
"
0382,linked-list-random-node,"# frozen_string_literal: true

# 382. Linked List Random Node
# https://leetcode.com/problems/linked-list-random-node

# Definition for singly-linked list.
# class ListNode
#     attr_accessor :val, :next
#     def initialize(val = 0, _next = nil)
#         @val = val
#         @next = _next
#     end
# end
class Solution
=begin
    :type head: ListNode
=end
  def initialize(head)
    @array = []
    tmp = head
    while tmp
      @array.push(tmp)
      tmp = tmp.next
    end
  end


=begin
    :rtype: Integer
=end
  def get_random
    @array[rand(@array.size)].val
  end
end

# Your Solution object will be instantiated and called as such:
# obj = Solution.new(head)
# param_1 = obj.get_random()
"
0383,ransom-note,"# frozen_string_literal: true

# 383. Ransom Note
# https://leetcode.com/problems/ransom-note
# Easy

=begin
Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the letters from magazine and false otherwise.

Each letter in magazine can only be used once in ransomNote.

Example 1:
Input: ransomNote = ""a"", magazine = ""b""
Output: false

Example 2:
Input: ransomNote = ""aa"", magazine = ""ab""
Output: false

Example 3:
Input: ransomNote = ""aa"", magazine = ""aab""
Output: true

Constraints:
1 <= ransomNote.length, magazine.length <= 105
ransomNote and magazine consist of lowercase English letters.
=end

# @param {String} ransom_note
# @param {String} magazine
# @return {Boolean}
def can_construct(ransom_note, magazine)
  ransom_note.chars.uniq.all? { |character| ransom_note.count(character) <= magazine.count(character) }
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_can_construct < Test::Unit::TestCase
  def test_
    assert_equal false, can_construct(""a"", ""b"")
    assert_equal false, can_construct(""aa"", ""ab"")
    assert_equal true, can_construct(""aa"", ""aab"")
  end
end
"
0387,first-unique-character-in-a-string,"# frozen_string_literal: true

# 387. First Unique Character in a String
# https://leetcode.com/problems/first-unique-character-in-a-string

# @param {String} s
# @return {Integer}
def first_uniq_char(s)
  a = s.chars
  hash = a.each_with_object(Hash.new(0)) do |e, h|
    h[e] += 1
  end
  hash.key(1) ? a.index(hash.key(1)) : -1
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_first_uniq_char < Test::Unit::TestCase
  def test_
    assert_equal 0, first_uniq_char(""leetcode"")
    assert_equal 2, first_uniq_char(""loveleetcode"")
    assert_equal(-1, first_uniq_char(""aabb""))
  end
end
"
0389,find-the-difference,"# frozen_string_literal: true

# 389. Find the Difference
# Easy
# https://leetcode.com/problems/find-the-difference

=begin
You are given two strings s and t.

String t is generated by random shuffling string s and then add one more letter at a random position.
Return the letter that was added to t.

Example 1:
Input: s = ""abcd"", t = ""abcde""
Output: ""e""
Explanation: 'e' is the letter that was added.

Example 2:
Input: s = """", t = ""y""
Output: ""y""

Constraints:
0 <= s.length <= 1000
t.length == s.length + 1
s and t consist of lowercase English letters.
=end

# @param {String} s
# @param {String} t
# @return {Character}
def find_the_difference(s, t)
  (s + t).bytes.reduce(:^).chr
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_find_the_difference < Test::Unit::TestCase
  def test_
    assert_equal ""e"", find_the_difference(""abcd"", ""abcde"")
    assert_equal ""y"", find_the_difference("""", ""y"")
  end
end
"
0392,is-subsequence,"# frozen_string_literal: true

# 392. Is Subsequence
# https://leetcode.com/problems/is-subsequence
# Easy

=begin

Given two strings s and t, return true if s is a subsequence of t, or false otherwise.

A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., ""ace"" is a subsequence of ""abcde"" while ""aec"" is not).

### Example 1:

Input: s = ""abc"", t = ""ahbgdc""
Output: true

### Example 2:

Input: s = ""axc"", t = ""ahbgdc""
Output: false

### Constraints:

* 0 <= s.length <= 100
* 0 <= t.length <= 104
* s and t consist only of lowercase English letters.

=end

# Runtime 86 ms
# Memory 212.1 MB
# @param {String} s
# @param {String} t
# @return {Boolean}
def is_subsequence(s, t)
  return true if s.size == 0
  return false if s.size > t.size

  sp = 0
  t.chars.each do |char|
    if s[sp] == char
      sp += 1
      return true if sp == s.size
    end
  end

  false
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_is_subsequence < Test::Unit::TestCase
  def test_
    assert_equal true, is_subsequence(""abc"", ""ahbgdc"")
    assert_equal false, is_subsequence(""axc"", ""ahbgdc"")
  end
end
"
0394,decode-string,"# frozen_string_literal: true

# 394. Decode String
# https://leetcode.com/problems/decode-string

=begin

Given an encoded string, return its decoded string.

The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.

You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there will not be input like 3a or 2[4].

The test cases are generated so that the length of the output will never exceed 105.

### Example 1:
Input: s = ""3[a]2[bc]""
Output: ""aaabcbc""

### Example 2:
Input: s = ""3[a2[c]]""
Output: ""accaccacc""

### Example 3:
Input: s = ""2[abc]3[cd]ef""
Output: ""abcabccdcdcdef""

### Constraints:
* 1 <= s.length <= 30
* s consists of lowercase English letters, digits, and square brackets '[]'.
* s is guaranteed to be a valid input.
* All the integers in s are in the range [1, 300].
=end

# @param {String} s
# @return {String}
def decode_string(s)
  stack = []
  s.each_char do |c|
    if c == ""]""
      s1 = """"
      while stack.last != ""[""
        s1 = stack.pop + s1
      end
      stack.pop
      n = """"
      while !stack.empty? && stack.last.match?(/[0-9]/)
        n = stack.pop + n
      end
      stack.push(s1 * n.to_i)
    else
      stack.push(c)
    end
  end
  stack.join
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_decode_string < Test::Unit::TestCase
  def test_
    assert_equal ""aaabcbc"", decode_string(""3[a]2[bc]"")
    assert_equal ""accaccacc"", decode_string(""3[a2[c]]"")
    assert_equal ""abcabccdcdcdef"", decode_string(""2[abc]3[cd]ef"")
  end
end
"
0399,evaluate-division,"# frozen_string_literal: true

# 399. Evaluate Division
# https://leetcode.com/problems/evaluate-division
# Medium

=begin
You are given an array of variable pairs equations and an array of real numbers values, where equations[i] = [Ai, Bi] and values[i] represent the equation Ai / Bi = values[i]. Each Ai or Bi is a string that represents a single variable.

You are also given some queries, where queries[j] = [Cj, Dj] represents the jth query where you must find the answer for Cj / Dj = ?.

Return the answers to all queries. If a single answer cannot be determined, return -1.0.

Note: The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.

Example 1:
Input: equations = [[""a"",""b""],[""b"",""c""]], values = [2.0,3.0], queries = [[""a"",""c""],[""b"",""a""],[""a"",""e""],[""a"",""a""],[""x"",""x""]]
Output: [6.00000,0.50000,-1.00000,1.00000,-1.00000]
Explanation:
Given: a / b = 2.0, b / c = 3.0
queries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?
return: [6.0, 0.5, -1.0, 1.0, -1.0 ]

Example 2:
Input: equations = [[""a"",""b""],[""b"",""c""],[""bc"",""cd""]], values = [1.5,2.5,5.0], queries = [[""a"",""c""],[""c"",""b""],[""bc"",""cd""],[""cd"",""bc""]]
Output: [3.75000,0.40000,5.00000,0.20000]

Example 3:
Input: equations = [[""a"",""b""]], values = [0.5], queries = [[""a"",""b""],[""b"",""a""],[""a"",""c""],[""x"",""y""]]
Output: [0.50000,2.00000,-1.00000,-1.00000]

Constraints:
1 <= equations.length <= 20
equations[i].length == 2
1 <= Ai.length, Bi.length <= 5
values.length == equations.length
0.0 < values[i] <= 20.0
1 <= queries.length <= 20
queries[i].length == 2
1 <= Cj.length, Dj.length <= 5
Ai, Bi, Cj, Dj consist of lower case English letters and digits.
=end

# @param {String[][]} equations
# @param {Float[]} values
# @param {String[][]} queries
# @return {Float[]}
def calc_equation(equations, values, queries)
  @graph = Hash.new { |h, k| h[k] = {} }

  equations.zip(values).each do |equation, value|
    variable_1, variable_2 = equation

    @graph[variable_1][variable_2] = value.to_f
    @graph[variable_2][variable_1] = 1.0 / value
    @graph[variable_1][variable_1] = 1.0
    @graph[variable_2][variable_2] = 1.0
  end

  result = []

  queries.each do |variable_1, variable_2|
    if @graph[variable_1].empty? || @graph[variable_2].empty?
      result << -1.0
    else
      result << dfs(variable_1, variable_2, 1.0, Set.new)
    end
  end

  result
end

def dfs(variable_1, variable_2, result, checked_variables_set)
  return result if variable_1 == variable_2

  checked_variables_set << variable_1

  @graph[variable_1].keys.each do |connected_variable|
    unless checked_variables_set.include?(connected_variable)
      value = dfs(
        connected_variable,
        variable_2,
        result * @graph[variable_1][connected_variable],
        checked_variables_set.dup
      )
      return value if value != -1.0
    end
  end

  -1.0
end


# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_calc_equation < Test::Unit::TestCase
  def test_
    assert_equal [6.00000, 0.50000, -1.00000, 1.00000, -1.00000], calc_equation([[""a"", ""b""], [""b"", ""c""]], [2.0, 3.0], [[""a"", ""c""], [""b"", ""a""], [""a"", ""e""], [""a"", ""a""], [""x"", ""x""]])
    assert_equal [3.75000, 0.40000, 5.00000, 0.20000], calc_equation([[""a"", ""b""], [""b"", ""c""], [""bc"", ""cd""]], [1.5, 2.5, 5.0], [[""a"", ""c""], [""c"", ""b""], [""bc"", ""cd""], [""cd"", ""bc""]])
    assert_equal [0.50000, 2.00000, -1.00000, -1.00000], calc_equation([[""a"", ""b""]], [0.5], [[""a"", ""b""], [""b"", ""a""], [""a"", ""c""], [""x"", ""y""]])
  end
end
"
0403,frog-jump,"# frozen_string_literal: true

# 403. Frog Jump
# Hard
# https://leetcode.com/problems/frog-jump

=begin
A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.
Given a list of stones' positions (in units) in sorted ascending order, determine if the frog can cross the river by landing on the last stone. Initially, the frog is on the first stone and assumes the first jump must be 1 unit.
If the frog's last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.

Example 1:
Input: stones = [0,1,3,5,6,8,12,17]
Output: true
Explanation: The frog can jump to the last stone by jumping 1 unit to the 2nd stone, then 2 units to the 3rd stone, then 2 units to the 4th stone, then 3 units to the 6th stone, 4 units to the 7th stone, and 5 units to the 8th stone.

Example 2:
Input: stones = [0,1,2,3,4,8,9,11]
Output: false
Explanation: There is no way to jump to the last stone as the gap between the 5th and 6th stone is too large.

Constraints:
* 2 <= stones.length <= 2000
* 0 <= stones[i] <= 231 - 1
* stones[0] == 0
* stones is sorted in a strictly increasing order.
=end

# @param {Integer[]} stones
# @return {Boolean}
def can_cross(stones)
  return false if stones[1] > 1
  state = Hash.new { |hash, key| hash[key] = [] }
  state[0] << 0

  stones.each do |stone|
    state[stone].each do |jump|
      if stone == stones[-1]
        return true
      end

      return false if jump < -1
      check_stone(stone, jump, state)
    end
  end
  false
end

def check_stone(stone, jump, state)
  (-1..1).each do |i|
    next_jump = jump + i
    next if next_jump <= 0
    next_stone = stone + next_jump
    state[next_stone] << next_jump
  end
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_can_cross < Test::Unit::TestCase
  def test_
    assert_equal true, can_cross([0, 1, 3, 5, 6, 8, 12, 17])
    assert_equal false, can_cross([0, 1, 2, 3, 4, 8, 9, 11])
  end
end
"
0409,longest-palindrome,"# frozen_string_literal: true

# 409. Longest Palindrome
# https://leetcode.com/problems/longest-palindrome

=begin

Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters.

Letters are case sensitive, for example, ""Aa"" is not considered a palindrome here.

### Example 1:
Input: s = ""abccccdd""
Output: 7
Explanation: One longest palindrome that can be built is ""dccaccd"", whose length is 7.

### Example 2:
Input: s = ""a""
Output: 1
Explanation: The longest palindrome that can be built is ""a"", whose length is 1.

### Constraints:
* 1 <= s.length <= 2000
* s consists of lowercase and/or uppercase English letters only.

=end

# Runtime 92 ms
# Memory 210.9 MB
# @param {String} s
# @return {Integer}
def longest_palindrome(s)
  [s.size, s.each_char.tally.sum { _2 & ~1 } + 1].min
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_longest_palindrome < Test::Unit::TestCase
  def test_
    assert_equal 7, longest_palindrome(""abccccdd"")
    assert_equal 1, longest_palindrome(""a"")
  end
end
"
0416,partition-equal-subset-sum,"# frozen_string_literal: true

# 416. Partition Equal Subset Sum
# https://leetcode.com/problems/partition-equal-subset-sum/
# Medium

=begin
Given an integer array nums, return true if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or false otherwise.

Example 1:
Input: nums = [1,5,11,5]
Output: true
Explanation: The array can be partitioned as [1, 5, 5] and [11].

Example 2:
Input: nums = [1,2,3,5]
Output: false
Explanation: The array cannot be partitioned into equal sum subsets.

Constraints:
1 <= nums.length <= 200
1 <= nums[i] <= 100
=end

# @param {Integer[]} nums
# @return {Boolean}
def can_partition(nums)
  (s = nums.sum).even? &&
      (nums.reduce(1) { _1 | (_1 << _2) } >> s / 2).odd?
end
"
0417,pacific-atlantic-water-flow,"# frozen_string_literal: true

# 417. Pacific Atlantic Water Flow
# https://leetcode.com/problems/pacific-atlantic-water-flow
# Medium

=begin

There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges.

The island is partitioned into a grid of square cells. You are given an m x n integer heights heights where heights[r][c] represents the height above sea level of the cell at coordinate (r, c).

The island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is less than or equal to the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.

Return a 2D list of grid coordinates result where result[i] = [ri, ci] denotes that rain water can flow from cell (ri, ci) to both the Pacific and Atlantic oceans.

### Example 1:
Input: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]
Output: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]
Explanation: The following cells can flow to the Pacific and Atlantic oceans, as shown below:
[0,4]: [0,4] -> Pacific Ocean
       [0,4] -> Atlantic Ocean
[1,3]: [1,3] -> [0,3] -> Pacific Ocean
       [1,3] -> [1,4] -> Atlantic Ocean
[1,4]: [1,4] -> [1,3] -> [0,3] -> Pacific Ocean
       [1,4] -> Atlantic Ocean
[2,2]: [2,2] -> [1,2] -> [0,2] -> Pacific Ocean
       [2,2] -> [2,3] -> [2,4] -> Atlantic Ocean
[3,0]: [3,0] -> Pacific Ocean
       [3,0] -> [4,0] -> Atlantic Ocean
[3,1]: [3,1] -> [3,0] -> Pacific Ocean
       [3,1] -> [4,1] -> Atlantic Ocean
[4,0]: [4,0] -> Pacific Ocean
       [4,0] -> Atlantic Ocean
Note that there are other possible paths for these cells to flow to the Pacific and Atlantic oceans.

### Example 2:
Input: heights = [[1]]
Output: [[0,0]]
Explanation: The water can flow from the only cell to the Pacific and Atlantic oceans.

### Constraints:
* m == heights.length
* n == heights[r].length
* 1 <= m, n <= 200
* 0 <= heights[r][c] <= 105

=end

# @param {Integer[][]} heights
# @return {Integer[][]}
def pacific_atlantic(heights)
  return [] if heights.empty?
  pacific = Array.new(heights.length) { Array.new(heights[0].length, false) }
  atlantic = Array.new(heights.length) { Array.new(heights[0].length, false) }

  # left side pacific column
  for i in 0...heights.length
    dfs(heights, i, 0, pacific)
  end

  # upper side pacific row
  for j in 0...heights[0].length
    dfs(heights, 0, j, pacific)
  end

  # right side atlantic column
  for i in 0...heights.length
    dfs(heights, i, heights[0].length - 1, atlantic)
  end

  # down side atlantic row
  for j in 0...heights[0].length
    dfs(heights, heights.length - 1, j, atlantic)
  end

  res = []
  for i in 0...heights.length
    for j in 0...heights[0].length
      res << [i, j] if pacific[i][j] && atlantic[i][j]
    end
  end
  res
end

def dfs(heights, i, j, visited)
  visited[i][j] = true
  dfs(heights, i + 1, j, visited) if i + 1 < heights.size && !visited[i + 1][j] && heights[i + 1][j] >= heights[i][j]
  dfs(heights, i - 1, j, visited) if i - 1 >= 0 && !visited[i - 1][j] && heights[i - 1][j] >= heights[i][j]
  dfs(heights, i, j + 1, visited) if j + 1 < heights[0].size && !visited[i][j + 1] && heights[i][j + 1] >= heights[i][j]
  dfs(heights, i, j - 1, visited) if j - 1 >= 0 && !visited[i][j - 1] && heights[i][j - 1] >= heights[i][j]
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_pacific_atlantic < Test::Unit::TestCase
  def test_
    assert_equal([[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]], pacific_atlantic([[1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 4, 5], [5, 1, 1, 2, 4]]))
    assert_equal([[0, 0]], pacific_atlantic([[1]]))
  end
end
"
0424,longest-repeating-character-replacement,"# frozen_string_literal: true

# 424. Longest Repeating Character Replacement
# https://leetcode.com/problems/longest-repeating-character-replacement

=begin

You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.

Return the length of the longest substring containing the same letter you can get after performing the above operations.

### Example 1:
Input: s = ""ABAB"", k = 2
Output: 4
Explanation: Replace the two 'A's with two 'B's or vice versa.

### Example 2:
Input: s = ""AABABBA"", k = 1
Output: 4
Explanation: Replace the one 'A' in the middle with 'B' and form ""AABBBBA"".
The substring ""BBBB"" has the longest repeating letters, which is 4.

### Constraints:
* 1 <= s.length <= 105
* s consists of only uppercase English letters.
* 0 <= k <= s.length

=end

# @param {String} s
# @param {Integer} k
# @return {Integer}
def character_replacement(s, k)
  left = 0
  curr_lead_char_count = 0
  hash = {}
  hash.default = 0

  s.each_char.with_index.reduce(0) do |max_length, (char, right)|
    hash[char] += 1

    curr_lead_char_count = [curr_lead_char_count, hash[char]].max

    if right - left + 1 - curr_lead_char_count > k
      hash[s[left]] -= 1
      left += 1
    end

    [max_length, right - left + 1].max
  end
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_character_replacement < Test::Unit::TestCase
  def test_
    assert_equal 4, character_replacement(""ABAB"", 2)
    assert_equal 4, character_replacement(""AABABBA"", 1)
  end
end
"
0427,construct-quad-tree,"# frozen_string_literal: true

# 427. Construct Quad Tree
# https://leetcode.com/problems/construct-quad-tree

# Definition for a QuadTree node.
# class Node
#     attr_accessor :val, :isLeaf, :topLeft, :topRight, :bottomLeft, :bottomRight
#     def initialize(val=false, isLeaf=false, topLeft=nil, topRight=nil, bottomLeft=nil, bottomRight=nil)
#         @val = val
#         @isLeaf = isLeaf
#         @topLeft = topLeft
#         @topRight = topRight
#         @bottomLeft = bottomLeft
#         @bottomRight = bottomRight
#     end
# end

# @param {Integer[][]} grid
# @return {Node}
def construct(grid, r = 0, c = 0, length = grid.length)
  if same?(grid, r, c, length)
    return Node.new(grid[r][c] == 1 ? true : false, true)
  end

  node = Node.new(true, false)
  node.topLeft = construct(grid, r, c, length / 2)
  node.topRight = construct(grid, r, c + length / 2, length / 2)
  node.bottomLeft = construct(grid, r + length / 2, c, length / 2)
  node.bottomRight = construct(grid, r + length / 2, c + length / 2, length / 2)
  node
end

def same?(grid, r, c, n)
  for i in r..r + n - 1
    for j in c..c + n - 1
      if grid[i][j] != grid[r][c]
        return false
      end
    end
  end

  true
end
"
0433,minimum-genetic-mutation,"# frozen_string_literal: true

# 433. Minimum Genetic Mutation
# https://leetcode.com/problems/minimum-genetic-mutation
# Medium

=begin
A gene string can be represented by an 8-character long string, with choices from 'A', 'C', 'G', and 'T'.
Suppose we need to investigate a mutation from a gene string startGene to a gene string endGene where one mutation is defined as one single character changed in the gene string.
* For example, ""AACCGGTT"" --> ""AACCGGTA"" is one mutation.

There is also a gene bank bank that records all the valid gene mutations. A gene must be in bank to make it a valid gene string.

Given the two gene strings startGene and endGene and the gene bank bank, return the minimum number of mutations needed to mutate from startGene to endGene. If there is no such a mutation, return -1.

Note that the starting point is assumed to be valid, so it might not be included in the bank.

Example 1:
Input: startGene = ""AACCGGTT"", endGene = ""AACCGGTA"", bank = [""AACCGGTA""]
Output: 1

Example 2:
Input: startGene = ""AACCGGTT"", endGene = ""AAACGGTA"", bank = [""AACCGGTA"",""AACCGCTA"",""AAACGGTA""]
Output: 2

Constraints:
* 0 <= bank.length <= 10
* startGene.length == endGene.length == bank[i].length == 8
* startGene, endGene, and bank[i] consist of only the characters ['A', 'C', 'G', 'T'].
=end

# @param {String} start
# @param {String} end
# @param {String[]} bank
# @return {Integer}
def min_mutation(start_gene, end_gene, bank)
  queue = [[start_gene, 0]]

  queue.each do |word, depth|
    bank.reject! do |next_word|
      if one_mutation_away?(word, next_word)
        queue << [next_word, depth + 1]
        true
      else
        false
      end
    end
  end

  queue.to_h[end_gene] || -1
end

def one_mutation_away?(word1, word2)
  (0..7).count { |i| word1[i] != word2[i] } == 1
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_min_mutation < Test::Unit::TestCase
  def test_
    assert_equal 1, min_mutation(""AACCGGTT"", ""AACCGGTA"", [""AACCGGTA""])
    assert_equal 2, min_mutation(""AACCGGTT"", ""AAACGGTA"", [""AACCGGTA"", ""AACCGCTA"", ""AAACGGTA""])
  end
end
"
0435,non-overlapping-intervals,"# frozen_string_literal: true

# 435. Non-overlapping Intervals
# https://leetcode.com/problems/non-overlapping-intervals
# Medium

=begin
Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.

Example 1:
Input: intervals = [[1,2],[2,3],[3,4],[1,3]]
Output: 1
Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.

Example 2:
Input: intervals = [[1,2],[1,2],[1,2]]
Output: 2
Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.

Example 3:
Input: intervals = [[1,2],[2,3]]
Output: 0
Explanation: You don't need to remove any of the intervals since they're already non-overlapping.

Constraints:
1 <= intervals.length <= 105
intervals[i].length == 2
-5 * 104 <= starti < endi <= 5 * 104
=end

# @param {Integer[][]} intervals
# @return {Integer}
def erase_overlap_intervals(intervals)
  return 0 if intervals.count <= 1

  result = 0
  end_point = -Float::INFINITY
  intervals.sort_by(&:last).each do |interval|
    if interval.first >= end_point
      end_point = interval.last
    else
      result += 1
    end
  end

  result
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_erase_overlap_intervals < Test::Unit::TestCase
  def test_
    assert_equal 1, erase_overlap_intervals([[1, 2], [2, 3], [3, 4], [1, 3]])
    assert_equal 2, erase_overlap_intervals([[1, 2], [1, 2], [1, 2]])
    assert_equal 0, erase_overlap_intervals([[1, 2], [2, 3]])
  end
end
"
0437,path-sum-iii,"# frozen_string_literal: true

# 437. Path Sum III
# https://leetcode.com/problems/path-sum-iii/
# Medium

=begin
Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum.

The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).

Example 1:
Input: root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
Output: 3
Explanation: The paths that sum to 8 are shown.

Example 2:
Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
Output: 3

Constraints:
* The number of nodes in the tree is in the range [0, 1000].
* -109 <= Node.val <= 109
* -1000 <= targetSum <= 1000
=end

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root
# @param {Integer} target_sum
# @return {Integer}
def path_sum(root, target_sum)
  return 0 if !root
  count = 0
  stack = [[root, root.val, { 0 => 1 }]] # node, curr_sum, prefix_sums
  while stack.length > 0 do
    node, curr_sum, prefix_sums = stack.pop
    matching_prefix_sum = curr_sum - target_sum
    count += prefix_sums[matching_prefix_sum] || 0
    prefix_sums[curr_sum] = 1 + (prefix_sums[curr_sum] || 0)
    stack << [node.right, curr_sum + node.right.val, prefix_sums.clone] if node.right
    stack << [node.left, curr_sum + node.left.val, prefix_sums.clone] if node.left
  end
  count
end
"
0438,find-all-anagrams-in-a-string,"# frozen_string_literal: true

# 438. Find All Anagrams in a String
# https://leetcode.com/problems/find-all-anagrams-in-a-string

=begin

Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may return the answer in any order.

An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

### Example 1:
Input: s = ""cbaebabacd"", p = ""abc""
Output: [0,6]
Explanation:
The substring with start index = 0 is ""cba"", which is an anagram of ""abc"".
The substring with start index = 6 is ""bac"", which is an anagram of ""abc"".

### Example 2:
Input: s = ""abab"", p = ""ab""
Output: [0,1,2]
Explanation:
The substring with start index = 0 is ""ab"", which is an anagram of ""ab"".
The substring with start index = 1 is ""ba"", which is an anagram of ""ab"".
The substring with start index = 2 is ""ab"", which is an anagram of ""ab"".

### Constraints:
* 1 <= s.length, p.length <= 3 * 104
* s and p consist of lowercase English letters.

=end

# @param {String} s
# @param {String} p
# @return {Integer[]}
def find_anagrams(s, p)
  p_hash = Hash.new(0)
  p.each_char { |c| p_hash[c] += 1 }

  i = 0
  j = 0
  res = []

  while j < s.size
    if p_hash[s[j]] != 0
      p_hash[s[j]] -= 1
      res << i if j - i == p.size - 1
      j += 1
    elsif i == j
      i += 1
      j += 1
    else
      p_hash[s[i]] += 1
      i += 1
    end
  end
  res
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_find_anagrams < Test::Unit::TestCase
  def test_
    assert_equal [0, 6], find_anagrams(""cbaebabacd"", ""abc"")
    assert_equal [0, 1, 2], find_anagrams(""abab"", ""ab"")
  end
end
"
0443,string-compression,"# frozen_string_literal: true

# 443. String Compression
# https://leetcode.com/problems/string-compression

# @param {Character[]} chars
# @return {Integer}
def compress(chars)
  n = chars.length

  return 1 if n == 1

  i = 0
  j = 0
  count = 0

  while i < n do
    count += 1

    if chars[i + 1] != chars[i]
      chars[j] = chars[i]
      j += 1

      if count > 1
        count.to_s.each_char do |char|
          chars[j] = char
          j += 1
        end
      end

      count = 0
    end

    i += 1
  end

  j
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_compress < Test::Unit::TestCase
  def test_
    assert_equal 6, compress([""a"", ""a"", ""b"", ""b"", ""c"", ""c"", ""c""])
    assert_equal 1, compress([""a""])
    assert_equal 4, compress([""a"", ""b"", ""b"", ""b"", ""b"", ""b"", ""b"", ""b"", ""b"", ""b"", ""b"", ""b"", ""b""])
  end
end
"
0445,add-two-numbers-ii,"# frozen_string_literal: true

# 445. Add Two Numbers II
# Medium
# https://leetcode.com/problems/add-two-numbers-ii

=begin
You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.

Example 1:
Input: l1 = [7,2,4,3], l2 = [5,6,4]
Output: [7,8,0,7]

Example 2:
Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [8,0,7]

Example 3:
Input: l1 = [0], l2 = [0]
Output: [0]

Constraints:
The number of nodes in each linked list is in the range [1, 100].
0 <= Node.val <= 9
It is guaranteed that the list represents a number that does not have leading zeros.
=end

# Definition for singly-linked list.
# class ListNode
#     attr_accessor :val, :next
#     def initialize(val = 0, _next = nil)
#         @val = val
#         @next = _next
#     end
# end
# @param {ListNode} l1
# @param {ListNode} l2
# @return {ListNode}
def add_two_numbers(l1, l2)
  num1 = num2 = 0
  while l1
    num1 = num1 * 10 + l1.val
    l1 = l1.next
  end
  while l2
    num2 = num2 * 10 + l2.val
    l2 = l2.next
  end
  sum = num1 + num2
  return ListNode.new(0) if sum.zero?

  prev = nil
  while sum > 0
    curr = ListNode.new(sum % 10)
    curr.next = prev
    prev = curr
    sum /= 10
  end
  prev
end
"
0450,delete-node-in-a-bst,"# frozen_string_literal: true

# 450. Delete Node in a BST
# https://leetcode.com/problems/delete-node-in-a-bst
# Medium

=begin
Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.

Basically, the deletion can be divided into two stages:

Search for a node to remove.
If the node is found, delete the node.

Example 1:
Input: root = [5,3,6,2,4,null,7], key = 3
Output: [5,4,6,2,null,null,7]
Explanation: Given key to delete is 3. So we find the node with value 3 and delete it.
One valid answer is [5,4,6,2,null,null,7], shown in the above BST.
Please notice that another valid answer is [5,2,6,null,4,null,7] and it's also accepted.

Example 2:
Input: root = [5,3,6,2,4,null,7], key = 0
Output: [5,3,6,2,4,null,7]
Explanation: The tree does not contain a node with value = 0.

Example 3:
Input: root = [], key = 0
Output: []

Constraints:
The number of nodes in the tree is in the range [0, 104].
-105 <= Node.val <= 105
Each node has a unique value.
root is a valid binary search tree.
-105 <= key <= 105
=end

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root
# @param {Integer} key
# @return {TreeNode}
def delete_node(root, key)
  return root if !root

  if root.val == key
    return if !root.right && !root.left
    return root.right if !root.left
    return root.left if !root.right

    right_node = root.right
    right_node = right_node.left while right_node.left

    root.right = delete_node(root.right, right_node.val)
    right_node.left = root.left
    right_node.right = root.right
    return right_node
  elsif root.val < key
    root.right = delete_node(root.right, key)
  else
    root.left = delete_node(root.left, key)
  end

  root
end
"
0452,minimum-number-of-arrows-to-burst-balloons,"# frozen_string_literal: true

# 452. Minimum Number of Arrows to Burst Balloons
# https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons
# Medium

=begin
There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons.

Arrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart <= x <= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.

Given the array points, return the minimum number of arrows that must be shot to burst all balloons.

Example 1:
Input: points = [[10,16],[2,8],[1,6],[7,12]]
Output: 2
Explanation: The balloons can be burst by 2 arrows:
- Shoot an arrow at x = 6, bursting the balloons [2,8] and [1,6].
- Shoot an arrow at x = 11, bursting the balloons [10,16] and [7,12].

Example 2:
Input: points = [[1,2],[3,4],[5,6],[7,8]]
Output: 4
Explanation: One arrow needs to be shot for each balloon for a total of 4 arrows.

Example 3:
Input: points = [[1,2],[2,3],[3,4],[4,5]]
Output: 2
Explanation: The balloons can be burst by 2 arrows:
- Shoot an arrow at x = 2, bursting the balloons [1,2] and [2,3].
- Shoot an arrow at x = 4, bursting the balloons [3,4] and [4,5].

Constraints:
1 <= points.length <= 105
points[i].length == 2
-231 <= xstart < xend <= 231 - 1
=end

# @param {Integer[][]} points
# @return {Integer}
def find_min_arrow_shots(points)
  points.sort_by!(&:first)
  shoot = 0
  index = points.size - 1

  while index >= 0
    shoot += 1
    shoot_point = points[index].first
    index -= 1 while index >= 0 && shoot_point <= points[index].last
  end

  shoot
end
# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_find_min_arrow_shots < Test::Unit::TestCase
  def test_
    assert_equal 2, find_min_arrow_shots([[10, 16], [2, 8], [1, 6], [7, 12]])
    assert_equal 4, find_min_arrow_shots([[1, 2], [3, 4], [5, 6], [7, 8]])
    assert_equal 2, find_min_arrow_shots([[1, 2], [2, 3], [3, 4], [4, 5]])
  end
end
"
0455,assign-cookies,"# frozen_string_literal: true

# 455. Assign Cookies
# Easy
# https://leetcode.com/problems/assign-cookies

=begin
Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.
Each child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] >= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.

Example 1:
Input: g = [1,2,3], s = [1,1]
Output: 1
Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3.
And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.
You need to output 1.

Example 2:
Input: g = [1,2], s = [1,2,3]
Output: 2
Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2.
You have 3 cookies and their sizes are big enough to gratify all of the children,
You need to output 2.
=end

# @param {Integer[]} g
# @param {Integer[]} s
# @return {Integer}
def find_content_children(g, s)
  count = 0

  g.sort!
  s.sort!

  s.each do |cookie|
    if count < g.size && cookie >= g[count]
      count += 1
    end
  end

  count
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_find_content_children < Test::Unit::TestCase
  def test_
    assert_equal 1, find_content_children([1, 2, 3], [1, 1])
    assert_equal 2, find_content_children([1, 2], [1, 2, 3])
  end
end
"
0456,132-pattern,"# frozen_string_literal: true

# 456. 132 Pattern
# Medium
# https://leetcode.com/problems/132-pattern

=begin
Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j] and nums[k] such that i < j < k and nums[i] < nums[k] < nums[j].
Return true if there is a 132 pattern in nums, otherwise, return false.

Example 1:
Input: nums = [1,2,3,4]
Output: false
Explanation: There is no 132 pattern in the sequence.

Example 2:
Input: nums = [3,1,4,2]
Output: true
Explanation: There is a 132 pattern in the sequence: [1, 4, 2].

Example 3:
Input: nums = [-1,3,2,0]
Output: true
Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].

Constraints:
n == nums.length
1 <= n <= 2 * 105
-109 <= nums[i] <= 109
=end

# @param {Integer[]} nums
# @return {Boolean}
def find132pattern(nums)
  stack = []
  minVal = nums[0]
  (1...nums.size).each do |i|
    while (!stack.empty?) && nums[i] >= stack[-1][0]
      stack.pop
    end
    if (!stack.empty?) && nums[i] > stack[-1][1]
      return true
    end
    stack.push([nums[i], minVal])
    minVal = nums[i] < minVal ? nums[i] : minVal
  end
  false
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_find132pattern < Test::Unit::TestCase
  def test_
    assert_equal false, find132pattern([1, 2, 3, 4])
    assert_equal true, find132pattern([3, 1, 4, 2])
    assert_equal true, find132pattern([-1, 3, 2, 0])
  end
end
"
0458,poor-pigs,"# frozen_string_literal: true

# 458. Poor Pigs
# Hard
# https://leetcode.com/problems/poor-pigs

=begin
There are buckets buckets of liquid, where exactly one of the buckets is poisonous. To figure out which one is poisonous, you feed some number of (poor) pigs the liquid to see whether they will die or not. Unfortunately, you only have minutesToTest minutes to determine which bucket is poisonous.
You can feed the pigs according to these steps:
1. Choose some live pigs to feed.
2. For each pig, choose which buckets to feed it. The pig will consume all the chosen buckets simultaneously and will take no time. Each pig can feed from any number of buckets, and each bucket can be fed from by any number of pigs.
3. Wait for minutesToDie minutes. You may not feed any other pigs during this time.
4. After minutesToDie minutes have passed, any pigs that have been fed the poisonous bucket will die, and all others will survive.
5. Repeat this process until you run out of time.
Given buckets, minutesToDie, and minutesToTest, return the minimum number of pigs needed to figure out which bucket is poisonous within the allotted time.

Example 1:
Input: buckets = 4, minutesToDie = 15, minutesToTest = 15
Output: 2
Explanation: We can determine the poisonous bucket as follows:
At time 0, feed the first pig buckets 1 and 2, and feed the second pig buckets 2 and 3.
At time 15, there are 4 possible outcomes:
- If only the first pig dies, then bucket 1 must be poisonous.
- If only the second pig dies, then bucket 3 must be poisonous.
- If both pigs die, then bucket 2 must be poisonous.
- If neither pig dies, then bucket 4 must be poisonous.

Example 2:
Input: buckets = 4, minutesToDie = 15, minutesToTest = 30
Output: 2
Explanation: We can determine the poisonous bucket as follows:
At time 0, feed the first pig bucket 1, and feed the second pig bucket 2.
At time 15, there are 2 possible outcomes:
- If either pig dies, then the poisonous bucket is the one it was fed.
- If neither pig dies, then feed the first pig bucket 3, and feed the second pig bucket 4.
At time 30, one of the two pigs must die, and the poisonous bucket is the one it was fed.

Constraints:
1 <= buckets <= 1000
1 <= minutesToDie <= minutesToTest <= 100
=end

# @param {Integer} buckets
# @param {Integer} minutes_to_die
# @param {Integer} minutes_to_test
# @return {Integer}
def poor_pigs(buckets, minutes_to_die, minutes_to_test)
  pigs = 0
  while (minutes_to_test / minutes_to_die + 1)**pigs < buckets
    pigs += 1
  end
  pigs
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_poor_pigs < Test::Unit::TestCase
  def test_
    assert_equal 2, poor_pigs(4, 15, 15)
    assert_equal 2, poor_pigs(4, 15, 30)
  end
end
"
0459,repeated-substring-pattern,"# frozen_string_literal: true

# 459. Repeated Substring Pattern
# Easy
# https://leetcode.com/problems/repeated-substring-pattern

=begin
Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.

Example 1:
Input: s = ""abab""
Output: true
Explanation: It is the substring ""ab"" twice.

Example 2:
Input: s = ""aba""
Output: false

Example 3:
Input: s = ""abcabcabcabc""
Output: true
Explanation: It is the substring ""abc"" four times or the substring ""abcabc"" twice.

Constraints:
1 <= s.length <= 104
s consists of lowercase English letters.
=end

# @param {String} s
# @return {Boolean}
def repeated_substring_pattern(s)
  str = s + s
  str[1...-1].include? s
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_repeated_substring_pattern < Test::Unit::TestCase
  def test_
    assert_equal true, repeated_substring_pattern(""abab"")
    assert_equal false, repeated_substring_pattern(""aba"")
    assert_equal true, repeated_substring_pattern(""abcabcabcabc"")
  end
end
"
0486,predict-the-winner,"# frozen_string_literal: true

# 486. Predict the Winner
# Medium
# https://leetcode.com/problems/predict-the-winner

=begin
You are given an integer array nums. Two players are playing a game with this array: player 1 and player 2.
Player 1 and player 2 take turns, with player 1 starting first. Both players start the game with a score of 0. At each turn, the player takes one of the numbers from either end of the array (i.e., nums[0] or nums[nums.length - 1]) which reduces the size of the array by 1. The player adds the chosen number to their score. The game ends when there are no more elements in the array.
Return true if Player 1 can win the game. If the scores of both players are equal, then player 1 is still the winner, and you should also return true. You may assume that both players are playing optimally.

Example 1:
Input: nums = [1,5,2]
Output: false
Explanation: Initially, player 1 can choose between 1 and 2.
If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2).
So, final score of player 1 is 1 + 2 = 3, and player 2 is 5.
Hence, player 1 will never be the winner and you need to return false.

Example 2:
Input: nums = [1,5,233,7]
Output: true
Explanation: Player 1 first chooses 1. Then player 2 has to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.
Finally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.

Constraints:
* 1 <= nums.length <= 20
* 0 <= nums[i] <= 107
=end

# @param {Integer[]} nums
# @return {Boolean}
def predict_the_winner(nums)
  n = nums.length
  dp = Array.new(n) { Array.new(n, 0) }
  nums.inject(:+)

  n.downto(0).each do |i|
    (i...n).each do |j|
      if i == j
        dp[i][j] = nums[i]
      else
        dp[i][j] = [nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]].max
      end
    end
  end

  dp[0][n - 1] >= 0
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_predict_the_winner < Test::Unit::TestCase
  def test_
    assert_equal false, predict_the_winner([1, 5, 2])
    assert_equal true, predict_the_winner([1, 5, 233, 7])
  end
end
"
0501,find-mode-in-binary-search-tree,"# frozen_string_literal: true

# 501. Find Mode in Binary Search Tree
# Easy
# https://leetcode.com/problems/find-mode-in-binary-search-tree

=begin
Given the root of a binary search tree (BST) with duplicates, return all the mode(s) (i.e., the most frequently occurred element) in it.
If the tree has more than one mode, return them in any order.
Assume a BST is defined as follows:
* The left subtree of a node contains only nodes with keys less than or equal to the node's key.
* The right subtree of a node contains only nodes with keys greater than or equal to the node's key.
* Both the left and right subtrees must also be binary search trees.

Example 1:
Input: root = [1,null,2,2]
Output: [2]

Example 2:
Input: root = [0]
Output: [0]

Constraints:
* The number of nodes in the tree is in the range [1, 104].
* -105 <= Node.val <= 105
=end

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root
# @return {Integer[]}
def find_mode(root)
  inorder(root, 0, 0, nil, modes = [])

  modes
end

def inorder(root, local_max, global_max, prev, modes)
  return [local_max, global_max, prev] unless root

  local_max, global_max, prev = inorder(root.left, local_max, global_max, prev, modes)
  val = root.val

  if prev&.val == root.val
    local_max += 1
  else
    local_max = 1
  end
  if local_max == global_max
    modes << val
  elsif local_max > global_max
    global_max = local_max
    modes.clear
    modes << val
  end
  prev = root
  local_max, global_max, prev = inorder(root.right, local_max, global_max, prev, modes)
  [local_max, global_max, prev]
end
"
0502,ipo,"# frozen_string_literal: true

# 502. IPO
# https://leetcode.com/problems/ipo

# @param {Integer} k
# @param {Integer} w
# @param {Integer[]} profits
# @param {Integer[]} capital
# @return {Integer}
def bs_insert(a, item)
  a.insert(a.bsearch_index { item <= _1 } || a.size, item)
end

def find_maximized_capital(k, w, profits, costs)
  tasks = costs.zip(profits).sort
  sorted_profits = []

  k.times.reduce(w) do |capital, _|
    while tasks[0] && capital >= tasks[0][0]
      bs_insert(sorted_profits, tasks.shift[1])
    end

    capital + (sorted_profits.pop || 0)
  end
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_find_maximized_capital < Test::Unit::TestCase
  def test_
    assert_equal 4, find_maximized_capital(2, 0, [1, 2, 3], [0, 1, 1])
    assert_equal 6, find_maximized_capital(3, 0, [1, 2, 3], [0, 1, 2])
  end
end
"
0509,fibonacci-number,"# frozen_string_literal: true

# 509. Fibonacci Number
# https://leetcode.com/problems/fibonacci-number

# @param {Integer} n
# @return {Integer}
def fib(n)
  case n
  when 0
    return 0
  when 1
    return 1
  end

  fib(n - 1) + fib(n - 2)
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_fib < Test::Unit::TestCase
  def test_
    assert_equal 1, fib(2)
    assert_equal 2, fib(3)
    assert_equal 3, fib(4)
  end
end
"
0515,find-largest-value-in-each-tree-row,"# 515. Find Largest Value in Each Tree Row
# Medium
# https://leetcode.com/problems/find-largest-value-in-each-tree-row

=begin
Given the root of a binary tree, return an array of the largest value in each row of the tree (0-indexed).

Example 1:
Input: root = [1,3,2,5,3,null,9]
Output: [1,3,9]

Example 2:
Input: root = [1,2,3]
Output: [1,3]

Constraints:
The number of nodes in the tree will be in the range [0, 104].
-231 <= Node.val <= 231 - 1
=end

# frozen_string_literal: true

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root
# @return {Integer[]}
def largest_values(root)
  return [] if root.nil?

  res = []

  queue = Queue.new

  queue << root

  while !queue.empty? do
    n_a = []
    queue.size.times do
      node = queue.pop

      n_a << node.val
      if node.left != nil
        queue << node.left
      end

      if node.right != nil
        queue << node.right
      end
    end
    res << n_a.max
  end

  res
end
"
0516,longest-palindromic-subsequence,"# frozen_string_literal: true

# 516. Longest Palindromic Subsequence
# https://leetcode.com/problems/longest-palindromic-subsequence/
# Medium

=begin

Given a string s, find the longest palindromic subsequence's length in s.

A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.

### Example 1:
Input: s = ""bbbab""
Output: 4
Explanation: One possible longest palindromic subsequence is ""bbbb"".

### Example 2:
Input: s = ""cbbd""
Output: 2
Explanation: One possible longest palindromic subsequence is ""bb"".

### Constraints:
* 1 <= s.length <= 1000
* s consists only of lowercase English letters.

=end

# @param {String} s
# @return {Integer}
def longest_palindrome_subseq(s)
  dp, dp_nxt = 2.times.collect { |i| Array.new(s.size, 0) }
  (s.size - 1).downto(0) { |i|
    dp_nxt[i] = 1
    (i + 1...s.size).each { |j|
      dp_nxt[j] = (s[i] == s[j]) ? dp[j - 1] + 2 : [dp[j], dp_nxt[j - 1]].max
    }
    dp, dp_nxt = dp_nxt, dp
  }
  dp.last
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_longest_palindrome_subseq < Test::Unit::TestCase
  def test_
    assert_equal 4, longest_palindrome_subseq(""bbbab"")
    assert_equal 2, longest_palindrome_subseq(""cbbd"")
  end
end
"
0518,coin-change-ii,"# frozen_string_literal: true

# 518. Coin Change II
# Medium
# https://leetcode.com/problems/coin-change-ii

=begin
You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.
Return the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.
You may assume that you have an infinite number of each kind of coin.
The answer is guaranteed to fit into a signed 32-bit integer.

Example 1:
Input: amount = 5, coins = [1,2,5]
Output: 4
Explanation: there are four ways to make up the amount:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1

Example 2:
Input: amount = 3, coins = [2]
Output: 0
Explanation: the amount of 3 cannot be made up just with coins of 2.

Example 3:
Input: amount = 10, coins = [10]
Output: 1

Constraints:
* 1 <= coins.length <= 300
* 1 <= coins[i] <= 5000
* All the values of coins are unique.
* 0 <= amount <= 5000
=end

# @param {Integer} amount
# @param {Integer[]} coins
# @return {Integer}
def change(amount, coins)
  dp = Array.new(amount + 1, 0)
  dp[0] = 1
  coins.each do |coin|
    (coin..amount).each do |x|
      dp[x] += dp[x - coin]
    end
  end
  dp[amount]
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_length_of_longest_substring < Test::Unit::TestCase
  def test_
    assert_equal 4, change(5, [1, 2, 5])
    assert_equal 0, change(3, [2])
    assert_equal 1, change(10, [10])
  end
end
"
0530,minimum-absolute-difference-in-bst,"# frozen_string_literal: true

# 530. Minimum Absolute Difference in BST
# https://leetcode.com/problems/minimum-absolute-difference-in-bst
# Easy

=begin
Given the root of a Binary Search Tree (BST), return the minimum absolute difference between the values of any two different nodes in the tree.

Example 1:
Input: root = [4,2,6,1,3]
Output: 1

Example 2:
Input: root = [1,0,48,null,null,12,49]
Output: 1

Constraints:
* The number of nodes in the tree is in the range [2, 104].
* 0 <= Node.val <= 105
=end

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root
# @return {Integer}
# @param {TreeNode} root
# @return {Integer}
def get_minimum_difference(root)
  @prev = nil
  @min_diff = Float::INFINITY

  in_order_traversal(root)
  @min_diff
end

def in_order_traversal(node)
  return if node.nil?

  in_order_traversal(node.left)

  if @prev
    diff = node.val - @prev.val
    @min_diff = [@min_diff, diff].min
  end

  @prev = node
  in_order_traversal(node.right)
end
"
0540,single-element-in-a-sorted-array,"# frozen_string_literal: true

# 540. Single Element in a Sorted Array
# https://leetcode.com/problems/single-element-in-a-sorted-array

# @param {Integer[]} nums
# @return {Integer}
def single_non_duplicate1(nums, left = 0, right = nums.size - 1)
  return nums[left] if left == right

  mid = (left + right) / 2
  mid -= 1 if mid % 2 == 1

  return single_non_duplicate1(nums, left, mid - 2) if nums[mid] == nums[mid - 1]
  return single_non_duplicate1(nums, mid + 2, right) if nums[mid] == nums[mid + 1]

  nums[mid]
end

def single_non_duplicate2(nums)
  left, right = 0, nums.size - 1

  while left < right
    m = (left + right) / 2
    if nums[m] != nums[m ^ 1]
      right = m
    else
      left = m + 1
    end
  end

  nums[left]
end

def single_non_duplicate3(nums)
  nums[ (0...nums.size).bsearch { |i| nums[i] != nums[i ^ 1] } ]
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_single_non_duplicate < Test::Unit::TestCase
  def test_
    assert_equal 2, single_non_duplicate1([1, 1, 2, 3, 3, 4, 4, 8, 8])
    assert_equal 10, single_non_duplicate1([3, 3, 7, 7, 10, 11, 11])

    assert_equal 2, single_non_duplicate2([1, 1, 2, 3, 3, 4, 4, 8, 8])
    assert_equal 10, single_non_duplicate2([3, 3, 7, 7, 10, 11, 11])

    assert_equal 2, single_non_duplicate3([1, 1, 2, 3, 3, 4, 4, 8, 8])
    assert_equal 10, single_non_duplicate3([3, 3, 7, 7, 10, 11, 11])
  end
end

# ********************#
#     Benchmark       #
# ********************#

require ""benchmark""

nums = [3, 3, 7, 7, 10, 10, 11, 11, 12, 12, 15, 15, 16, 16, 17, 17, 18, 20, 20, 21, 21, 22, 22, 23, 23]
Benchmark.bm do |x|
  x.report(""single_non_duplicate1: "") { single_non_duplicate1(nums) }
  x.report(""single_non_duplicate2: "") { single_non_duplicate2(nums) }
  x.report(""single_non_duplicate3: "") { single_non_duplicate3(nums) }
end

# user     system      total        real
# single_non_duplicate1:   0.000017   0.000006   0.000023 (  0.000015)
# single_non_duplicate2:   0.000013   0.000001   0.000014 (  0.000012)
# single_non_duplicate3:   0.000011   0.000003   0.000014 (  0.000013)
"
0542,01-matrix,"# frozen_string_literal: true

# 542. 01 Matrix
# Medium
# https://leetcode.com/problems/01-matrix

=begin
Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell.
The distance between two adjacent cells is 1.

Example 1:
Input: mat = [[0,0,0],[0,1,0],[0,0,0]]
Output: [[0,0,0],[0,1,0],[0,0,0]]

Example 2:
Input: mat = [[0,0,0],[0,1,0],[1,1,1]]
Output: [[0,0,0],[0,1,0],[1,2,1]]

Constraints:
* m == mat.length
* n == mat[i].length
* 1 <= m, n <= 104
* 1 <= m * n <= 104
* mat[i][j] is either 0 or 1.
* There is at least one 0 in mat.
=end

# @param {Integer[][]} mat
# @return {Integer[][]}
def update_matrix(matrix)
  rows = matrix.size
  cols = matrix.first.size

  queue = []
  max = Float::INFINITY

  # Identify the cells with 0's and initialize the rest of the cells to max
  (0...rows).each do |r|
    (0...cols).each do |c|
      if matrix[r][c] == 0
        queue.push([r, c])
      else
        matrix[r][c] = max
      end
    end
  end

  directions = [[1, 0], [-1, 0], [0, 1], [0, -1]] # down, up, right and left

  while queue.size > 0 do
    cell = queue.shift

    directions.each do |direction|
      r = cell.first + direction.first
      c = cell.last + direction.last

      # If the neighbor cell is out of bounds OR it has lower or equal distance, then ignore current neighbor
      if r < 0 || c < 0 || r == rows || c == cols || matrix[r][c] <= matrix[cell.first][cell.last] + 1
        next
      end

      # update the distance of the neighbour to current distance + 1
      queue.push([r, c])
      matrix[r][c] = matrix[cell.first][cell.last] + 1
    end
  end

  matrix
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_update_matrix < Test::Unit::TestCase
  def test_
    assert_equal [[0, 0, 0], [0, 1, 0], [0, 0, 0]], update_matrix([[0, 0, 0], [0, 1, 0], [0, 0, 0]])
    assert_equal [[0, 0, 0], [0, 1, 0], [1, 2, 1]], update_matrix([[0, 0, 0], [0, 1, 0], [1, 1, 1]])
  end
end
"
0543,diameter-of-binary-tree,"# frozen_string_literal: true

# 543. Diameter of Binary Tree
# https://leetcode.com/problems/diameter-of-binary-tree/
# Easy

=begin
Given the root of a binary tree, return the length of the diameter of the tree.

The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.

The length of a path between two nodes is represented by the number of edges between them.

Example 1:
Input: root = [1,2,3,4,5]
Output: 3
Explanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].

Example 2:
Input: root = [1,2]
Output: 1

Constraints:
* The number of nodes in the tree is in the range [1, 104].
* -100 <= Node.val <= 100
=end

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root
# @return {Integer}
def diameter_of_binary_tree(root)
  diameter = 0

  longest_path = lambda do |node|
    return 0 if node.nil?

    left_path = longest_path[node.left]
    right_path = longest_path[node.right]

    diameter = [diameter, left_path + right_path].max

    [left_path, right_path].max + 1
  end

  longest_path[root]

  diameter
end
"
0547,number-of-provinces,"# frozen_string_literal: true

# 547. Number of Provinces
# https://leetcode.com/problems/number-of-provinces
# Medium

=begin
There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, then city a is connected indirectly with city c.

A province is a group of directly or indirectly connected cities and no other cities outside of the group.

You are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are directly connected, and isConnected[i][j] = 0 otherwise.

Return the total number of provinces.

Example 1:
Input: isConnected = [[1,1,0],[1,1,0],[0,0,1]]
Output: 2

Example 2:
Input: isConnected = [[1,0,0],[0,1,0],[0,0,1]]
Output: 3

Constraints:
1 <= n <= 200
n == isConnected.length
n == isConnected[i].length
isConnected[i][j] is 1 or 0.
isConnected[i][i] == 1
isConnected[i][j] == isConnected[j][i]
=end

# @param {Integer[][]} is_connected
# @return {Integer}
def find_circle_num(is_connected)
  visited = Array.new(is_connected.size, 0)
  count = 0
  is_connected.size.times do |i|
    if visited[i] == 0
      dfs(is_connected, visited, i)
      count += 1
    end
  end
  count
end

def dfs(m, visited, i)
  m.size.times do |j|
    if m[i][j] == 1 && visited[j] == 0
      visited[j] = 1
      dfs(m, visited, j)
    end
  end
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_find_circle_num < Test::Unit::TestCase
  def test_
    assert_equal 2, find_circle_num([[1, 1, 0], [1, 1, 0], [0, 0, 1]])
    assert_equal 3, find_circle_num([[1, 0, 0], [0, 1, 0], [0, 0, 1]])
  end
end
"
0557,reverse-words-in-a-string-iii,"# frozen_string_literal: true

# 557. Reverse Words in a String III
# https://leetcode.com/problems/reverse-words-in-a-string-iii

# @param {String} s
# @return {String}
def reverse_words(s)
  s.split.map(&:reverse).join("" "")
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_reverse_words < Test::Unit::TestCase
  def test_
    assert_equal ""s'teL ekat edoCteeL tsetnoc"", reverse_words(""Let's take LeetCode contest"")
    assert_equal ""doG gniD"", reverse_words(""God Ding"")
  end
end
"
0567,permutation-in-string,"# frozen_string_literal: true

# 567. Permutation in String
# https://leetcode.com/problems/permutation-in-string

# @param {String} s1
# @param {String} s2
# @return {Boolean}
def check_inclusion(s1, s2)
  return false if s1.size > s2.size

  s1_h = Hash.new(0)
  s1.each_char { |c| s1_h[c] += 1 }

  i = 0
  j = 0

  while j < s2.size
    if s1_h[s2[j]] != 0
      s1_h[s2[j]] -= 1
      return true if j - i == s1.size - 1

      j += 1
    elsif i == j
      i += 1
      j += 1
    else
      s1_h[s2[i]] += 1
      i += 1
    end
  end

  false
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_check_inclusion < Test::Unit::TestCase
  def test_
    assert_equal true, check_inclusion(""ab"", ""eidbaooo"")
    assert_equal false, check_inclusion(""ab"", ""eidboaoo"")
  end
end
"
0589,n-ary-tree-preorder-traversal,"# frozen_string_literal: true

# 589. N-ary Tree Preorder Traversal
# https://leetcode.com/problems/n-ary-tree-preorder-traversal

=begin

Given the root of an n-ary tree, return the preorder traversal of its nodes' values.

Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)

### Example 1:
Input: root = [1,null,3,2,4,null,5,6]
Output: [1,3,5,6,2,4]

### Example 2:
Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
Output: [1,2,3,6,7,11,14,4,8,12,5,9,13,10]

### Constraints:
* The number of nodes in the tree is in the range [0, 104].
* 0 <= Node.val <= 104
* The height of the n-ary tree is less than or equal to 1000.

=end

# Definition for a Node.
# class Node
#     attr_accessor :val, :children
#     def initialize(val)
#         @val = val
#         @children = []
#     end
# end

# Runtime: 112 ms
# Memory: 211.7 MB
# @param {Node} root
# @return {List[int]}
def preorder(root)
  loop.reduce([[], root ? [root] : []]) do | (r, s) |
    s.empty? ? (break r) : [
      r << (root = s.pop).val, s.push(*root.children.reverse_each)
    ]
  end
end
"
0605,can-place-flowers,"# frozen_string_literal: true

# 605. Can Place Flowers
# https://leetcode.com/problems/can-place-flowers
# Easy

=begin

You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.

Given an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule.

### Constraints:

* 1 <= flowerbed.length <= 2 * 104
* flowerbed[i] is 0 or 1.
* There are no two adjacent flowers in flowerbed.
* 0 <= n <= flowerbed.length

=end

# @param {Integer[]} flowerbed
# @param {Integer} n
# @return {Boolean}
# Runtime 80 ms, Beats 100%
# Memory 212.4 MB, Beats 28.57%
def can_place_flowers1(flowerbed, n)
  return true if n == 0

  flowerbed_count = flowerbed.count
  index = 0
  count_of_plant = 0

  while index < flowerbed_count
    break if count_of_plant == n

    if flowerbed[index] == 1
      index += 2
      next
    elsif index == flowerbed_count - 1 || flowerbed[index + 1] == 0
      flowerbed[index] = 1

      index += 2
      count_of_plant += 1
    else
      index += 1
    end
  end

  count_of_plant == n
end

# @param {Integer[]} flowerbed
# @param {Integer} n
# @return {Boolean}
# Runtime 124 ms, Beats 28.57%
# Memory 212.5 MB, Beats 19.5%
def can_place_flowers2(flowerbed, n)
  planted = 0
  (0...flowerbed.size).each do |i|
    one = i - 1 == -1 || 0 == flowerbed[i - 1]
    two =  i + 1 == flowerbed.size || 0 == flowerbed[i + 1]
    if one && two
      planted += 1 if 0 == flowerbed[i]
      return true if planted >= n
      flowerbed[i] = 1
    end
  end
  planted >= n
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_can_place_flowers < Test::Unit::TestCase
  def test_
    assert_equal true, can_place_flowers1([1, 0, 0, 0, 1], 1)
    assert_equal false, can_place_flowers1([1, 0, 0, 0, 1], 2)

    assert_equal true, can_place_flowers2([1, 0, 0, 0, 1], 1)
    assert_equal false, can_place_flowers2([1, 0, 0, 0, 1], 2)
  end
end

# ********************#
#     Benchmark       #
# ********************#

require ""benchmark""

flowerbed = [1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1]
n = 5
Benchmark.bm do |x|
  x.report(""can_place_flowers1: "") { can_place_flowers1(flowerbed, n) }
  x.report(""can_place_flowers2: "") { can_place_flowers2(flowerbed, n) }
end
"
0606,construct-string-from-binary-tree,"# frozen_string_literal: true

# 606. Construct String from Binary Tree
# Easy
# https://leetcode.com/problems/construct-string-from-binary-tree

=begin
Given the root of a binary tree, construct a string consisting of parenthesis and integers from a binary tree with the preorder traversal way, and return it.
Omit all the empty parenthesis pairs that do not affect the one-to-one mapping relationship between the string and the original binary tree.

Example 1:
Input: root = [1,2,3,4]
Output: ""1(2(4))(3)""
Explanation: Originally, it needs to be ""1(2(4)())(3()())"", but you need to omit all the unnecessary empty parenthesis pairs. And it will be ""1(2(4))(3)""

Example 2:
Input: root = [1,2,3,null,4]
Output: ""1(2()(4))(3)""
Explanation: Almost the same as the first example, except we cannot omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output.

Constraints:
The number of nodes in the tree is in the range [1, 104].
-1000 <= Node.val <= 1000
=end

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root
# @return {String}
def tree2str(root)
  return """" if root.nil?

  string = root.val.to_s
  string += ""(#{tree2str(root.left)})"" if root.left || root.right
  string += ""(#{tree2str(root.right)})"" if root.right

  string
end
"
0621,task-scheduler,"# frozen_string_literal: true

# 621. Task Scheduler
# https://leetcode.com/problems/task-scheduler
# Medium

=begin
Given a characters array tasks, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle.

However, there is a non-negative integer n that represents the cooldown period between two same tasks (the same letter in the array), that is that there must be at least n units of time between any two same tasks.

Return the least number of units of times that the CPU will take to finish all the given tasks.

Example 1:
Input: tasks = [""A"",""A"",""A"",""B"",""B"",""B""], n = 2
Output: 8
Explanation:
A -> B -> idle -> A -> B -> idle -> A -> B
There is at least 2 units of time between any two same tasks.

Example 2:
Input: tasks = [""A"",""A"",""A"",""B"",""B"",""B""], n = 0
Output: 6
Explanation: On this case any permutation of size 6 would work since n = 0.
[""A"",""A"",""A"",""B"",""B"",""B""]
[""A"",""B"",""A"",""B"",""A"",""B""]
[""B"",""B"",""B"",""A"",""A"",""A""]
...
And so on.

Example 3:
Input: tasks = [""A"",""A"",""A"",""A"",""A"",""A"",""B"",""C"",""D"",""E"",""F"",""G""], n = 2
Output: 16
Explanation:
One possible solution is
A -> B -> C -> A -> D -> E -> A -> F -> G -> A -> idle -> idle -> A -> idle -> idle -> A


Constraints:
1 <= task.length <= 104
tasks[i] is upper-case English letter.
The integer n is in the range [0, 100].
=end

# @param {Character[]} tasks
# @param {Integer} n
# @return {Integer}
def least_interval(tasks, n)
  freqs = Hash.new(0)
  tasks.each { |a| freqs[a] += 1 }
  max_f = freqs.values.max
  max_f_key_num = (freqs.select { |k, v| v == max_f }).length

  [tasks.length, (max_f - 1) * (n + 1) + max_f_key_num].max
end
"
0622,design-circular-queue,"# frozen_string_literal: true

# 622. Design Circular Queue
# https://leetcode.com/problems/design-circular-queue

class MyCircularQueue
  #     :type k: Integer
  def initialize(k)
    @queue = [-1] * k
    @size = k
    @len = 0
    @head = 0
  end

  #     :type value: Integer
  #     :rtype: Boolean
  def en_queue(value)
    if @len < @size
      @queue[(@head + @len) % @size] = value
      @len += 1

      return true
    end

    false
  end

  #     :rtype: Boolean
  def de_queue
    return false if is_empty

    @queue[@head] = -1
    @head = (@head + 1) % @size
    @len -= 1

    true
  end

  #     :rtype: Integer
  def front
    is_empty ? -1 : @queue[@head]
  end

  #     :rtype: Integer
  def rear
    is_empty ? -1 : @queue[(@head + @len - 1) % @size]
  end

  #     :rtype: Boolean
  def is_empty
    @len.zero?
  end

  #     :rtype: Boolean
  def is_full
    @len == @size
  end
end

# Your MyCircularQueue object will be instantiated and called as such:
# obj = MyCircularQueue.new(k)
# param_1 = obj.en_queue(value)
# param_2 = obj.de_queue()
# param_3 = obj.front()
# param_4 = obj.rear()
# param_5 = obj.is_empty()
# param_6 = obj.is_full()

# **************** #
#       TEST       #
# **************** #

# TODO: Write tests
"
0637,average-of-levels-in-binary-tree,"# frozen_string_literal: true

# 637. Average of Levels in Binary Tree
# https://leetcode.com/problems/average-of-levels-in-binary-tree
# Easy

=begin
Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. Answers within 10-5 of the actual answer will be accepted.

Example 1:
Input: root = [3,9,20,null,null,15,7]
Output: [3.00000,14.50000,11.00000]
Explanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.
Hence return [3, 14.5, 11].

Example 2:
Input: root = [3,9,20,15,7]
Output: [3.00000,14.50000,11.00000]

Constraints:
* The number of nodes in the tree is in the range [1, 104].
* -231 <= Node.val <= 231 - 1
=end

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root
# @return {Float[]}
def average_of_levels(root, sums = [], level = 0)
  return if !root
  sums[level] ||= [0, 0]
  sums[level][0] += root.val
  sums[level][1] += 1
  average_of_levels(root.left, sums, level + 1)
  average_of_levels(root.right, sums, level + 1)
  sums.map { |sum, n| sum.fdiv(n) } if level == 0
end
"
0643,maximum-average-subarray-i,"# frozen_string_literal: true

# 643. Maximum Average Subarray I
# https://leetcode.com/problems/maximum-average-subarray-i
# Easy

=begin
You are given an integer array nums consisting of n elements, and an integer k.

Find a contiguous subarray whose length is equal to k that has the maximum average value and return this value. Any answer with a calculation error less than 10-5 will be accepted.

Example 1:
Input: nums = [1,12,-5,-6,50,3], k = 4
Output: 12.75000
Explanation: Maximum average is (12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75

Example 2:
Input: nums = [5], k = 1
Output: 5.00000

Constraints:
n == nums.length
1 <= k <= n <= 105
-104 <= nums[i] <= 104
=end

# @param {Integer[]} nums
# @param {Integer} k
# @return {Float}
def find_max_average(nums, k)
  max_sum = 0
  i = 0
  while i < k do
    max_sum += nums[i]
    i += 1
  end

  new_sum = max_sum

  while i < nums.length do
    new_sum += nums[i] - nums[i - k]
    max_sum = new_sum if new_sum > max_sum
    i += 1
  end
  max_sum / k.to_f
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_max_vowels < Test::Unit::TestCase
  def test_
    assert_equal 12.75, find_max_average([1, 12, -5, -6, 50, 3], 4)
    assert_equal 5.0, find_max_average([5], 1)
  end
end
"
0646,maximum-length-of-pair-chain,"# frozen_string_literal: true

# 646. Maximum Length of Pair Chain
# Medium
# https://leetcode.com/problems/maximum-length-of-pair-chain

=begin
You are given an array of n pairs pairs where pairs[i] = [lefti, righti] and lefti < righti.
A pair p2 = [c, d] follows a pair p1 = [a, b] if b < c. A chain of pairs can be formed in this fashion.
Return the length longest chain which can be formed.
You do not need to use up all the given intervals. You can select pairs in any order.

Example 1:
Input: pairs = [[1,2],[2,3],[3,4]]
Output: 2
Explanation: The longest chain is [1,2] -> [3,4].

Example 2:
Input: pairs = [[1,2],[7,8],[4,5]]
Output: 3
Explanation: The longest chain is [1,2] -> [4,5] -> [7,8].

Constraints:
* n == pairs.length
* 1 <= n <= 1000
* -1000 <= lefti < righti <= 1000
=end

# @param {Integer[][]} pairs
# @return {Integer}
def find_longest_chain(pairs)
  return 0 if pairs.empty?
  pairs.sort_by! { |p| p[1] }
  c = 0
  a = Float::INFINITY * -1
  pairs.each do |pair|
    if a < pair[0]
      a = pair[1]
      c += 1
    end
  end
  c
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_find_longest_chain < Test::Unit::TestCase
  def test_
    assert_equal 2, find_longest_chain([[1, 2], [2, 3], [3, 4]])
    assert_equal 3, find_longest_chain([[1, 2], [7, 8], [4, 5]])
  end
end
"
0649,dota2-senate,"# frozen_string_literal: true

# 649. Dota2 Senate
# https://leetcode.com/problems/dota2-senate
# Medium

=begin
In the world of Dota2, there are two parties: the Radiant and the Dire.

The Dota2 senate consists of senators coming from two parties. Now the Senate wants to decide on a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise one of the two rights:

Ban one senator's right: A senator can make another senator lose all his rights in this and all the following rounds.
Announce the victory: If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and decide on the change in the game.
Given a string senate representing each senator's party belonging. The character 'R' and 'D' represent the Radiant party and the Dire party. Then if there are n senators, the size of the given string will be n.

The round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure.

Suppose every senator is smart enough and will play the best strategy for his own party. Predict which party will finally announce the victory and change the Dota2 game. The output should be ""Radiant"" or ""Dire"".

Example 1:
Input: senate = ""RD""
Output: ""Radiant""
Explanation:
The first senator comes from Radiant and he can just ban the next senator's right in round 1.
And the second senator can't exercise any rights anymore since his right has been banned.
And in round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote.

Example 2:
Input: senate = ""RDD""
Output: ""Dire""
Explanation:
The first senator comes from Radiant and he can just ban the next senator's right in round 1.
And the second senator can't exercise any rights anymore since his right has been banned.
And the third senator comes from Dire and he can ban the first senator's right in round 1.
And in round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote.

Constraints:
* n == senate.length
* 1 <= n <= 104
* senate[i] is either 'R' or 'D'.
=end

# @param {String} senate
# @return {String}
def predict_party_victory(senate)
  qr, qd = senate.chars.each_with_index.partition { |q| q.first == ""R"" }.collect { |a| a.collect(&:last) }
  until qr.empty? || qd.empty? do
    ri, di = [qr, qd].collect(&:shift)
    if ri < di then
      qr << ri + senate.size
    else
      qd << di + senate.size
    end
  end
  qr.size > qd.size ? ""Radiant"" : ""Dire""
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_predict_party_victory < Test::Unit::TestCase
  def test_
    assert_equal ""Radiant"", predict_party_victory(""RD"")
    assert_equal ""Dire"", predict_party_victory(""RDD"")
  end
end
"
0652,find-duplicate-subtrees,"# frozen_string_literal: true

# 652. Find Duplicate Subtrees
# https://leetcode.com/problems/find-duplicate-subtrees

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root
# @return {TreeNode[]}
def find_duplicate_subtrees(root)
  @path = {}
  @duplicates = []

  find_duplicates(root)

  @duplicates
end

def find_duplicates(root)
  return """" if root.nil?

  path = [root.val, find_duplicates(root.left), find_duplicates(root.right)].join("","")

  if @path[path]
    @duplicates << root if @path[path] == 1
    @path[path] += 1
  else
    @path[path] = 1
  end

  path
end
"
0661,image-smoother,"# frozen_string_literal: true

# 661. Image Smoother
# Easy
# https://leetcode.com/problems/image-smoother

=begin
An image smoother is a filter of the size 3 x 3 that can be applied to each cell of an image by rounding down the average of the cell and the eight surrounding cells (i.e., the average of the nine cells in the blue smoother). If one or more of the surrounding cells of a cell is not present, we do not consider it in the average (i.e., the average of the four cells in the red smoother).
Given an m x n integer matrix img representing the grayscale of an image, return the image after applying the smoother on each cell of it.

Example 1:
Input: img = [[1,1,1],[1,0,1],[1,1,1]]
Output: [[0,0,0],[0,0,0],[0,0,0]]
Explanation:
For the points (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0
For the points (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0
For the point (1,1): floor(8/9) = floor(0.88888889) = 0

Example 2:
Input: img = [[100,200,100],[200,50,200],[100,200,100]]
Output: [[137,141,137],[141,138,141],[137,141,137]]
Explanation:
For the points (0,0), (0,2), (2,0), (2,2): floor((100+200+200+50)/4) = floor(137.5) = 137
For the points (0,1), (1,0), (1,2), (2,1): floor((200+200+50+200+100+100)/6) = floor(141.666667) = 141
For the point (1,1): floor((50+200+200+200+200+100+100+100+100)/9) = floor(138.888889) = 138

Constraints:
m == img.length
n == img[i].length
1 <= m, n <= 200
0 <= img[i][j] <= 255
=end

# @param {Integer[][]} img
# @return {Integer[][]}
def image_smoother(img)
  m = img.size - 1
  n = img[0].size - 1
  result = []

  i = 0
  while i <= m
    result << []
    min_x = [0, i - 1].max
    max_x = [i + 1, m].min
    dx = max_x - min_x + 1
    j = 0
    while j <= n
      min_y = [0, j - 1].max
      max_y = [j + 1, n].min
      dy = max_y - min_y + 1
      result[i] << img[min_x..max_x].sum { |r| r[min_y..max_y].sum } / (dx * dy)
      j += 1
    end

    i += 1
  end

  result
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_image_smoother < Test::Unit::TestCase
  def test_
    assert_equal [[0, 0, 0], [0, 0, 0], [0, 0, 0]], image_smoother([[1, 1, 1], [1, 0, 1], [1, 1, 1]])
    assert_equal [[137, 141, 137], [141, 138, 141], [137, 141, 137]], image_smoother([[100, 200, 100], [200, 50, 200], [100, 200, 100]])
  end
end
"
0662,maximum-width-of-binary-tree,"# frozen_string_literal: true

# 662. Maximum Width of Binary Tree
# https://leetcode.com/problems/maximum-width-of-binary-tree/
# Medium

=begin
Given the root of a binary tree, return the maximum width of the given tree.

The maximum width of a tree is the maximum width among all levels.

The width of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), where the null nodes between the end-nodes that would be present in a complete binary tree extending down to that level are also counted into the length calculation.

It is guaranteed that the answer will in the range of a 32-bit signed integer.

Example 1:
Input: root = [1,3,2,5,3,null,9]
Output: 4
Explanation: The maximum width exists in the third level with length 4 (5,3,null,9).

Example 2:
Input: root = [1,3,2,5,null,null,9,6,null,7]
Output: 7
Explanation: The maximum width exists in the fourth level with length 7 (6,null,null,null,null,null,7).

Example 3:
Input: root = [1,3,2,5]
Output: 2
Explanation: The maximum width exists in the second level with length 2 (3,2).

Constraints:
* The number of nodes in the tree is in the range [1, 3000].
* -100 <= Node.val <= 100
=end

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root
# @return {Integer}
def width_of_binary_tree(root)
  max = 0
  queue = [{ node: root, pos: 0 }]
  while queue.length > 0 do
    next_queue = []
    length = queue.length
    min_pos = +1.0 / 0.0
    max_pos = 0
    while queue.length > 0 do
      current = queue.pop
      if current[:node].left
        next_queue << { node: current[:node].left, pos: 2 * current[:pos] + 1 }
      end
      if current[:node].right
        next_queue << { node: current[:node].right, pos: 2 * current[:pos] + 2 }
      end
      min_pos = [min_pos, current[:pos]].min
      max_pos = [max_pos, current[:pos]].max
    end
    queue = next_queue
    level_length = length == 1 ? 1 : max_pos - min_pos + 1
    max = [max, level_length].max
  end
  max
end
"
0664,strange-printer,"# frozen_string_literal: true

# 664. Strange Printer
# Hard
# https://leetcode.com/problems/strange-printer

=begin
There is a strange printer with the following two special properties:
* The printer can only print a sequence of the same character each time.
* At each turn, the printer can print new characters starting from and ending at any place and will cover the original existing characters.
Given a string s, return the minimum number of turns the printer needed to print it.

Example 1:
Input: s = ""aaabbb""
Output: 2
Explanation: Print ""aaa"" first and then print ""bbb"".

Example 2:
Input: s = ""aba""
Output: 2
Explanation: Print ""aaa"" first and then print ""b"" from the second place of the string, which will cover the existing character 'a'.

Constraints:
* 1 <= s.length <= 100
* s consists of lowercase English letters.
=end

# @param {String} s
# @return {Integer}
def strange_printer(s)
  n = s.size
  dp = Array.new(n) { Array.new(n, 0) }

  (n - 1).downto(0) do |i|
    dp[i][i] = 1
    (i + 1...n).each do |j|
      dp[i][j] = dp[i][j - 1] + 1
      (i...j).each do |k|
        if s[k] == s[j]
          dp[i][j] = [dp[i][j], dp[i][k] + (k + 1 <= j - 1 ? dp[k + 1][j - 1] : 0)].min
        end
      end
    end
  end

  dp[0][n - 1]
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_strange_printer < Test::Unit::TestCase
  def test_
    assert_equal 2, strange_printer(""aaabbb"")
    assert_equal 2, strange_printer(""aba"")
  end
end
"
0673,number-of-longest-increasing-subsequence,"# frozen_string_literal: true

# 673. Number of Longest Increasing Subsequence
# Medium
# https://leetcode.com/problems/number-of-longest-increasing-subsequence

=begin
Given an integer array nums, return the number of longest increasing subsequences.
Notice that the sequence has to be strictly increasing.

Example 1:
Input: nums = [1,3,5,4,7]
Output: 2
Explanation: The two longest increasing subsequences are [1, 3, 4, 7] and [1, 3, 5, 7].

Example 2:
Input: nums = [2,2,2,2,2]
Output: 5
Explanation: The length of the longest increasing subsequence is 1, and there are 5 increasing subsequences of length 1, so output 5.

Constraints:
* 1 <= nums.length <= 2000
* -106 <= nums[i] <= 106
=end

# @param {Integer[]} nums
# @return {Integer}
def find_number_of_lis(nums)
  n = nums.length
  return 0 if n == 0
  dp = Array.new(n, 1)
  count = Array.new(n, 1)

  (0...n).each do |i|
    (0...i).each do |j|
      if nums[i] > nums[j]
        if dp[i] == dp[j] + 1
          count[i] += count[j]
        elsif dp[i] < dp[j] + 1
          dp[i] = dp[j] + 1
          count[i] = count[j]
        end
      end
    end
  end

  max_length = dp.max
  count.select.with_index { |_, i| dp[i] == max_length }.sum
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_find_number_of_lis < Test::Unit::TestCase
  def test_
    assert_equal 2, find_number_of_lis([1, 3, 5, 4, 7])
    assert_equal 5, find_number_of_lis([2, 2, 2, 2, 2])
  end
end
"
0688,knight-probability-in-chessboard,"# frozen_string_literal: true

# 688. Knight Probability in Chessboard
# Medium
# https://leetcode.com/problems/knight-probability-in-chessboard

=begin
On an n x n chessboard, a knight starts at the cell (row, column) and attempts to make exactly k moves. The rows and columns are 0-indexed, so the top-left cell is (0, 0), and the bottom-right cell is (n - 1, n - 1).
A chess knight has eight possible moves it can make, as illustrated below. Each move is two cells in a cardinal direction, then one cell in an orthogonal direction.
Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.
The knight continues moving until it has made exactly k moves or has moved off the chessboard.
Return the probability that the knight remains on the board after it has stopped moving.

Example 1:
Input: n = 3, k = 2, row = 0, column = 0
Output: 0.06250
Explanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board.
From each of those positions, there are also two moves that will keep the knight on the board.
The total probability the knight stays on the board is 0.0625.

Example 2:
Input: n = 1, k = 0, row = 0, column = 0
Output: 1.00000

Constraints:
1 <= n <= 25
0 <= k <= 100
0 <= row, column <= n - 1
=end

# @param {Integer} n
# @param {Integer} k
# @param {Integer} row
# @param {Integer} column
# @return {Float}
def knight_probability(n, k, row, column)
  moves = [[-2, -1], [2, -1], [-2, 1], [2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2]]
  dp = Array.new(n) { Array.new(n) { Array.new(k + 1, 0) } }
  dp[row][column][0] = 1

  (1..k).each do |k_index|
    (0..n - 1).each do |i|
      (0..n - 1).each do |j|
        moves.each do |move|
          new_x, new_y = i + move[0], j + move[1]
          dp[i][j][k_index] += dp[new_x][new_y][k_index - 1] if new_x.between?(0, n - 1) && new_y.between?(0, n - 1)
        end
      end
    end
  end

  total = 0.0
  (0..n - 1).each do |i|
    (0..n - 1).each do |j|
      total += dp[i][j][k]
    end
  end

  total / (8**k)
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_knight_probability < Test::Unit::TestCase
  def test_
    assert_equal 0.06250, knight_probability(3, 2, 0, 0)
    assert_equal 1.00000, knight_probability(1, 0, 0, 0)
  end
end
"
0692,top-k-frequent-words,"# frozen_string_literal: true

# 692. Top K Frequent Words
# https://leetcode.com/problems/top-k-frequent-words

=begin

Given an array of strings words and an integer k, return the k most frequent strings.

Return the answer sorted by the frequency from highest to lowest. Sort the words with the same frequency by their lexicographical order.

### Example 1:
Input: words = [""i"",""love"",""leetcode"",""i"",""love"",""coding""], k = 2
Output: [""i"",""love""]
Explanation: ""i"" and ""love"" are the two most frequent words.
Note that ""i"" comes before ""love"" due to a lower alphabetical order.

### Example 2:
Input: words = [""the"",""day"",""is"",""sunny"",""the"",""the"",""the"",""sunny"",""is"",""is""], k = 4
Output: [""the"",""is"",""sunny"",""day""]
Explanation: ""the"", ""is"", ""sunny"" and ""day"" are the four most frequent words, with the number of occurrence being 4, 3, 2 and 1 respectively.

### Constraints:
* 1 <= words.length <= 500
* 1 <= words[i].length <= 10
* words[i] consists of lowercase English letters.
* k is in the range [1, The number of unique words[i]]

=end

# @param {String[]} words
# @param {Integer} k
# @return {String[]}
def top_k_frequent(words, k)
  words.tally.to_a.sort { |a, b| a[1] != b[1] ? a[1] <=> b[1] : b[0] <=> a[0] }[-k..-1].map(&:first).reverse
end

require ""test/unit""
class Test_top_k_frequent < Test::Unit::TestCase
  def test_
    assert_equal [""i"", ""love""], top_k_frequent([""i"", ""love"", ""leetcode"", ""i"", ""love"", ""coding""], 2)
    assert_equal [""the"", ""is"", ""sunny"", ""day""], top_k_frequent([""the"", ""day"", ""is"", ""sunny"", ""the"", ""the"", ""the"", ""sunny"", ""is"", ""is""], 4)
  end
end
"
0700,search-in-a-binary-search-tree,"# 700. Search in a Binary Search Tree
# https://leetcode.com/problems/search-in-a-binary-search-tree
# Easy

=begin
You are given the root of a binary search tree (BST) and an integer val.

Find the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.

Example 1:
Input: root = [4,2,7,1,3], val = 2
Output: [2,1,3]

Example 2:
Input: root = [4,2,7,1,3], val = 5
Output: []

Constraints:
The number of nodes in the tree is in the range [1, 5000].
1 <= Node.val <= 107
root is a binary search tree.
1 <= val <= 107
=end

# frozen_string_literal: true

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root
# @param {Integer} val
# @return {TreeNode}
def search_bst(root, val)
  return nil if root.nil?

  return root if root.val == val
  return search_bst(root.right, val) if root.val < val

  search_bst(root.left, val)
end
"
0703,kth-largest-element-in-a-stream,"# frozen_string_literal: true

# 703. Kth Largest Element in a Stream
# https://leetcode.com/problems/kth-largest-element-in-a-stream
# Easy

=begin
Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.

Implement KthLargest class:

KthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums.
int add(int val) Appends the integer val to the stream and returns the element representing the kth largest element in the stream.

Example 1:
Input
[""KthLargest"", ""add"", ""add"", ""add"", ""add"", ""add""]
[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]
Output
[null, 4, 5, 5, 8, 8]

Explanation
KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);
kthLargest.add(3);   // return 4
kthLargest.add(5);   // return 5
kthLargest.add(10);  // return 5
kthLargest.add(9);   // return 8
kthLargest.add(4);   // return 8

Constraints:
1 <= k <= 104
0 <= nums.length <= 104
-104 <= nums[i] <= 104
-104 <= val <= 104
At most 104 calls will be made to add.
It is guaranteed that there will be at least k elements in the array when you search for the kth element.
=end

class KthLargest
=begin
    :type k: Integer
    :type nums: Integer[]
=end
  def initialize(k, nums)
    @max_size = k
    @data = nums.sort.reverse[0...k]
  end


=begin
    :type val: Integer
    :rtype: Integer
=end
  def add(val)
    if (i = @data.bsearch_index { |x| x < val })
      @data.insert(i, val)
    else
      @data.push(val)
    end
    @data.pop if @data.length > @max_size
    # @data.sort!{|a, b| b<=> a}
    @data.last
  end
end

# Your KthLargest object will be instantiated and called as such:
# obj = KthLargest.new(k, nums)
# param_1 = obj.add(val)
"
0704,binary-search,"# frozen_string_literal: true

# 704. Binary Search
# https://leetcode.com/problems/binary-search

=begin

Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.

You must write an algorithm with O(log n) runtime complexity.

### Example 1:
Input: nums = [-1,0,3,5,9,12], target = 9
Output: 4
Explanation: 9 exists in nums and its index is 4

### Example 2:
Input: nums = [-1,0,3,5,9,12], target = 2
Output: -1
Explanation: 2 does not exist in nums so return -1

### Constraints:
* 1 <= nums.length <= 104
* -104 < nums[i], target < 104
* All the integers in nums are unique.
* nums is sorted in ascending order.

=end

# Runtime: 100 ms
# Memory: 213.7 MB
# @param {Integer[]} nums
# @param {Integer} target
# @return {Integer}
def search(nums, target)
  nums.bsearch_index { |i| target - i } || -1
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_search < Test::Unit::TestCase
  def test_
    assert_equal 4, search([-1, 0, 3, 5, 9, 12], 9)
    assert_equal(-1, search([-1, 0, 3, 5, 9, 12], 2))
  end
end
"
0705,design-hashset,"# frozen_string_literal: true

# 705. Design HashSet
# https://leetcode.com/problems/design-hashset
# Easy

=begin
Design a HashSet without using any built-in hash table libraries.

Implement MyHashSet class:

* void add(key) Inserts the value key into the HashSet.
* bool contains(key) Returns whether the value key exists in the HashSet or not.
* void remove(key) Removes the value key in the HashSet. If key does not exist in the HashSet, do nothing.

Example 1:
Input
[""MyHashSet"", ""add"", ""add"", ""contains"", ""contains"", ""add"", ""contains"", ""remove"", ""contains""]
[[], [1], [2], [1], [3], [2], [2], [2], [2]]
Output
[null, null, null, true, false, null, true, null, false]
Explanation
MyHashSet myHashSet = new MyHashSet();
myHashSet.add(1);      // set = [1]
myHashSet.add(2);      // set = [1, 2]
myHashSet.contains(1); // return True
myHashSet.contains(3); // return False, (not found)
myHashSet.add(2);      // set = [1, 2]
myHashSet.contains(2); // return True
myHashSet.remove(2);   // set = [1]
myHashSet.contains(2); // return False, (already removed)

Constraints:
* 0 <= key <= 106
* At most 104 calls will be made to add, remove, and contains.
=end

class MyHashSet
  def initialize
    @array = Array.new(1000000)
  end


=begin
  :type key: Integer
  :rtype: Void
=end
  def add(key)
    @array[key] = true
  end


=begin
  :type key: Integer
  :rtype: Void
=end
  def remove(key)
    @array[key] = nil
  end


=begin
  :type key: Integer
  :rtype: Boolean
=end
  def contains(key)
    !!@array[key]
  end
end

# Your MyHashSet object will be instantiated and called as such:
# obj = MyHashSet.new()
# obj.add(key)
# obj.remove(key)
# param_3 = obj.contains(key)
"
0706,design-hashmap,"# frozen_string_literal: true

# 706. Design HashMap
# Easy
# https://leetcode.com/problems/design-hashmap

=begin
Design a HashMap without using any built-in hash table libraries.
Implement the MyHashMap class:
* MyHashMap() initializes the object with an empty map.
* void put(int key, int value) inserts a (key, value) pair into the HashMap. If the key already exists in the map, update the corresponding value.
* int get(int key) returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key.
* void remove(key) removes the key and its corresponding value if the map contains the mapping for the key.

Example 1:
Input
[""MyHashMap"", ""put"", ""put"", ""get"", ""get"", ""put"", ""get"", ""remove"", ""get""]
[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]
Output
[null, null, null, 1, -1, null, 1, null, -1]
Explanation
MyHashMap myHashMap = new MyHashMap();
myHashMap.put(1, 1); // The map is now [[1,1]]
myHashMap.put(2, 2); // The map is now [[1,1], [2,2]]
myHashMap.get(1);    // return 1, The map is now [[1,1], [2,2]]
myHashMap.get(3);    // return -1 (i.e., not found), The map is now [[1,1], [2,2]]
myHashMap.put(2, 1); // The map is now [[1,1], [2,1]] (i.e., update the existing value)
myHashMap.get(2);    // return 1, The map is now [[1,1], [2,1]]
myHashMap.remove(2); // remove the mapping for 2, The map is now [[1,1]]
myHashMap.get(2);    // return -1 (i.e., not found), The map is now [[1,1]]

Constraints:
0 <= key, value <= 106
At most 104 calls will be made to put, get, and remove.
=end

class MyHashMap
  def initialize
  end

  def put(key, value)
    instance_variable_set(trans_key(key), value)
  end

  def get(key)
    instance_variable_get(trans_key(key)) || -1
  end

  def remove(key)
    instance_variable_set(trans_key(key), nil)
  end

  private
    def trans_key(key)
      ""@_#{key}""
    end
end

# Your MyHashMap object will be instantiated and called as such:
# obj = MyHashMap.new()
# obj.put(key, value)
# param_2 = obj.get(key)
# obj.remove(key)
"
0712,minimum-ascii-delete-sum-for-two-strings,"# frozen_string_literal: true

# 712. Minimum ASCII Delete Sum for Two Strings
# Medium
# https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings

=begin
Given two strings s1 and s2, return the lowest ASCII sum of deleted characters to make two strings equal.

Example 1:
Input: s1 = ""sea"", s2 = ""eat""
Output: 231
Explanation: Deleting ""s"" from ""sea"" adds the ASCII value of ""s"" (115) to the sum.
Deleting ""t"" from ""eat"" adds 116 to the sum.
At the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.

Example 2:
Input: s1 = ""delete"", s2 = ""leet""
Output: 403
Explanation: Deleting ""dee"" from ""delete"" to turn the string into ""let"",
adds 100[d] + 101[e] + 101[e] to the sum.
Deleting ""e"" from ""leet"" adds 101[e] to the sum.
At the end, both strings are equal to ""let"", and the answer is 100+101+101+101 = 403.
If instead we turned both strings into ""lee"" or ""eet"", we would get answers of 433 or 417, which are higher.

Constraints:
* 1 <= s1.length, s2.length <= 1000
* s1 and s2 consist of lowercase English letters.
=end

# @param {String} s1
# @param {String} s2
# @return {Integer}
def minimum_delete_sum(s1, s2)
  dp = Array.new(s1.size + 1) { Array.new(s2.size + 1, 0) }

  (1..s1.length).each do |i|
    dp[i][0] = dp[i - 1][0] + s1[i - 1].ord
  end

  (1..s2.length).each do |j|
    dp[0][j] = dp[0][j - 1] + s2[j - 1].ord
  end

  (1..s1.length).each do |i|
    (1..s2.length).each do |j|
      if s1[i - 1] == s2[j - 1]
        dp[i][j] = dp[i - 1][j - 1]
      else
        dp[i][j] = [dp[i - 1][j] + s1[i - 1].ord, dp[i][j - 1] + s2[j - 1].ord].min
      end
    end
  end

  dp[s1.length][s2.length]
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_minimum_delete_sum < Test::Unit::TestCase
  def test_
    assert_equal 231, minimum_delete_sum(""sea"", ""eat"")
    assert_equal 403, minimum_delete_sum(""delete"", ""leet"")
  end
end
"
0714,best-time-to-buy-and-sell-stock-with-transaction-fee,"# frozen_string_literal: true

# 714. Best Time to Buy and Sell Stock with Transaction
# https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee
# Medium

=begin
You are given an array prices where prices[i] is the price of a given stock on the ith day, and an integer fee representing a transaction fee.

Find the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.

Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).

Example 1:
Input: prices = [1,3,2,8,4,9], fee = 2
Output: 8
Explanation: The maximum profit can be achieved by:
- Buying at prices[0] = 1
- Selling at prices[3] = 8
- Buying at prices[4] = 4
- Selling at prices[5] = 9
The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.

Example 2:
Input: prices = [1,3,7,5,10,3], fee = 3
Output: 6

Constraints:
1 <= prices.length <= 5 * 104
1 <= prices[i] < 5 * 104
0 <= fee < 5 * 104
=end

# @param {Integer[]} prices
# @param {Integer} fee
# @return {Integer}
def max_profit(prices, fee)
  dp_hold, dp_not_hold = -Float::INFINITY, 0

  prices.each do |price|
    dp_not_hold = [dp_not_hold, dp_hold + price].max
    dp_hold = [dp_hold, dp_not_hold - price - fee].max
  end

  dp_not_hold
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_max_profit < Test::Unit::TestCase
  def test_
    assert_equal 8, max_profit([1, 3, 2, 8, 4, 9], 2)
    assert_equal 6, max_profit([1, 3, 7, 5, 10, 3], 3)
  end
end
"
0724,find-pivot-index,"# frozen_string_literal: true

# 724. Find Pivot Index
# https://leetcode.com/problems/find-pivot-index
# Easy

=begin
Given an array of integers nums, calculate the pivot index of this array.

The pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index's right.

If the index is on the left edge of the array, then the left sum is 0 because there are no elements to the left. This also applies to the right edge of the array.

Return the leftmost pivot index. If no such index exists, return -1

### Example 1:
Input: nums = [1,7,3,6,5,6]
Output: 3
Explanation:
The pivot index is 3.
Left sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11
Right sum = nums[4] + nums[5] = 5 + 6 = 11

### Example 2:
Input: nums = [1,2,3]
Output: -1
Explanation:
There is no index that satisfies the conditions in the problem statement.

### Example 3:
Input: nums = [2,1,-1]
Output: 0
Explanation:
The pivot index is 0.
Left sum = 0 (no elements to the left of index 0)
Right sum = nums[1] + nums[2] = 1 + -1 = 0

### Constraints:
* 1 <= nums.length <= 104
* -1000 <= nums[i] <= 1000
=end

# Runtime 109 ms
# Memory 212.6 MB
# @param {Integer[]} nums
# @return {Integer}
def pivot_index(nums)
  sum = nums.sum
  left_sum = 0

  nums.each_with_index do |num, index|
    return index if left_sum == sum - left_sum - num

    left_sum += num
  end

  -1
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_pivot_index < Test::Unit::TestCase
  def test_
    assert_equal 3, pivot_index([1, 7, 3, 6, 5, 6])
    assert_equal(-1, pivot_index([1, 2, 3]))
    assert_equal 0, pivot_index([2, 1, -1])
  end
end
"
0725,split-linked-list-in-parts,"# frozen_string_literal: true

# 725. Split Linked List in Parts
# Medium
# https://leetcode.com/problems/split-linked-list-in-parts

=begin
Given the head of a singly linked list and an integer k, split the linked list into k consecutive linked list parts.
The length of each part should be as equal as possible: no two parts should have a size differing by more than one. This may lead to some parts being null.
The parts should be in the order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal to parts occurring later.
Return an array of the k parts.

Example 1:
Input: head = [1,2,3], k = 5
Output: [[1],[2],[3],[],[]]
Explanation:
The first element output[0] has output[0].val = 1, output[0].next = null.
The last element output[4] is null, but its string representation as a ListNode is [].

Example 2:
Input: head = [1,2,3,4,5,6,7,8,9,10], k = 3
Output: [[1,2,3,4],[5,6,7],[8,9,10]]
Explanation:
The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.

Constraints:
The number of nodes in the list is in the range [0, 1000].
0 <= Node.val <= 1000
1 <= k <= 50
=end

# Definition for singly-linked list.
# class ListNode
#     attr_accessor :val, :next
#     def initialize(val = 0, _next = nil)
#         @val = val
#         @next = _next
#     end
# end
# @param {ListNode} head
# @param {Integer} k
# @return {ListNode[]}
def split_list_to_parts(head, k)
  base = Array.new(k, [])

  if head == nil
    return base
  end

  list_length = 0
  vals = []

  while head
    list_length += 1
    vals.push(head.val)
    head = head.next
  end

  fraction = list_length / k
  remainder = list_length % k

  base.map do |g|
    if fraction > 0
      g = vals.slice!(0, fraction)
      if remainder > 0
        g.push(vals.slice!(0))
        remainder -= 1
        next g
      end
      next g
    end
    if vals.any?
      g = [vals.slice!(0)]
    end
    next g
  end
end
"
0733,flood-fill,"# frozen_string_literal: true

# 733. Flood Fill
# https://leetcode.com/problems/flood-fill

=begin

An image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image.

You are also given three integers sr, sc, and color. You should perform a flood fill on the image starting from the pixel image[sr][sc].

To perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with color.

Return the modified image after performing the flood fill.

### Example 1:
Input: image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, color = 2
Output: [[2,2,2],[2,2,0],[2,0,1]]
Explanation: From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.
Note the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.

### Example 2:
Input: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, color = 0
Output: [[0,0,0],[0,0,0]]
Explanation: The starting pixel is already colored 0, so no changes are made to the image.

### Constraints:
* m == image.length
* n == image[i].length
* 1 <= m, n <= 50
* 0 <= image[i][j], color < 216
* 0 <= sr < m
* 0 <= sc < n

=end

# @param {Integer[][]} image
# @param {Integer} sr
# @param {Integer} sc
# @param {Integer} color
# @return {Integer[][]}
def flood_fill(image, sr, sc, color)
  return image if image[sr][sc] == color

  fill(image, sr, sc, image[sr][sc], color)

  image
end

def fill(image, sr, sc, original_color, new_color)
  m = image.length
  n = image[0].length

  if sr.negative? ||
     sr >= m ||
     sc.negative? ||
     sc >= n

    return
  end

  return if image[sr][sc] != original_color

  image[sr][sc] = new_color

  fill(image, sr - 1, sc, original_color, new_color)
  fill(image, sr + 1, sc, original_color, new_color)
  fill(image, sr, sc - 1, original_color, new_color)
  fill(image, sr, sc + 1, original_color, new_color)
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_flood_fill < Test::Unit::TestCase
  def test_
    assert_equal [[2, 2, 2], [2, 2, 0], [2, 0, 1]], flood_fill([[1, 1, 1], [1, 1, 0], [1, 0, 1]], 1, 1, 2)
    assert_equal [[0, 0, 0], [0, 0, 0]], flood_fill([[0, 0, 0], [0, 0, 0]], 0, 0, 0)
  end
end
"
0735,asteroid-collision,"# frozen_string_literal: true

# 735. Asteroid Collision
# https://leetcode.com/problems/asteroid-collision
# Medium

=begin
We are given an array asteroids of integers representing asteroids in a row.

For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.

Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.

Example 1:
Input: asteroids = [5,10,-5]
Output: [5,10]
Explanation: The 10 and -5 collide resulting in 10. The 5 and 10 never collide.

Example 2:
Input: asteroids = [8,-8]
Output: []
Explanation: The 8 and -8 collide exploding each other.

Example 3:
Input: asteroids = [10,2,-5]
Output: [10]
Explanation: The 2 and -5 collide resulting in -5. The 10 and -5 collide resulting in 10.

Constraints:
2 <= asteroids.length <= 104
-1000 <= asteroids[i] <= 1000
asteroids[i] != 0
=end

# @param {Integer[]} asteroids
# @return {Integer[]}
def asteroid_collision(asteroids)
  result = []

  asteroids.each do |asteroid|
    result << asteroid

    while result.count > 1 && result[-1] < 0 && result[-2] > 0
      last_asteroid = result.pop

      if last_asteroid.abs == result[-1]
        result.pop
      elsif last_asteroid.abs > result[-1]
        result[-1] = last_asteroid
      end
    end
  end

  result
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_asteroid_collision < Test::Unit::TestCase
  def test_
    assert_equal [5, 10], asteroid_collision([5, 10, -5])
    assert_equal [], asteroid_collision([8, -8])
    assert_equal [10], asteroid_collision([10, 2, -5])
  end
end
"
0739,daily-temperatures,"# frozen_string_literal: true

# 739. Daily Temperatures
# https://leetcode.com/problems/daily-temperatures
# Medium

=begin
Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.

Example 1:
Input: temperatures = [73,74,75,71,69,72,76,73]
Output: [1,1,4,2,1,1,0,0]

Example 2:
Input: temperatures = [30,40,50,60]
Output: [1,1,1,0]

Example 3:
Input: temperatures = [30,60,90]
Output: [1,1,0]

Constraints:
1 <= temperatures.length <= 105
30 <= temperatures[i] <= 100
=end

# @param {Integer[]} temperatures
# @return {Integer[]}
def daily_temperatures(temperatures)
  t = temperatures
  s = []
  si = []
  answer = Array.new(t.size, 0)
  t.each_with_index do |v, i|
    while (!s.empty?) && s.last < v
      s.pop()
      j = si.pop()
      answer[j] = i - j
    end
    s.push(v)
    si.push(i)
  end
  answer
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_daily_temperatures < Test::Unit::TestCase
  def test_
    assert_equal [1, 1, 4, 2, 1, 1, 0, 0], daily_temperatures([73, 74, 75, 71, 69, 72, 76, 73])
    assert_equal [1, 1, 1, 0], daily_temperatures([30, 40, 50, 60])
    assert_equal [1, 1, 0], daily_temperatures([30, 60, 90])
  end
end
"
0744,find-smallest-letter-greater-than-target,"# frozen_string_literal: true

# https://leetcode.com/problems/find-smallest-letter-greater-than-target
# 744. Find Smallest Letter Greater Than Target
# Easy

=begin
You are given an array of characters letters that is sorted in non-decreasing order, and a character target. There are at least two different characters in letters.

Return the smallest character in letters that is lexicographically greater than target. If such a character does not exist, return the first character in letters.

Example 1:
Input: letters = [""c"",""f"",""j""], target = ""a""
Output: ""c""
Explanation: The smallest character that is lexicographically greater than 'a' in letters is 'c'.

Example 2:
Input: letters = [""c"",""f"",""j""], target = ""c""
Output: ""f""
Explanation: The smallest character that is lexicographically greater than 'c' in letters is 'f'.

Example 3:
Input: letters = [""x"",""x"",""y"",""y""], target = ""z""
Output: ""x""
Explanation: There are no characters in letters that is lexicographically greater than 'z' so we return letters[0].

Constraints:
* 2 <= letters.length <= 104
* letters[i] is a lowercase English letter.
* letters is sorted in non-decreasing order.
* letters contains at least two different characters.
* target is a lowercase English letter.
=end

# @param {Character[]} letters
# @param {Character} target
# @return {Character}
def next_greatest_letter(letters, target)
  i = 0
  j = letters.size - 1
  res = letters[0]
  while i <= j
    mid = i + (j - i) / 2

    if letters[mid] == target
      res = letters[mid + 1] || letters[0]
      i = mid + 1
    elsif letters[mid] < target
      i = mid + 1
    else
      res = letters[mid]
      j = mid - 1
    end
  end
  res
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_next_greatest_letter < Test::Unit::TestCase
  def test_
    assert_equal ""c"", next_greatest_letter([""c"", ""f"", ""j""], ""a"")
    assert_equal ""f"", next_greatest_letter([""c"", ""f"", ""j""], ""c"")
    assert_equal ""x"", next_greatest_letter([""x"", ""x"", ""y"", ""y""], ""z"")
  end
end
"
0746,min-cost-climbing-stairs,"# frozen_string_literal: true

# 746. Min Cost Climbing Stairs
# https://leetcode.com/problems/min-cost-climbing-stairs
# Easy

=begin

You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps.

You can either start from the step with index 0, or the step with index 1.

Return the minimum cost to reach the top of the floor.

### Example 1:
Input: cost = [10,15,20]
Output: 15
Explanation: You will start at index 1.
- Pay 15 and climb two steps to reach the top.
The total cost is 15.

### Example 2:
Input: cost = [1,100,1,1,1,100,1,1,100,1]
Output: 6
Explanation: You will start at index 0.
- Pay 1 and climb two steps to reach index 2.
- Pay 1 and climb two steps to reach index 4.
- Pay 1 and climb two steps to reach index 6.
- Pay 1 and climb one step to reach index 7.
- Pay 1 and climb two steps to reach index 9.
- Pay 1 and climb one step to reach the top.
The total cost is 6.

### Constraints:
* 2 <= cost.length <= 1000
* 0 <= cost[i] <= 999

=end

# @param {Integer[]} cost
# @return {Integer}
def min_cost_climbing_stairs(cost)
  dp = [0] * cost.count
  dp[0] = cost[0]
  dp[1] = cost[1]

  (2...cost.count).each do |i|
    dp[i] = [dp[i - 2] + cost[i], dp[i - 1] + cost[i]].min
  end

  [dp[-2], dp[-1]].min
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_min_cost_climbing_stairs < Test::Unit::TestCase
  def test_
    assert_equal 15, min_cost_climbing_stairs([10, 15, 20])
    assert_equal 6, min_cost_climbing_stairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])
  end
end
"
0767,reorganize-string,"# frozen_string_literal: true

# 767. Reorganize String
# Medium
# https://leetcode.com/problems/reorganize-string

=begin
Given a string s, rearrange the characters of s so that any two adjacent characters are not the same.
Return any possible rearrangement of s or return """" if not possible.

Example 1:
Input: s = ""aab""
Output: ""aba""

Example 2:
Input: s = ""aaab""
Output: """"

Constraints:
* 1 <= s.length <= 500
* s consists of lowercase English letters.
=end

# @param {String} s
# @return {String}
def reorganize_string(s)
  count_hash = {}
  s.each_char do |c|
    count_hash[c] = count_hash.fetch(c, 0) + 1
  end

  sorted_chars = count_hash.sort_by { |k, v| -v }

  # If any character occurs more than (N + 1) / 2 times, the task is impossible.
  if sorted_chars[0][1] > (s.length + 1) / 2
    return """"
  end

  res = [""""] * s.length
  idx = 0

  sorted_chars.each do |char, count|
    count.times do
      if idx >= s.length
        idx = 1
      end
      res[idx] = char
      idx += 2
    end
  end

  res.join("""")
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_length_of_longest_substring < Test::Unit::TestCase
  def test_
    assert_equal ""aba"", reorganize_string(""aab"")
    assert_equal """", reorganize_string(""aaab"")
  end
end
"
0779,k-th-symbol-in-grammar,"# frozen_string_literal: true

# 779. K-th Symbol in Grammar
# Medium
# https://leetcode.com/problems/k-th-symbol-in-grammar

=begin
We build a table of n rows (1-indexed). We start by writing 0 in the 1st row. Now in every subsequent row, we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10.
* For example, for n = 3, the 1st row is 0, the 2nd row is 01, and the 3rd row is 0110.
Given two integer n and k, return the kth (1-indexed) symbol in the nth row of a table of n rows.

Example 1:
Input: n = 1, k = 1
Output: 0
Explanation: row 1: 0

Example 2:
Input: n = 2, k = 1
Output: 0
Explanation:
row 1: 0
row 2: 01

Example 3:
Input: n = 2, k = 2
Output: 1
Explanation:
row 1: 0
row 2: 01

Constraints:
1 <= n <= 30
1 <= k <= 2n - 1
=end

# @param {Integer} n
# @param {Integer} k
# @return {Integer}
def kth_grammar(n, k)
  r = 0
  while n > 1
    k.odd? ? k += 1 : r ^= 1
    k /= 2
    n -= 1
  end
  r
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_kth_grammar < Test::Unit::TestCase
  def test_
    assert_equal 0, kth_grammar(1, 1)
    assert_equal 0, kth_grammar(2, 1)
    assert_equal 1, kth_grammar(2, 2)
  end
end
"
0783,minimum-distance-between-bst-nodes,"# frozen_string_literal: true

# 783. Minimum Distance Between BST Nodes
# https://leetcode.com/problems/minimum-distance-between-bst-nodes
# Easy
# TODO: Write Tests

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root
# @return {Integer}
def min_diff_in_bst(root)
  @prev = nil
  @min = nil
  inorder_traversal(root)
  @min
end

def inorder_traversal(root)
  return if root.nil?
  inorder_traversal(root.left)
  if @prev
    val = root.val - @prev
    @min = @min ? [@min, val].min : val
  end
  @prev = root.val
  inorder_traversal(root.right)
end
"
0785,is-graph-bipartite,"# frozen_string_literal: true

# 785. Is Graph Bipartite?
# https://leetcode.com/problems/is-graph-bipartite
# Medium

=begin
There is an undirected graph with n nodes, where each node is numbered between 0 and n - 1. You are given a 2D array graph, where graph[u] is an array of nodes that node u is adjacent to. More formally, for each v in graph[u], there is an undirected edge between node u and node v. The graph has the following properties:

There are no self-edges (graph[u] does not contain u).
There are no parallel edges (graph[u] does not contain duplicate values).
If v is in graph[u], then u is in graph[v] (the graph is undirected).
The graph may not be connected, meaning there may be two nodes u and v such that there is no path between them.
A graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B.

Return true if and only if it is bipartite.

Example 1:
Input: graph = [[1,2,3],[0,2],[0,1,3],[0,2]]
Output: false
Explanation: There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other.

Example 2:
Input: graph = [[1,3],[0,2],[1,3],[0,2]]
Output: true
Explanation: We can partition the nodes into two sets: {0, 2} and {1, 3}.

Constraints:
graph.length == n
1 <= n <= 100
0 <= graph[u].length < n
0 <= graph[u][i] <= n - 1
graph[u] does not contain u.
All the values of graph[u] are unique.
If graph[u] contains v, then graph[v] contains u.
=end

# @param {Integer[][]} graph
# @return {Boolean}
def is_bipartite(graph)
  @graph = graph
  n = @graph.count
  @group = [-1] * n

  n.times do |i|
    if @group[i] == -1
      @group[i] = 0
      return false unless dfs(i)
    end
  end

  true
end

def dfs(i)
  @graph[i].each do |j|
    if @group[j] != -1
      return false if @group[j] == @group[i]
    else
      @group[j] = 1 - @group[i]
      return false unless dfs(j)
    end
  end

  true
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_is_bipartite < Test::Unit::TestCase
  def test_
    assert_equal false, is_bipartite([[1, 2, 3], [0, 2], [0, 1, 3], [0, 2]])
    assert_equal true, is_bipartite([[1, 3], [0, 2], [1, 3], [0, 2]])
  end
end
"
0790,domino-and-tromino-tiling,"# frozen_string_literal: true

# 790. Domino and Tromino Tiling
# https://leetcode.com/problems/domino-and-tromino-tiling
# Medium

=begin
You have two types of tiles: a 2 x 1 domino shape and a tromino shape. You may rotate these shapes.

Given an integer n, return the number of ways to tile an 2 x n board. Since the answer may be very large, return it modulo 109 + 7.

In a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.

Example 1:
Input: n = 3
Output: 5
Explanation: The five different ways are show above.

Example 2:
Input: n = 1
Output: 1

Constraints:
1 <= n <= 1000
=end

# @param {Integer} n
# @return {Integer}
MOD = 10**9 + 7
def num_tilings(n)
  dp = Array.new(3) { Array.new(2, 0) }
  dp[1] = [1, 1]
  dp[2] = [2, 2]
  (3..n).each do |i|
    dp[i % 3][0] = dp[(i - 1) % 3][0] + dp[(i - 2) % 3][0] + 2 * dp[(i - 2) % 3][1]
    dp[i % 3][1] = dp[(i - 1) % 3][0] + dp[(i - 1) % 3][1]
  end
  dp[n % 3][0] % MOD
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_num_tilings < Test::Unit::TestCase
  def test_
    assert_equal 5, num_tilings(3)
    assert_equal 1, num_tilings(1)
  end
end
"
0799,champagne-tower,"# frozen_string_literal: true

# 799. Champagne Tower
# Medium
# https://leetcode.com/problems/champagne-tower

=begin
We stack glasses in a pyramid, where the first row has 1 glass, the second row has 2 glasses, and so on until the 100th row.  Each glass holds one cup of champagne.
Then, some champagne is poured into the first glass at the top.  When the topmost glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it.  When those glasses become full, any excess champagne will fall equally to the left and right of those glasses, and so on.  (A glass at the bottom row has its excess champagne fall on the floor.)
For example, after one cup of champagne is poured, the top most glass is full.  After two cups of champagne are poured, the two glasses on the second row are half full.  After three cups of champagne are poured, those two cups become full - there are 3 full glasses total now.  After four cups of champagne are poured, the third row has the middle glass half full, and the two outside glasses are a quarter full, as pictured below.
Now after pouring some non-negative integer cups of champagne, return how full the jth glass in the ith row is (both i and j are 0-indexed.)

Example 1:
Input: poured = 1, query_row = 1, query_glass = 1
Output: 0.00000
Explanation: We poured 1 cup of champange to the top glass of the tower (which is indexed as (0, 0)). There will be no excess liquid so all the glasses under the top glass will remain empty.

Example 2:
Input: poured = 2, query_row = 1, query_glass = 1
Output: 0.50000
Explanation: We poured 2 cups of champange to the top glass of the tower (which is indexed as (0, 0)). There is one cup of excess liquid. The glass indexed as (1, 0) and the glass indexed as (1, 1) will share the excess liquid equally, and each will get half cup of champange.

Example 3:
Input: poured = 100000009, query_row = 33, query_glass = 17
Output: 1.00000

Constraints:
* 0 <= poured <= 109
* 0 <= query_glass <= query_row < 100
=end

# @param {Integer} poured
# @param {Integer} query_row
# @param {Integer} query_glass
# @return {Float}
def champagne_tower(poured, query_row, query_glass)
  dp = Array.new(101) { |i| Array.new(i + 1, 0) }
  dp[0][0] = poured
  (0..query_row).each do |r|
    (0..r).each do |c|
      q = (dp[r][c] - 1).fdiv(2)
      if q > 0
        dp[r + 1][c] += q
        dp[r + 1][c + 1] += q
      end
    end
  end
  [1, dp[query_row][query_glass]].min
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_champagne_tower < Test::Unit::TestCase
  def test_
    assert_equal 0.00000, champagne_tower(1, 1, 1)
    assert_equal 0.50000, champagne_tower(2, 1, 1)
    assert_equal 1.00000, champagne_tower(100000009, 33, 17)
  end
end
"
0802,find-eventual-safe-states,"# frozen_string_literal: true

# 802. Find Eventual Safe States
# Medium
# https://leetcode.com/problems/find-eventual-safe-states

=begin
There is a directed graph of n nodes with each node labeled from 0 to n - 1. The graph is represented by a 0-indexed 2D integer array graph where graph[i] is an integer array of nodes adjacent to node i, meaning there is an edge from node i to each node in graph[i].
A node is a terminal node if there are no outgoing edges. A node is a safe node if every possible path starting from that node leads to a terminal node (or another safe node).
Return an array containing all the safe nodes of the graph. The answer should be sorted in ascending order.

Example 1:
Input: graph = [[1,2],[2,3],[5],[0],[5],[],[]]
Output: [2,4,5,6]
Explanation: The given graph is shown above.
Nodes 5 and 6 are terminal nodes as there are no outgoing edges from either of them.
Every path starting at nodes 2, 4, 5, and 6 all lead to either node 5 or 6.

Example 2:
Input: graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]
Output: [4]
Explanation:
Only node 4 is a terminal node, and every path starting at node 4 leads to node 4.

Constraints:
* n == graph.length
* 1 <= n <= 104
* 0 <= graph[i].length <= n
* 0 <= graph[i][j] <= n - 1
* graph[i] is sorted in a strictly increasing order.
* The graph may contain self-loops.
* The number of edges in the graph will be in the range [1, 4 * 104].
=end

# @param {Integer[][]} graph
# @return {Integer[]}
def eventual_safe_nodes(graph)
  node_states = Array.new(graph.size, :unvisited)
  graph.each_index { |i| dfs(i, graph, node_states) }
  node_states.each_index.select { |i| node_states[i] == :safe }.sort
end

def dfs(node, graph, node_states)
  return false if node_states[node] == :unsafe
  return true if node_states[node] == :safe

  node_states[node] = :unsafe
  graph[node].each do |neighbour|
    return false unless dfs(neighbour, graph, node_states)
  end

  node_states[node] = :safe
  true
end
"
0815,bus-routes,"# frozen_string_literal: true

# 815. Bus Routes
# https://leetcode.com/problems/bus-routes/
# Hard
# TODO: Implement

=begin
You are given an array routes representing bus routes where routes[i] is a bus route that the ith bus repeats forever.

For example, if routes[0] = [1, 5, 7], this means that the 0th bus travels in the sequence 1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ... forever.
You will start at the bus stop source (You are not on any bus initially), and you want to go to the bus stop target. You can travel between bus stops by buses only.

Return the least number of buses you must take to travel from source to target. Return -1 if it is not possible.

Example 1:
Input: routes = [[1,2,7],[3,6,7]], source = 1, target = 6
Output: 2
Explanation: The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6.

Example 2:
Input: routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12
Output: -1

Constraints:
1 <= routes.length <= 500.
1 <= routes[i].length <= 105
All the values of routes[i] are unique.
sum(routes[i].length) <= 105
0 <= routes[i][j] < 106
0 <= source, target < 106

=end

# @param {Integer[][]} routes
# @param {Integer} source
# @param {Integer} target
# @return {Integer}
def num_buses_to_destination(routes, source, target)
  return 0 if source == target

  stop_to_bus = Hash.new { |h, k| h[k] = [] }
  routes.each_with_index do |route, i|
    route.each { |stop| stop_to_bus[stop] << i }
  end

  buses_taken = 0
  visited_stops = Set.new([source])
  visited_buses = Set.new
  queue = [source]

  while !queue.empty?
    buses_taken += 1
    next_queue = []

    queue.each do |stop|
      stop_to_bus[stop].each do |bus|
        next if visited_buses.include?(bus)
        visited_buses.add(bus)

        routes[bus].each do |next_stop|
          return buses_taken if next_stop == target
          next if visited_stops.include?(next_stop)

          visited_stops.add(next_stop)
          next_queue << next_stop
        end
      end
    end

    queue = next_queue
  end

  -1
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_num_buses_to_destination < Test::Unit::TestCase
  def test_
    assert_equal 2, num_buses_to_destination([[1, 2, 7], [3, 6, 7]], 1, 6)
    assert_equal(-1, num_buses_to_destination([[7, 12], [4, 5, 15], [6], [15, 19], [9, 12, 13]], 15, 12))
  end
end
"
0823,binary-trees-with-factors,"# frozen_string_literal: true

# 823. Binary Trees With Factors
# Medium
# https://leetcode.com/problems/binary-trees-with-factors

=begin
Given an array of unique integers, arr, where each integer arr[i] is strictly greater than 1.
We make a binary tree using these integers, and each number may be used for any number of times. Each non-leaf node's value should be equal to the product of the values of its children.
Return the number of binary trees we can make. The answer may be too large so return the answer modulo 10^9 + 7.

Example 1:
Input: arr = [2,4]
Output: 3
Explanation: We can make these trees: [2], [4], [4, 2, 2]

Example 2:
Input: arr = [2,4,5,10]
Output: 7
Explanation: We can make these trees: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2].

Constraints:
1 <= arr.length <= 1000
2 <= arr[i] <= 109
All the values of arr are unique.
=end

# @param {Integer[]} arr
# @return {Integer}
def num_factored_binary_trees(arr)
  mod = 10**9 + 7
  arr.sort!
  dp = {}

  (0...arr.length).each do |i|
    dp[arr[i]] = 1
    (0...i).each do |j|
      if arr[i] % arr[j] == 0
        factor = arr[i] / arr[j]
        if dp.key?(factor)
          dp[arr[i]] = (dp[arr[i]] + dp[arr[j]] * dp[factor]) % mod
        end
      end
    end
  end

  result = 0
  dp.values.each do |value|
    result = (result + value) % mod
  end

  result
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_num_factored_binary_trees < Test::Unit::TestCase
  def test_
    assert_equal 3, num_factored_binary_trees([2, 4])
    assert_equal 7, num_factored_binary_trees([2, 4, 5, 10])
  end
end
"
0837,new-21-game,"# frozen_string_literal: true

# 837. New 21 Game
# https://leetcode.com/problems/new-21-game
# Medium

=begin
Alice plays the following game, loosely based on the card game ""21"".

Alice starts with 0 points and draws numbers while she has less than k points. During each draw, she gains an integer number of points randomly from the range [1, maxPts], where maxPts is an integer. Each draw is independent and the outcomes have equal probabilities.

Alice stops drawing numbers when she gets k or more points.

Return the probability that Alice has n or fewer points.

Answers within 10**-5 of the actual answer are considered accepted.

Example 1:
Input: n = 10, k = 1, maxPts = 10
Output: 1.00000
Explanation: Alice gets a single card, then stops.

Example 2:
Input: n = 6, k = 1, maxPts = 10
Output: 0.60000
Explanation: Alice gets a single card, then stops.
In 6 out of 10 possibilities, she is at or below 6 points.

Example 3:
Input: n = 21, k = 17, maxPts = 10
Output: 0.73278

Constraints:
0 <= k <= n <= 104
1 <= maxPts <= 104
=end

# @param {Integer} n
# @param {Integer} k
# @param {Integer} max_pts
# @return {Float}
def new21_game(n, k, max_pts)
  return 1 if k - 1 + max_pts <= n

  result = Array.new(k + max_pts, 0.0)

  k.upto(n) do |i|
    result[i] = 1
  end

  sum = result[k...(k + max_pts)].sum

  (k - 1).downto(0) do |i|
    result[i] = sum / max_pts
    sum += result[i] - result[i + max_pts]
  end

  result[0].round(5)
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_new21_game < Test::Unit::TestCase
  def test_
    assert_equal 1.00000, new21_game(10, 1, 10)
    assert_equal 0.60000, new21_game(6, 1, 10)
    assert_equal 0.73278, new21_game(21, 17, 10)
  end
end
"
0839,similar-string-groups,"# frozen_string_literal: true

# 839. Similar String Groups
# https://leetcode.com/problems/similar-string-groups
# Hard

=begin
Two strings X and Y are similar if we can swap two letters (in different positions) of X, so that it equals Y. Also two strings X and Y are similar if they are equal.

For example, ""tars"" and ""rats"" are similar (swapping at positions 0 and 2), and ""rats"" and ""arts"" are similar, but ""star"" is not similar to ""tars"", ""rats"", or ""arts"".

Together, these form two connected groups by similarity: {""tars"", ""rats"", ""arts""} and {""star""}.  Notice that ""tars"" and ""arts"" are in the same group even though they are not similar.  Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group.

We are given a list strs of strings where every string in strs is an anagram of every other string in strs. How many groups are there?

Example 1:
Input: strs = [""tars"",""rats"",""arts"",""star""]
Output: 2

Example 2:
Input: strs = [""omv"",""ovm""]
Output: 1

Constraints:
1 <= strs.length <= 300
1 <= strs[i].length <= 300
strs[i] consists of lowercase letters only.
All words in strs have the same length and are anagrams of each other.
=end

# @param {String[]} strs
# @return {Integer}
def num_similar_groups(strs)
  strs.map! do |str|
    str.split("""").map(&:ord)
  end

  @connected = strs.each_with_object({}) { |str, connected| connected[str] = [] }

  max_index = strs.size.pred
  strs.each_with_index do |str1, index1|
    index1.next.upto max_index do |index2|
      compare(str1, strs[index2])
    end
  end

  count_groups
end

def compare(str1, str2)
  counter = 0

  str1.each_with_index do |char1, char_index|
    if char1 != str2[char_index]
      counter += 1

      break if counter > 2
    end
  end

  if counter == 2
    @connected[str1] << str2
    @connected[str2] << str1
  end
end

def count_groups
  counter = 0

  until @connected.empty?
    counter += 1
    connected_strs = [ @connected.keys.first ]

    until connected_strs.empty?
      connected_strs.map! { |str| @connected.delete(str) }
      connected_strs.compact!
      connected_strs.flatten!(1)
    end
  end

  counter
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_num_similar_groups < Test::Unit::TestCase
  def test_
    assert_equal 2, num_similar_groups([""tars"", ""rats"", ""arts"", ""star""])
    assert_equal 1, num_similar_groups([""omv"", ""ovm""])
  end
end
"
0841,keys-and-rooms,"# frozen_string_literal: true

# 841. Keys and Rooms
# https://leetcode.com/problems/keys-and-rooms
# Medium

=begin
There are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.

When you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.

Given an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.

Example 1:
Input: rooms = [[1],[2],[3],[]]
Output: true
Explanation:
We visit room 0 and pick up key 1.
We then visit room 1 and pick up key 2.
We then visit room 2 and pick up key 3.
We then visit room 3.
Since we were able to visit every room, we return true.

Example 2:
Input: rooms = [[1,3],[3,0,1],[2],[0]]
Output: false
Explanation: We can not enter room number 2 since the only key that unlocks it is in that room.

Constraints:
n == rooms.length
2 <= n <= 1000
0 <= rooms[i].length <= 1000
1 <= sum(rooms[i].length) <= 3000
0 <= rooms[i][j] < n
All the values of rooms[i] are unique.
=end

# @param {Integer[][]} rooms
# @return {Boolean}
def can_visit_all_rooms(rooms)
  seen = [0] * rooms.count
  seen[0] = 1
  stack = rooms[0]

  until stack.empty?
    r = stack.pop
    seen[r] = 1
    rooms[r].each do |k|
     stack << k if seen[k] == 0
   end
  end

  seen.find { |r| r == 0 }.nil?
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_can_visit_all_rooms < Test::Unit::TestCase
  def test_
    assert_equal true, can_visit_all_rooms([[1], [2], [3], []])
    assert_equal false, can_visit_all_rooms([[1, 3], [3, 0, 1], [2], [0]])
  end
end
"
0844,backspace-string-compare,"# frozen_string_literal: true

# 844. Backspace String Compare
# https://leetcode.com/problems/backspace-string-compare

=begin

Given two strings s and t, return true if they are equal when both are typed into empty text editors. '#' means a backspace character.

Note that after backspacing an empty text, the text will continue empty.

### Example 1:
Input: s = ""ab#c"", t = ""ad#c""
Output: true
Explanation: Both s and t become ""ac"".

### Example 2:
Input: s = ""ab##"", t = ""c#d#""
Output: true
Explanation: Both s and t become """".

### Example 3:
Input: s = ""a#c"", t = ""b""
Output: false
Explanation: s becomes ""c"" while t becomes ""b"".

### Constraints:
* 1 <= s.length, t.length <= 200
* s and t only contain lowercase letters and '#' characters.

=end

# @param {String} s
# @param {String} t
# @return {Boolean}
def backspace_compare(s, t)
  backspace(s) == backspace(t)
end

def backspace(str)
  str.chars.inject("""") do |r, c|
    (c == ""#"") ? r[0...-1] : (r + c)
  end
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_backspace_compare < Test::Unit::TestCase
  def test_
    assert_equal true, backspace_compare(""ab#c"", ""ad#c"")
    assert_equal true, backspace_compare(""ab##"", ""c#d#"")
    assert_equal false, backspace_compare(""a#c"", ""b"")
  end
end
"
0847,shortest-path-visiting-all-nodes,"# frozen_string_literal: true

# 847. Shortest Path Visiting All Nodes
# Hard
# https://leetcode.com/problems/shortest-path-visiting-all-nodes

=begin
You have an undirected, connected graph of n nodes labeled from 0 to n - 1. You are given an array graph where graph[i] is a list of all the nodes connected with node i by an edge.
Return the length of the shortest path that visits every node. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.

Example 1:
Input: graph = [[1,2,3],[0],[0],[0]]
Output: 4
Explanation: One possible path is [1,0,2,0,3]

Example 2:
Input: graph = [[1],[0,2,4],[1,3,4],[2],[1,2]]
Output: 4
Explanation: One possible path is [0,1,4,2,3]

Constraints:
* n == graph.length
* 1 <= n <= 12
* 0 <= graph[i].length < n
* graph[i] does not contain i.
* If graph[a] contains b, then graph[b] contains a.
* The input graph is always connected.
=end

# @param {Integer[][]} graph
# @return {Integer}
def shortest_path_length(graph)
  v = graph.length
  curr_level = []

  (0...v).each do |u|
    curr_level << [u, 1 << u]
  end

  all_visited = (1 << v) - 1
  visited = Array.new(v) { Array.new(all_visited + 1, false) }

  (0...v).each do |u|
    visited[u][1 << u] = true
  end

  path_length = 0

  until curr_level.empty?
    n = curr_level.length
    while n.positive?
      u, bit_mask = curr_level.shift

      return path_length if bit_mask == all_visited

      graph[u].each do |v|
        next_bit_mask = bit_mask | (1 << v)

        next if visited[v][next_bit_mask]

        return path_length + 1 if next_bit_mask == all_visited

        curr_level << [v, next_bit_mask]
        visited[v][next_bit_mask] = true
      end

      n -= 1
    end

    path_length += 1
  end

  -1
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_shortest_path_length < Test::Unit::TestCase
  def test_
    assert_equal 4, shortest_path_length([[1, 2, 3], [0], [0], [0]])
    assert_equal 4, shortest_path_length([[1], [0, 2, 4], [1, 3, 4], [2], [1, 2]])
  end
end
"
0852,peak-index-in-a-mountain-array,"# frozen_string_literal: true

# 852. Peak Index in a Mountain Array
# Medium
# https://leetcode.com/problems/peak-index-in-a-mountain-array

=begin
An array arr a mountain if the following properties hold:
* arr.length >= 3
* There exists some i with 0 < i < arr.length - 1 such that:
  * arr[0] < arr[1] < ... < arr[i - 1] < arr[i]
  * arr[i] > arr[i + 1] > ... > arr[arr.length - 1]
Given a mountain array arr, return the index i such that arr[0] < arr[1] < ... < arr[i - 1] < arr[i] > arr[i + 1] > ... > arr[arr.length - 1].
You must solve it in O(log(arr.length)) time complexity.

Example 1:
Input: arr = [0,1,0]
Output: 1

Example 2:
Input: arr = [0,2,1,0]
Output: 1

Example 3:
Input: arr = [0,10,5,2]
Output: 1

Constraints:
* 3 <= arr.length <= 105
* 0 <= arr[i] <= 106
* arr is guaranteed to be a mountain array.
=end

# @param {Integer[]} arr
# @return {Integer}
def peak_index_in_mountain_array(arr)
  low = 0
  high = arr.length - 1

  while low < high
    mid = low + (high - low) / 2

    if arr[mid] < arr[mid + 1]
      low = mid + 1
    else
      high = mid
    end
  end

  low
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_peak_index_in_mountain_array < Test::Unit::TestCase
  def test_
    assert_equal 1, peak_index_in_mountain_array([0, 1, 0])
    assert_equal 1, peak_index_in_mountain_array([0, 2, 1, 0])
    assert_equal 1, peak_index_in_mountain_array([0, 10, 5, 2])
  end
end
"
0859,buddy-strings,"# frozen_string_literal: true

# 859. Buddy Strings
# Easy
# https://leetcode.com/problems/buddy-strings

=begin
Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.
Swapping letters is defined as taking two indices i and j (0-indexed) such that i != j and swapping the characters at s[i] and s[j].
* For example, swapping at indices 0 and 2 in ""abcd"" results in ""cbad"".

Example 1:
Input: s = ""ab"", goal = ""ba""
Output: true
Explanation: You can swap s[0] = 'a' and s[1] = 'b' to get ""ba"", which is equal to goal.

Example 2:
Input: s = ""ab"", goal = ""ab""
Output: false
Explanation: The only letters you can swap are s[0] = 'a' and s[1] = 'b', which results in ""ba"" != goal.

Example 3:
Input: s = ""aa"", goal = ""aa""
Output: true
Explanation: You can swap s[0] = 'a' and s[1] = 'a' to get ""aa"", which is equal to goal.

Constraints:
* 1 <= s.length, goal.length <= 2 * 104
* s and goal consist of lowercase letters.
=end

# @param {String} s
# @param {String} goal
# @return {Boolean}
def buddy_strings1(s, goal)
  return false if s.length != goal.length
  return false if s.size < 2

  h = {}
  ans = []
  dublicates = false
  s.chars.each_with_index { |v, i|
    dublicates = true if h[v]
    h[v] = true
    return false if ans.size > 2
    ans.push(i) if v != goal[i]
  }
  return dublicates if ans.empty?
  return false if ans.size != 2
  i, j = ans
  s[i] == goal[j] && s[j] == goal[i]
end

def buddy_strings2(s, goal)
  return false if s.length != goal.length

  s1 = """"
  s2 = """"
  chars = [].to_set
  repeated = false

  s.length.times do |i|
    repeated ||= !chars.add?(s[i])
    next if s[i] == goal[i]
    s1 += s[i]
    s2 += goal[i]
  end

  (s1.length == 2 && s1 == s2.reverse) ||
      (s1.length == 0 && repeated)
end

def buddy_strings3(s, goal)
  return false if s.size != goal.size
  d = s.chars.zip(goal.chars).each_with_index.inject([]) { |res, ((c1, c2), idx)|
    res << idx if c1 != c2
    res
  }
  case d.size
  when 0 then !s.chars.tally.filter { |c, v| v >= 2 }.empty?
  when 2 then s[d.first] == goal[d.last] && s[d.last] == goal[d.first]
  else
    false
  end
end

def buddy_strings4(s, goal)
  return false if s.size != goal.size

  s_uniq_chars = s.chars.uniq.sort
  gogal_uniq_chars = goal.chars.uniq.sort

  return false if s_uniq_chars != gogal_uniq_chars

  if s == goal
    s.size - s_uniq_chars.size >= 1
  else
    indices = []
    counter = 0

    s.size.times do |i|
      if s[i] != goal[i]
        counter += 1
        indices << i
      end

      return false if counter > 2
    end

    s[indices[0]] == goal[indices[1]] &&
      s[indices[1]] == goal[indices[0]]
  end
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_buddy_strings < Test::Unit::TestCase
  def test_
    assert_equal true, buddy_strings4(""ab"", ""ba"")
    assert_equal false, buddy_strings4(""ab"", ""ab"")
    assert_equal true, buddy_strings4(""aa"", ""aa"")
  end
end

# ********************#
#     Benchmark       #
# ********************#

require ""benchmark""

s = ""abcd""
goal = ""cbad""
Benchmark.bm do |bm|
  bm.report(""buddy_strings1: "") { buddy_strings1(s, goal) }
  bm.report(""buddy_strings2: "") { buddy_strings2(s, goal) }
  bm.report(""buddy_strings3: "") { buddy_strings3(s, goal) }
  bm.report(""buddy_strings4: "") { buddy_strings4(s, goal) }
end

#        user     system      total        real
# buddy_strings1:   0.000032   0.000004   0.000036 (  0.000029)
# buddy_strings2:   0.002619   0.000254   0.002873 (  0.002903)
# buddy_strings3:   0.000639   0.000004   0.000643 (  0.000641)
# buddy_strings4:   0.000022   0.000001   0.000023 (  0.000021)
"
0863,all-nodes-distance-k-in-binary-tree,"# frozen_string_literal: true

# 863. All Nodes Distance K in Binary Tree
# Medium
# https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree

=begin
Given the root of a binary tree, the value of a target node target, and an integer k, return an array of the values of all nodes that have a distance k from the target node.

You can return the answer in any order.

Example 1:
Input: root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2
Output: [7,4,1]
Explanation: The nodes that are a distance 2 from the target node (with value 5) have values 7, 4, and 1.

Example 2:
Input: root = [1], target = 1, k = 3
Output: []

Constraints:
* The number of nodes in the tree is in the range [1, 500].
* 0 <= Node.val <= 500
* All the values Node.val are unique.
* target is the value of one of the nodes in the tree.
* 0 <= k <= 1000
=end

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val)
#         @val = val
#         @left, @right = nil, nil
#     end
# end
# @param {TreeNode} root
# @param {TreeNode} target
# @param {Integer} k
# @return {Integer[]}
def distance_k(root, target, k)
  graph = {}
  build_graph(graph, root, nil)
  bfs(graph, target, k)
end

def build_graph(graph, node, parent)
  return if node.nil?

  graph[node] = []
  graph[node] << parent unless parent.nil?
  graph[parent] << node unless parent.nil?

  build_graph(graph, node.left, node)
  build_graph(graph, node.right, node)
end

def bfs(graph, target, k)
  queue = [[target, 0]]
  visited = { target => true }
  res = []

  while !queue.empty?
    node, dist = queue.shift

    if dist == k
      res << node.val
    end

    graph[node].each do |nei|
      next if visited[nei]

      visited[nei] = true
      queue << [nei, dist + 1]
    end
  end

  res
end
"
0864,shortest-path-to-get-all-keys,"# frozen_string_literal: true

# 864. Shortest Path to Get All Keys
# Hard
# https://leetcode.com/problems/shortest-path-to-get-all-keys

=begin
You are given an m x n grid grid where:
* '.' is an empty cell.
* '#' is a wall.
* '@' is the starting point.
* Lowercase letters represent keys.
* Uppercase letters represent locks.
You start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.
If you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.
For some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.
Return the lowest number of moves to acquire all keys. If it is impossible, return -1.

Example 1:
Input: grid = [""@.a.."",""###.#"",""b.A.B""]
Output: 8
Explanation: Note that the goal is to obtain all the keys not to open all the locks.

Example 2:
Input: grid = [""@..aA"",""..B#."",""....b""]
Output: 6

Example 3:
Input: grid = [""@Aa""]
Output: -1

Constraints:
* m == grid.length
* n == grid[i].length
* 1 <= m, n <= 30
* grid[i][j] is either an English letter, '.', '#', or '@'.
* The number of keys in the grid is in the range [1, 6].
* Each key in the grid is unique.
* Each key in the grid has a matching lock.
=end

# @param {String[]} grid
# @return {Integer}
def shortest_path_all_keys(grid)
  m = grid.size
  n = grid[0].size

  start = nil
  key_count = 0
  for i in (0...m) do
    for j in (0...n) do
      start = [i, j] if grid[i][j] == ""@""
      key_count += 1 if grid[i][j].ord >= ""a"".ord && grid[i][j].ord <= ""f"".ord
    end
  end

  number_key_states = 2**key_count
  all_keys_state = number_key_states - 1
  visited = Array.new(m) { Array.new(n) { Array.new(number_key_states, false) } }

  start << 0 # distance
  start << 0 # keys
  bfs = [start]

  dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]

  while !bfs.empty?
    x, y, distance, keys = bfs.shift()

    for dir_x, dir_y in dirs do
      new_x = x + dir_x
      new_y = y + dir_y

      if new_x >= 0 && new_x < m && new_y >= 0 && new_y < n && grid[new_x][new_y] != ""#"" &&
        !visited[new_x][new_y][keys]

        bfs_continue = false
        new_keys = keys

        # It's a lock, we need the key
        if grid[new_x][new_y].ord >= ""A"".ord && grid[new_x][new_y].ord <= ""F"".ord
          key_mask = 1 << grid[new_x][new_y].ord - ""A"".ord
          bfs_continue = key_mask & keys != 0

        # It's a key, pick it up
        elsif grid[new_x][new_y].ord >= ""a"".ord && grid[new_x][new_y].ord <= ""f"".ord
          bfs_continue = true
          key_mask = 1 << grid[new_x][new_y].ord - ""a"".ord
          new_keys |= key_mask
        # move freely because it's not a wall. It's open or the start
        else
          bfs_continue = true
        end

        if bfs_continue
          return distance + 1 if new_keys == all_keys_state
          visited[new_x][new_y][keys] = true
          bfs << [new_x, new_y, distance + 1, new_keys]
        end
      end
    end
  end

  -1
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_shortest_path_all_keys < Test::Unit::TestCase
  def test_
    assert_equal 8, shortest_path_all_keys([""@.a.."", ""###.#"", ""b.A.B""])
    assert_equal 6, shortest_path_all_keys([""@..aA"", ""..B#."", ""....b""])
    assert_equal(-1, shortest_path_all_keys([""@Aa""]))
  end
end
"
0867,transpose-matrix,"# frozen_string_literal: true

# 867. Transpose Matrix
# Easy
# https://leetcode.com/problems/transpose-matrix

=begin
Given a 2D integer array matrix, return the transpose of matrix.
The transpose of a matrix is the matrix flipped over its main diagonal, switching the matrix's row and column indices.

Example 1:
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [[1,4,7],[2,5,8],[3,6,9]]

Example 2:
Input: matrix = [[1,2,3],[4,5,6]]
Output: [[1,4],[2,5],[3,6]]

Constraints:
m == matrix.length
n == matrix[i].length
1 <= m, n <= 1000
1 <= m * n <= 105
-109 <= matrix[i][j] <= 109
=end

# @param {Integer[][]} matrix
# @return {Integer[][]}
def transpose(matrix)
  matrix.transpose
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_transpose < Test::Unit::TestCase
  def test_
    assert_equal [[1, 4, 7], [2, 5, 8], [3, 6, 9]], transpose([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    assert_equal [[1, 4], [2, 5], [3, 6]], transpose([[1, 2, 3], [4, 5, 6]])
  end
end
"
0872,leaf-similar-trees,"# frozen_string_literal: true

# 872. Leaf-Similar Trees
# https://leetcode.com/problems/leaf-similar-trees
# Easy

=begin
Consider all the leaves of a binary tree, from left to right order, the values of those leaves form a leaf value sequence.

For example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8).

Two binary trees are considered leaf-similar if their leaf value sequence is the same.

Return true if and only if the two given trees with head nodes root1 and root2 are leaf-similar.

Example 1:
Input: root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]
Output: true

Example 2:
Input: root1 = [1,2,3], root2 = [1,3,2]
Output: false

Constraints:
The number of nodes in each tree will be in the range [1, 200].
Both of the given trees will have values in the range [0, 200].
=end

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root1
# @param {TreeNode} root2
# @return {Boolean}
def leaf_similar(root1, root2)
  leafs(root1) == leafs(root2)
end

def leafs(root)
  return [root.val] if !root.left && !root.right

  result = []

  result += leafs(root.left) if root.left
  result += leafs(root.right) if root.right
  result
end
"
0875,koko-eating-bananas,"# frozen_string_literal: true

# 875. Koko Eating Bananas
# https://leetcode.com/problems/koko-eating-bananas
# Medium

=begin

Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours.

Koko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.

Koko likes to eat slowly but still wants to finish eating all the bananas before the guards return.

Return the minimum integer k such that she can eat all the bananas within h hours.

Constraints:

* 1 <= piles.length <= 104
* piles.length <= h <= 109
* 1 <= piles[i] <= 109

=end

# @param {Integer[]} piles
# @param {Integer} h
# @return {Integer}
def min_eating_speed(piles, h)
  (1..piles.max).bsearch do |x|
    piles.sum { (_1 + x - 1) / x } <= h
  end
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_min_eating_speed < Test::Unit::TestCase
  def test_
    assert_equal 4, min_eating_speed([3, 6, 7, 11], 8)
    assert_equal 30, min_eating_speed([30, 11, 23, 4, 20], 5)
    assert_equal 23, min_eating_speed([30, 11, 23, 4, 20], 6)
  end
end
"
0876,middle-of-the-linked-list,"# frozen_string_literal: true

# 876. Middle of the Linked List
# https://leetcode.com/problems/middle-of-the-linked-list
# Easy
# TODO: Write Tests

=begin

Given the head of a singly linked list, return the middle node of the linked list.

If there are two middle nodes, return the second middle node.

### Example 1:
Input: head = [1,2,3,4,5]
Output: [3,4,5]
Explanation: The middle node of the list is node 3.

### Example 2:
Input: head = [1,2,3,4,5,6]
Output: [4,5,6]
Explanation: Since the list has two middle nodes with values 3 and 4, we return the second one.

### Constraints:
* The number of nodes in the list is in the range [1, 100].
* 1 <= Node.val <= 100

=end

# Definition for singly-linked list.
# class ListNode
#     attr_accessor :val, :next
#     def initialize(val = 0, _next = nil)
#         @val = val
#         @next = _next
#     end
# end
# @param {ListNode} head
# @return {ListNode}
def middle_node(head)
  slow = fast = head
  while fast != nil && fast.next != nil
    slow = slow.next
    fast = fast.next.next
  end
  slow
end
"
0879,profitable-schemes,"# frozen_string_literal: true

# 879. Profitable Schemes
# https://leetcode.com/problems/profitable-schemes/
# Hard

=begin
There is a group of n members, and a list of various crimes they could commit. The ith crime generates a profit[i] and requires group[i] members to participate in it. If a member participates in one crime, that member can't participate in another crime.

Let's call a profitable scheme any subset of these crimes that generates at least minProfit profit, and the total number of members participating in that subset of crimes is at most n.

Return the number of schemes that can be chosen. Since the answer may be very large, return it modulo 109 + 7.

Example 1:
Input: n = 5, minProfit = 3, group = [2,2], profit = [2,3]
Output: 2
Explanation: To make a profit of at least 3, the group could either commit crimes 0 and 1, or just crime 1.
In total, there are 2 schemes.

Example 2:
Input: n = 10, minProfit = 5, group = [2,3,5], profit = [6,7,8]
Output: 7
Explanation: To make a profit of at least 5, the group could commit any crimes, as long as they commit one.
There are 7 possible schemes: (0), (1), (2), (0,1), (0,2), (1,2), and (0,1,2).

Constraints:
1 <= n <= 100
0 <= minProfit <= 100
1 <= group.length <= 100
1 <= group[i] <= 100
profit.length == group.length
0 <= profit[i] <= 100
=end

# @param {Integer} n
# @param {Integer} min_profit
# @param {Integer[]} group
# @param {Integer[]} profit
# @return {Integer}
MOD = 10**9 + 7
def profitable_schemes(n, min_profit, group, profit)
  dp = Array.new(n + 1) { Array.new(min_profit + 1, 0) }
  dp[0][0] = 1
  group.each_with_index do |g, i|
    (n - g).downto(0) do |j|
      min_profit.downto(0) do |k|
          dp[j + g][[min_profit, k + profit[i]].min] += dp[j][k]
          dp[j + g][[min_profit, k + profit[i]].min] %= MOD
        end
    end
  end
  (0..n).sum { |i| dp[i][min_profit] } % MOD
end
"
0880,decoded-string-at-index,"# frozen_string_literal: true

# 880. Decoded String at Index
# Medium
# https://leetcode.com/problems/decoded-string-at-index

=begin
You are given an encoded string s. To decode the string to a tape, the encoded string is read one character at a time and the following steps are taken:

If the character read is a letter, that letter is written onto the tape.
If the character read is a digit d, the entire current tape is repeatedly written d - 1 more times in total.
Given an integer k, return the kth letter (1-indexed) in the decoded string.

Example 1:
Input: s = ""leet2code3"", k = 10
Output: ""o""
Explanation: The decoded string is ""leetleetcodeleetleetcodeleetleetcode"".
The 10th letter in the string is ""o"".

Example 2:
Input: s = ""ha22"", k = 5
Output: ""h""
Explanation: The decoded string is ""hahahaha"".
The 5th letter is ""h"".

Example 3:
Input: s = ""a2345678999999999999999"", k = 1
Output: ""a""
Explanation: The decoded string is ""a"" repeated 8301530446056247680 times.
The 1st letter is ""a"".

Constraints:
2 <= s.length <= 100
s consists of lowercase English letters and digits 2 through 9.
s starts with a letter.
1 <= k <= 109
It is guaranteed that k is less than or equal to the length of the decoded string.
The decoded string is guaranteed to have less than 263 letters.
=end

# @param {String} s
# @param {Integer} k
# @return {String}
def decode_at_index(s, k)
  length = 0
  s.chars.each do |char|
    length = /\d/.match?(char) ? length * char.to_i : length + 1
    next if k <= length
  end

  s.reverse.each_char do |char|
    if /\d/.match?(char)
      length /= char.to_i
      k %= length
    else
      return char if k == length || k == 0
      length -= 1
    end
  end
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_decode_at_index < Test::Unit::TestCase
  def test_
    assert_equal ""o"", decode_at_index(""leet2code3"", 10)
    assert_equal ""h"", decode_at_index(""ha22"", 5)
    assert_equal ""a"", decode_at_index(""a2345678999999999999999"", 1)
  end
end
"
0881,boats-to-save-people,"# frozen_string_literal: true

# 881. Boats to Save People
# https://leetcode.com/problems/boats-to-save-people

=begin

You are given an array people where people[i] is the weight of the ith person, and an infinite number of boats where each boat can carry a maximum weight of limit. Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most limit.

Return the minimum number of boats to carry every given person.

### Example 1:
Input: people = [1,2], limit = 3
Output: 1
Explanation: 1 boat (1, 2)

### Example 2:
Input: people = [3,2,2,1], limit = 3
Output: 3
Explanation: 3 boats (1, 2), (2) and (3)

### Example 3:
Input: people = [3,5,3,4], limit = 5
Output: 4
Explanation: 4 boats (3), (3), (4), (5)

### Constraints:
* 1 <= people.length <= 5 * 104
* 1 <= people[i] <= limit <= 3 * 104

=end

# @param {Integer[]} people
# @param {Integer} limit
# @return {Integer}
def num_rescue_boats(people, limit)
  people.sort!

  left = 0
  right = people.count - 1
  boat_count = 0

  loop do
    left += 1 if people[left] + people[right] <= limit
    boat_count += 1
    break if left >= right
    right -= 1
  end

  boat_count
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_num_rescue_boats < Test::Unit::TestCase
  def test_
    assert_equal 1, num_rescue_boats([1, 2], 3)
    assert_equal 3, num_rescue_boats([3, 2, 2, 1], 3)
    assert_equal 4, num_rescue_boats([3, 5, 3, 4], 5)
  end
end
"
0894,all-possible-full-binary-trees,"# frozen_string_literal: true

# 894. All Possible Full Binary Trees
# Medium
# https://leetcode.com/problems/all-possible-full-binary-trees

=begin
Given an integer n, return a list of all possible full binary trees with n nodes. Each node of each tree in the answer must have Node.val == 0.
Each element of the answer is the root node of one possible tree. You may return the final list of trees in any order.
A full binary tree is a binary tree where each node has exactly 0 or 2 children.

Example 1:
Input: n = 7
Output: [[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]

Example 2:
Input: n = 3
Output: [[0,0,0]]
=end

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {Integer} n
# @return {TreeNode[]}
def all_possible_fbt(n)
  return [] if n.even?
  dp = Array.new(n + 1) { Array.new() }
  dp[1].push(TreeNode.new(0))
  (3...n + 1).step(2).each do |c|
    (1...c - 1).step(2).each do |i|
      j = c - 1 - i
      dp[i].each do |l|
        dp[j].each do |r|
          r = TreeNode.new(0, l, r)
          dp[c].push(r)
        end
      end
    end
  end
  dp[n]
end
"
0896,monotonic-array,"# frozen_string_literal: true

# 896. Monotonic Array
# Easy
# https://leetcode.com/problems/monotonic-array

=begin
An array is monotonic if it is either monotone increasing or monotone decreasing.
An array nums is monotone increasing if for all i <= j, nums[i] <= nums[j]. An array nums is monotone decreasing if for all i <= j, nums[i] >= nums[j].
Given an integer array nums, return true if the given array is monotonic, or false otherwise.

Example 1:
Input: nums = [1,2,2,3]
Output: true

Example 2:
Input: nums = [6,5,4,4]
Output: true

Example 3:
Input: nums = [1,3,2]
Output: false

Constraints:
1 <= nums.length <= 105
-105 <= nums[i] <= 105
=end

# @param {Integer[]} nums
# @return {Boolean}
def is_monotonic(nums)
  x = nums
  up = false
  down = false
  (1...x.size).each do |i|
    return false if up && down
    up = true if x[i - 1] < x[i]
    down = true if x[i - 1] > x[i]
  end
  return false if up && down
  true
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_is_monotonic < Test::Unit::TestCase
  def test_
    assert_equal true, is_monotonic([1, 2, 2, 3])
    assert_equal true, is_monotonic([6, 5, 4, 4])
    assert_equal false, is_monotonic([1, 3, 2])
  end
end
"
0901,online-stock-span,"# frozen_string_literal: true

# 901. Online Stock Span
# https://leetcode.com/problems/online-stock-span
# Medium

=begin
Design an algorithm that collects daily price quotes for some stock and returns the span of that stock's price for the current day.

The span of the stock's price in one day is the maximum number of consecutive days (starting from that day and going backward) for which the stock price was less than or equal to the price of that day.

For example, if the prices of the stock in the last four days is [7,2,1,2] and the price of the stock today is 2, then the span of today is 4 because starting from today, the price of the stock was less than or equal 2 for 4 consecutive days.
Also, if the prices of the stock in the last four days is [7,34,1,2] and the price of the stock today is 8, then the span of today is 3 because starting from today, the price of the stock was less than or equal 8 for 3 consecutive days.
Implement the StockSpanner class:

StockSpanner() Initializes the object of the class.
int next(int price) Returns the span of the stock's price given that today's price is price.

Example 1:
Input
[""StockSpanner"", ""next"", ""next"", ""next"", ""next"", ""next"", ""next"", ""next""]
[[], [100], [80], [60], [70], [60], [75], [85]]
Output
[null, 1, 1, 1, 2, 1, 4, 6]

Explanation
StockSpanner stockSpanner = new StockSpanner();
stockSpanner.next(100); // return 1
stockSpanner.next(80);  // return 1
stockSpanner.next(60);  // return 1
stockSpanner.next(70);  // return 2
stockSpanner.next(60);  // return 1
stockSpanner.next(75);  // return 4, because the last 4 prices (including today's price of 75) were less than or equal to today's price.
stockSpanner.next(85);  // return 6

Constraints:
1 <= price <= 105
At most 104 calls will be made to next.
=end

class StockSpanner
  def initialize
    @current_index = -1
    @sorted = []
  end


=begin
  :type price: Integer
  :rtype: Integer
=end
  def next(current_price)
    @current_index += 1

    index_of_higher_price = @sorted.bsearch_index { |pair| pair.first > current_price } || @sorted.size
    @sorted[...index_of_higher_price] = [[current_price, @current_index]]

    @current_index - (@sorted[1]&.last || -1)
  end
end

# Your StockSpanner object will be instantiated and called as such:
# obj = StockSpanner.new()
# param_1 = obj.next(price)
"
0904,fruit-into-baskets,"# frozen_string_literal: true

# 904. Fruit Into Baskets
# https://leetcode.com/problems/fruit-into-baskets

# @param {Integer[]} fruits
# @return {Integer}
def total_fruit(fruits)
  left = 0
  max_fruit = 0
  hash = {}
  hash.default = 0

  fruits.each_with_index do |fruit, right|
    hash[fruit] += 1

    while hash.length > 2
      hash[fruits[left]] -= 1

      hash.delete(fruits[left]) if hash[fruits[left]].zero?

      left += 1
    end

    max_fruit = [max_fruit, right - left + 1].max
  end

  max_fruit
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_total_fruit < Test::Unit::TestCase
  def test_
    assert_equal 3, total_fruit([1, 2, 1])
    assert_equal 3, total_fruit([0, 1, 2, 2])
    assert_equal 4, total_fruit([1, 2, 3, 2, 2])
  end
end
"
0905,sort-array-by-parity,"# frozen_string_literal: true

# 905. Sort Array By Parity
# Easy
# https://leetcode.com/problems/sort-array-by-parity

=begin
Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers.
Return any array that satisfies this condition.

Example 1:
Input: nums = [3,1,2,4]
Output: [2,4,3,1]
Explanation: The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.

Example 2:
Input: nums = [0]
Output: [0]

Constraints:
1 <= nums.length <= 5000
0 <= nums[i] <= 5000
=end

# @param {Integer[]} nums
# @return {Integer[]}
def sort_array_by_parity(nums)
  nums.partition(&:even?).sum([])
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_length_of_longest_substring < Test::Unit::TestCase
  def test_
    assert_equal [2, 4, 3, 1].sort, sort_array_by_parity([3, 1, 2, 4]).sort
    assert_equal [0].sort, sort_array_by_parity([0])
  end
end
"
0909,snakes-and-ladders,"# frozen_string_literal: true

# 909. Snakes and Ladders
# https://leetcode.com/problems/snakes-and-ladders
# Medium

=begin
You are given an n x n integer matrix board where the cells are labeled from 1 to n2 in a Boustrophedon style starting from the bottom left of the board (i.e. board[n - 1][0]) and alternating direction each row.
You start on square 1 of the board. In each move, starting from square curr, do the following:
* Choose a destination square next with a label in the range [curr + 1, min(curr + 6, n2)].
  * This choice simulates the result of a standard 6-sided die roll: i.e., there are always at most 6 destinations, regardless of the size of the board.
* If next has a snake or ladder, you must move to the destination of that snake or ladder. Otherwise, you move to next.
* The game ends when you reach the square n2.
A board square on row r and column c has a snake or ladder if board[r][c] != -1. The destination of that snake or ladder is board[r][c]. Squares 1 and n2 do not have a snake or ladder.
Note that you only take a snake or ladder at most once per move. If the destination to a snake or ladder is the start of another snake or ladder, you do not follow the subsequent snake or ladder.
* For example, suppose the board is [[-1,4],[-1,3]], and on the first move, your destination square is 2. You follow the ladder to square 3, but do not follow the subsequent ladder to 4.
Return the least number of moves required to reach the square n2. If it is not possible to reach the square, return -1.

Example 1:
Input: board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]
Output: 4
Explanation:
In the beginning, you start at square 1 (at row 5, column 0).
You decide to move to square 2 and must take the ladder to square 15.
You then decide to move to square 17 and must take the snake to square 13.
You then decide to move to square 14 and must take the ladder to square 35.
You then decide to move to square 36, ending the game.
This is the lowest possible number of moves to reach the last square, so return 4.

Example 2:
Input: board = [[-1,-1],[-1,3]]
Output: 1

Constraints:
* n == board.length == board[i].length
* 2 <= n <= 20
* board[i][j] is either -1 or in the range [1, n2].
* The squares labeled 1 and n2 do not have any ladders or snakes.
=end

# @param {Integer[][]} board
# @return {Integer}
def snakes_and_ladders(board)
  h = Array.new (t = board.size**2) { [] }
  board.reverse!.each_with_index { _1.reverse! if _2.odd? }
  board.unshift nil
  board.flatten!
  for i in 1...t
    for j in 1..6
      break if (k = i + j) > t
      h[i] << (board[k] < 0 ? k : board[k])
    end
  end
  s, c = (q = [1]).to_set, 0
  until (c += 1) && q.empty?
    q.size.times do
      h[q.shift].each do | k |
        return c if k == t
        next if s === k
        s << k
        q << k
      end
    end
  end
  -1
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_snakes_and_ladders < Test::Unit::TestCase
  def test_
    assert_equal 4, snakes_and_ladders([[-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1], [-1, 35, -1, -1, 13, -1], [-1, -1, -1, -1, -1, -1], [-1, 15, -1, -1, -1, -1]])
    assert_equal 1, snakes_and_ladders([[-1, -1], [-1, 3]])
  end
end
"
0912,sort-an-array,"# frozen_string_literal: true

# 912. Sort an Array
# https://leetcode.com/problems/sort-an-array

# @param {Integer[]} nums
# @return {Integer[]}
def sort_array(nums)
  in_place_quick_sort(nums, 0, nums.length - 1)
  nums
end

def in_place_quick_sort(nums, l, r)
  return if l >= r

  pivot = nums[rand(l..r)]
  pl, pr = partition(nums, l, r, pivot)
  in_place_quick_sort(nums, l, pl - 1)
  in_place_quick_sort(nums, pr + 1, r)
end

def partition(nums, l, r, pivot)
  p0, p1, p2 = l, l, r
  while p1 <= p2
    if nums[p1] < pivot
      nums[p0], nums[p1] = nums[p1], nums[p0]
      p0 += 1
      p1 += 1
    elsif nums[p1] == pivot
      p1 += 1
    else
      nums[p1], nums[p2] = nums[p2], nums[p1]
      p2 -= 1
    end
  end

  [p0, p2]
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_sort_array < Test::Unit::TestCase
  def test_
    assert_equal [1, 2, 3, 5], sort_array([5, 2, 3, 1])
    assert_equal [0, 0, 1, 1, 2, 5], sort_array([5, 1, 1, 2, 0, 0])
  end
end
"
0918,maximum-sum-circular-subarray,"# frozen_string_literal: true

# https://leetcode.com/problems/maximum-sum-circular-subarray
# 918. Maximum Sum Circular Subarray
# Medium

=begin
Given a circular integer array nums of length n, return the maximum possible sum of a non-empty subarray of nums.

A circular array means the end of the array connects to the beginning of the array. Formally, the next element of nums[i] is nums[(i + 1) % n] and the previous element of nums[i] is nums[(i - 1 + n) % n].

A subarray may only include each element of the fixed buffer nums at most once. Formally, for a subarray nums[i], nums[i + 1], ..., nums[j], there does not exist i <= k1, k2 <= j with k1 % n == k2 % n.

Example 1:
Input: nums = [1,-2,3,-2]
Output: 3
Explanation: Subarray [3] has maximum sum 3.

Example 2:
Input: nums = [5,-3,5]
Output: 10
Explanation: Subarray [5,5] has maximum sum 5 + 5 = 10.

Example 3:
Input: nums = [-3,-2,-3]
Output: -2
Explanation: Subarray [-2] has maximum sum -2.

Constraints:
* n == nums.length
* 1 <= n <= 3 * 104
* -3 * 104 <= nums[i] <= 3 * 104
=end

# @param {Integer[]} nums
# @return {Integer}
def max_subarray_sum_circular(nums)
  curr_min = 0
  curr_max = 0
  mini = 1.0 / 0.0
  maxi = -1.0 / 0.0
  sum = 0
  nums.each do |num|
    curr_min = [num, curr_min + num].min
    mini = [mini, curr_min].min
    curr_max = [num, curr_max + num].max
    maxi = [maxi, curr_max].max
    sum += num
  end

  if maxi > 0
    [maxi, sum - mini].max
  else
    maxi
  end
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_max_subarray_sum_circular < Test::Unit::TestCase
  def test_
    assert_equal 3, max_subarray_sum_circular([1, -2, 3, -2])
    assert_equal 10, max_subarray_sum_circular([5, -3, 5])
    assert_equal(-2, max_subarray_sum_circular([-3, -2, -3]))
  end
end
"
0920,number-of-music-playlists,"# frozen_string_literal: true

# 920. Number of Music Playlists
# Hard
# https://leetcode.com/problems/number-of-music-playlists

=begin
Your music player contains n different songs. You want to listen to goal songs (not necessarily different) during your trip. To avoid boredom, you will create a playlist so that:
* Every song is played at least once.
* A song can only be played again only if k other songs have been played.
Given n, goal, and k, return the number of possible playlists that you can create. Since the answer can be very large, return it modulo 109 + 7.

Example 1:
Input: n = 3, goal = 3, k = 1
Output: 6
Explanation: There are 6 possible playlists: [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1].

Example 2:
Input: n = 2, goal = 3, k = 0
Output: 6
Explanation: There are 6 possible playlists: [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2, 1], [2, 1, 2], and [1, 2, 2].

Example 3:
Input: n = 2, goal = 3, k = 1
Output: 2
Explanation: There are 2 possible playlists: [1, 2, 1] and [2, 1, 2].


Constraints:
0 <= k < n <= goal <= 100
=end

# @param {Integer} n
# @param {Integer} goal
# @param {Integer} k
# @return {Integer}
def num_music_playlists(n, goal, k)
  mod = 10**9 + 7
  dp = Array.new(goal + 1) { Array.new(n + 1, 0) }
  dp[0][0] = 1
  for i in 1..goal
    for j in 1..n
      dp[i][j] = (dp[i - 1][j - 1] * (n - j + 1) + dp[i - 1][j] * [ j - k, 0 ].max) % mod
    end
  end
  dp[goal][n]
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_num_music_playlists < Test::Unit::TestCase
  def test_
    assert_equal 6, num_music_playlists(3, 3, 1)
    assert_equal 6, num_music_playlists(2, 3, 0)
    assert_equal 2, num_music_playlists(2, 3, 1)
  end
end
"
0933,number-of-recent-calls,"# frozen_string_literal: true

# 933. Number of Recent Calls
# https://leetcode.com/problems/number-of-recent-calls
# Easy

=begin
You have a RecentCounter class which counts the number of recent requests within a certain time frame.

Implement the RecentCounter class:

RecentCounter() Initializes the counter with zero recent requests.
int ping(int t) Adds a new request at time t, where t represents some time in milliseconds, and returns the number of requests that has happened in the past 3000 milliseconds (including the new request). Specifically, return the number of requests that have happened in the inclusive range [t - 3000, t].
It is guaranteed that every call to ping uses a strictly larger value of t than the previous call.

Example 1:
Input
[""RecentCounter"", ""ping"", ""ping"", ""ping"", ""ping""]
[[], [1], [100], [3001], [3002]]
Output
[null, 1, 2, 3, 3]

Explanation
RecentCounter recentCounter = new RecentCounter();
recentCounter.ping(1);     // requests = [1], range is [-2999,1], return 1
recentCounter.ping(100);   // requests = [1, 100], range is [-2900,100], return 2
recentCounter.ping(3001);  // requests = [1, 100, 3001], range is [1,3001], return 3
recentCounter.ping(3002);  // requests = [1, 100, 3001, 3002], range is [2,3002], return 3

Constraints:
1 <= t <= 109
Each test case will call ping with strictly increasing values of t.
At most 104 calls will be made to ping.
=end

class RecentCounter
  def initialize
    @queue = []
  end

  def ping(t)
    @queue << t

    while @queue[0] < t - 3000
      @queue.shift
    end

    @queue.count
  end
end

# Your RecentCounter object will be instantiated and called as such:
# obj = RecentCounter.new()
# param_1 = obj.ping(t)
"
0934,shortest-bridge,"# frozen_string_literal: true

# 934. Shortest Bridge
# https://leetcode.com/problems/shortest-bridge
# Medium

=begin
You are given an n x n binary matrix grid where 1 represents land and 0 represents water.

An island is a 4-directionally connected group of 1's not connected to any other 1's. There are exactly two islands in grid.

You may change 0's to 1's to connect the two islands to form one island.

Return the smallest number of 0's you must flip to connect the two islands.

Example 1:
Input: grid = [[0,1],[1,0]]
Output: 1

Example 2:
Input: grid = [[0,1,0],[0,0,0],[0,0,1]]
Output: 2

Example 3:
Input: grid = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]
Output: 1

Constraints:
n == grid.length == grid[i].length
2 <= n <= 100
grid[i][j] is either 0 or 1.
There are exactly two islands in grid.
=end

# @param {Integer[][]} grid
# @return {Integer}
def shortest_bridge(grid)
  n = grid.size - 1
  i = 0

  queue = []
  while i <= n
    j = 0

    while j <= n
      if grid[i][j] == 1
        add_to_queue(queue, grid, i, j, 0)
        return find_shortest(queue, grid, n)
      end

      j += 1
    end

    i += 1
  end
end

def find_shortest(queue, grid, n)
  k = 0
  while (i, j, _ = queue[k])
    add_to_queue(queue, grid, i - 1, j, 0) if i > 0 && grid[i - 1][j] == 1
    add_to_queue(queue, grid, i + 1, j, 0) if i < n && grid[i + 1][j] == 1
    add_to_queue(queue, grid, i, j - 1, 0) if j > 0 && grid[i][j - 1] == 1
    add_to_queue(queue, grid, i, j + 1, 0) if j < n && grid[i][j + 1] == 1
    k += 1
  end

  while (i, j, distance = queue.shift)
    if i > 0 && grid[i - 1][j] < 2 && add_to_queue(queue, grid, i - 1, j, distance + 1) ||
       i < n && grid[i + 1][j] < 2 && add_to_queue(queue, grid, i + 1, j, distance + 1) ||
       j > 0 && grid[i][j - 1] < 2 && add_to_queue(queue, grid, i, j - 1, distance + 1) ||
       j < n && grid[i][j + 1] < 2 && add_to_queue(queue, grid, i, j + 1, distance + 1)
      return distance
    end
  end

  -1
end

def add_to_queue(queue, grid, i, j, distance)
  grid_val = grid[i][j]
  grid[i][j] = 2
  queue << [i, j, distance]
  grid_val == 1
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_shortest_bridge < Test::Unit::TestCase
  def test_
    assert_equal 1, shortest_bridge([[0, 1], [1, 0]])
    assert_equal 2, shortest_bridge([[0, 1, 0], [0, 0, 0], [0, 0, 1]])
    assert_equal 1, shortest_bridge([[1, 1, 1, 1, 1], [1, 0, 0, 0, 1], [1, 0, 1, 0, 1], [1, 0, 0, 0, 1], [1, 1, 1, 1, 1]])
  end
end
"
0935,knight-dialer,"# frozen_string_literal: true

# 935. Knight Dialer
# Medium
# leetcode.com/problems/knight-dialer

=begin
The chess knight has a unique movement, it may move two squares vertically and one square horizontally, or two squares horizontally and one square vertically (with both forming the shape of an L). The possible movements of chess knight are shown in this diagaram:
A chess knight can move as indicated in the chess diagram below:
We have a chess knight and a phone pad as shown below, the knight can only stand on a numeric cell (i.e. blue cell).
Given an integer n, return how many distinct phone numbers of length n we can dial.
You are allowed to place the knight on any numeric cell initially and then you should perform n - 1 jumps to dial a number of length n. All jumps should be valid knight jumps.
As the answer may be very large, return the answer modulo 109 + 7.

Example 1:
Input: n = 1
Output: 10
Explanation: We need to dial a number of length 1, so placing the knight over any numeric cell of the 10 cells is sufficient.

Example 2:
Input: n = 2
Output: 20
Explanation: All the valid number we can dial are [04, 06, 16, 18, 27, 29, 34, 38, 40, 43, 49, 60, 61, 67, 72, 76, 81, 83, 92, 94]

Example 3:
Input: n = 3131
Output: 136006598
Explanation: Please take care of the mod.

Constraints:
1 <= n <= 5000
=end

JUMP_TO = [[4, 6], [6, 8], [7, 9], [4, 8], [0, 3, 9], [], [0, 1, 7], [2, 6], [1, 3], [2, 4]]
MOD = 10**9 + 7

def knight_dialer(n)
  (n - 1).times.inject(Array.new(10, 1)) { |cur, i|
    cur.zip(JUMP_TO).each_with_object(Array.new(10, 0)) { |(v, jt), res|
      jt.each { |jti| res[jti] = (res[jti] + v) % MOD }
    }
  }.inject(0) { |res, v| (res + v) % MOD }
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_knight_dialer < Test::Unit::TestCase
  def test_
    assert_equal 10, knight_dialer(1)
    assert_equal 20, knight_dialer(2)
    assert_equal 136006598, knight_dialer(3131)
  end
end
"
0946,validate-stack-sequences,"# frozen_string_literal: true

# 946. Validate Stack Sequences
# https://leetcode.com/problems/validate-stack-sequences/
# Medium

=begin

Given two integer arrays pushed and popped each with distinct values, return true if this could have been the result of a sequence of push and pop operations on an initially empty stack, or false otherwise.

### Example 1:
Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
Output: true
Explanation: We might do the following sequence:
push(1), push(2), push(3), push(4),
pop() -> 4,
push(5),
pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1

### Example 2:
Input: pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
Output: false
Explanation: 1 cannot be popped before 2.

### Constraints:
* 1 <= pushed.length <= 1000
* 0 <= pushed[i] <= 1000
* All the elements of pushed are unique.
* popped.length == pushed.length
* popped is a permutation of pushed.

=end

# @param {Integer[]} pushed
# @param {Integer[]} popped
# @return {Boolean}
def validate_stack_sequences(pushed, popped)
  stack = []
  for x in pushed
    stack << x
    while stack.last && stack.last == popped.first
      stack.pop
      popped.shift
    end
  end
  popped.empty?
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_validate_stack_sequences < Test::Unit::TestCase
  def test_
    assert_equal true, validate_stack_sequences([1, 2, 3, 4, 5], [4, 5, 3, 2, 1])
    assert_equal false, validate_stack_sequences([1, 2, 3, 4, 5], [4, 3, 5, 1, 2])
  end
end
"
0947,most-stones-removed-with-same-row-or-column,"# frozen_string_literal: true

# 947. Most Stones Removed with Same Row or Column
# https://leetcode.com/problems/most-stones-removed-with-same-row-or-column
# Medium

=begin
On a 2D plane, we place n stones at some integer coordinate points. Each coordinate point may have at most one stone.

A stone can be removed if it shares either the same row or the same column as another stone that has not been removed.

Given an array stones of length n where stones[i] = [xi, yi] represents the location of the ith stone, return the largest possible number of stones that can be removed.

Example 1:
Input: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]
Output: 5
Explanation: One way to remove 5 stones is as follows:
1. Remove stone [2,2] because it shares the same row as [2,1].
2. Remove stone [2,1] because it shares the same column as [0,1].
3. Remove stone [1,2] because it shares the same row as [1,0].
4. Remove stone [1,0] because it shares the same column as [0,0].
5. Remove stone [0,1] because it shares the same row as [0,0].
Stone [0,0] cannot be removed since it does not share a row/column with another stone still on the plane.

Example 2:
Input: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]
Output: 3
Explanation: One way to make 3 moves is as follows:
1. Remove stone [2,2] because it shares the same row as [2,0].
2. Remove stone [2,0] because it shares the same column as [0,0].
3. Remove stone [0,2] because it shares the same row as [0,0].
Stones [0,0] and [1,1] cannot be removed since they do not share a row/column with another stone still on the plane.

Example 3:
Input: stones = [[0,0]]
Output: 0
Explanation: [0,0] is the only stone on the plane, so you cannot remove it.

Constraints:
1 <= stones.length <= 1000
0 <= xi, yi <= 104
No two stones are at the same coordinate point.
=end

# @param {Integer[][]} stones
# @return {Integer}
# @param {Integer[][]} stones
# @return {Integer}
def remove_stones(stones)
  count = 0
  until stones.empty?
    removed = [stones.shift]
    until removed.empty?
      x, y = removed.pop
      matching_stones = stones.select { |stone| stone[0] == x || stone[1] == y }
      count += matching_stones.size
      removed += matching_stones
      stones -= matching_stones
    end
  end
  count
end


# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_remove_stones < Test::Unit::TestCase
  def test_
    assert_equal 5, remove_stones([[0, 0], [0, 1], [1, 0], [1, 2], [2, 1], [2, 2]])
    assert_equal 3, remove_stones([[0, 0], [0, 2], [1, 1], [2, 0], [2, 2]])
    assert_equal 0, remove_stones([[0, 0]])
  end
end
"
0953,verifying-an-alien-dictionary,"# frozen_string_literal: true

# 953. Verifying an Alien Dictionary
# https://leetcode.com/problems/verifying-an-alien-dictionary

# @param {String[]} words
# @param {String} order
# @return {Boolean}
def is_alien_sorted(words, order)
  words.sort_by { |w| w.chars.map { |c| order.include?(c) ? order.index(c) : c.ord } } == words
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_is_alien_sorted < Test::Unit::TestCase
  def test_
    assert_equal true, is_alien_sorted(%w[hello leetcode], ""hlabcdefgijkmnopqrstuvwxyz"")
    assert_equal false, is_alien_sorted(%w[word world row], ""worldabcefghijkmnpqstuvxyz"")
    assert_equal false, is_alien_sorted(%w[apple app], ""abcdefghijklmnopqrstuvwxyz"")
  end
end
"
0956,tallest-billboard,"# frozen_string_literal: true

# 956. Tallest Billboard
# Hard
# https://leetcode.com/problems/tallest-billboard/

=begin
You are installing a billboard and want it to have the largest height. The billboard will have two steel supports, one on each side. Each steel support must be an equal height.
You are given a collection of rods that can be welded together. For example, if you have rods of lengths 1, 2, and 3, you can weld them together to make a support of length 6.
Return the largest possible height of your billboard installation. If you cannot support the billboard, return 0.

Example 1:
Input: rods = [1,2,3,6]
Output: 6
Explanation: We have two disjoint subsets {1,2,3} and {6}, which have the same sum = 6.

Example 2:
Input: rods = [1,2,3,4,5,6]
Output: 10
Explanation: We have two disjoint subsets {2,3,5} and {4,6}, which have the same sum = 10.

Example 3:
Input: rods = [1,2]
Output: 0
Explanation: The billboard cannot be supported, so we return 0.

Constraints:
* 1 <= rods.length <= 20
* 1 <= rods[i] <= 1000
* sum(rods[i]) <= 5000
=end

# @param {Integer[]} rods
# @return {Integer}
def tallest_billboard(rods)
  max_sum = rods.sum / 2
  dp = { 0 => 0 }
  dp.default = 0

  rods.each do |rod|
    cur = {}
    cur.default = 0

    dp.keys.each do |key|
      cur[key + rod] = [dp[key] + rod, cur[key + rod]].max unless key + rod > max_sum
      cur[key] = [dp[key], cur[key]].max
      cur[key - rod] = [dp[key], cur[key - rod]].max unless key - rod < -max_sum
    end

    dp = cur
  end

  dp[0]
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_tallest_billboard < Test::Unit::TestCase
  def test_
    assert_equal 6, tallest_billboard([1, 2, 3, 6])
    assert_equal 10, tallest_billboard([1, 2, 3, 4, 5, 6])
    assert_equal 0, tallest_billboard([1, 2])
  end
end
"
0958,check-completeness-of-a-binary-tree,"# frozen_string_literal: true

# 958. Check Completeness of a Binary Tree
# https://leetcode.com/problems/check-completeness-of-a-binary-tree

=begin

Given the root of a binary tree, determine if it is a complete binary tree.

In a complete binary tree, every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.

### Constraints:

* The number of nodes in the tree is in the range [1, 100].
* 1 <= Node.val <= 1000

=end

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root
# @return {Boolean}
def is_complete_tree(root)
  q = [root]
  q.push root.left, root.right while root = q.shift
  q.count(nil) == q.size
end
"
0983,minimum-cost-for-tickets,"# frozen_string_literal: true

# 983. Minimum Cost For Tickets
# https://leetcode.com/problems/minimum-cost-for-tickets

=begin

You have planned some train traveling one year in advance. The days of the year in which you will travel are given as an integer array days. Each day is an integer from 1 to 365.

Train tickets are sold in three different ways:

a 1-day pass is sold for costs[0] dollars,
a 7-day pass is sold for costs[1] dollars, and
a 30-day pass is sold for costs[2] dollars.
The passes allow that many days of consecutive travel.

For example, if we get a 7-day pass on day 2, then we can travel for 7 days: 2, 3, 4, 5, 6, 7, and 8.
Return the minimum number of dollars you need to travel every day in the given list of days.

### Example 1:
Input: days = [1,4,6,7,8,20], costs = [2,7,15]
Output: 11
Explanation: For example, here is one way to buy passes that lets you travel your travel plan:
On day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1.
On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9.
On day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20.
In total, you spent $11 and covered all the days of your travel.

### Example 2:
Input: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]
Output: 17
Explanation: For example, here is one way to buy passes that lets you travel your travel plan:
On day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30.
On day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31.
In total, you spent $17 and covered all the days of your travel.

### Constraints:
1 <= days.length <= 365
1 <= days[i] <= 365
days is in strictly increasing order.
costs.length == 3
1 <= costs[i] <= 1000

=end

# Runtime 103 ms
# Memory 211.1 MB
# @param {Integer[]} days
# @param {Integer[]} costs
# @return {Integer}
def mincost_tickets(days, costs)
  is_travels = (days.last + 1).times.map { |day| days.include?(day) ? true : false }
  dp = [0] * (days.last + 1)

  (1..days.last).each do |day|
    dp[day] = if is_travels[day]
      dp[day] = [
        dp[day - 1] + costs[0],
        dp[[day - 7, 0].max] + costs[1],
        dp[[day - 30, 0].max] + costs[2]
      ].min
    else
      dp[day - 1]
    end
  end

  dp[days.last]
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_mincost_tickets < Test::Unit::TestCase
  def test_
    assert_equal 11, mincost_tickets([1, 4, 6, 7, 8, 20], [2, 7, 15])
    assert_equal 17, mincost_tickets([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 7, 15])
  end
end
"
0989,add-to-array-form-of-integer,"# frozen_string_literal: true

# 989. Add to Array-Form of Integer
# https://leetcode.com/problems/add-to-array-form-of-integer

# TODO: IMPROVE

# @param {Integer[]} num
# @param {Integer} k
# @return {Integer[]}
def add_to_array_form1(num, k)
  (num.join.to_i + k).digits.reverse
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_add_to_array_form < Test::Unit::TestCase
  def test_
    assert_equal [1, 2, 3, 4], add_to_array_form1([1, 2, 0, 0], 34)
    assert_equal [4, 5, 5], add_to_array_form1([2, 7, 4], 181)
    assert_equal [1, 0, 2, 1], add_to_array_form1([2, 1, 5], 806)
  end
end

require ""benchmark""

num = [1, 0, 2, 9, 5, 8, 7, 3, 6, 7, 9, 1, 3, 4, 6, 7, 8, 9, 5, 4, 3, 4, 6, 7, 7, 6, 5, 4, 3, 0, 1]
k = 458971347
Benchmark.bm do |x|
  x.report(""add_to_array_form1: "") { add_to_array_form1(num, k) }
end

# user     system      total        real
# add_to_array_form1:   0.000033   0.000025   0.000058 (  0.000054)
"
0990,satisfiability-of-equality-equations,"# frozen_string_literal: true

# 990. Satisfiability of Equality Equations
# https://leetcode.com/problems/satisfiability-of-equality-equations

# @param {String[]} equations
# @return {Boolean}
def equations_possible(equations)
  equations.join.tap { _1.tr! Regexp.last_match(1), Regexp.last_match(2) while _1 =~ /(.)==(?!\1)(.)/ } !~ /(.)!=\1/
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_equations_possible < Test::Unit::TestCase
  def test_
    assert_equal false, equations_possible([""a==b"", ""b!=a""])
    assert_equal true, equations_possible([""b==a"", ""a==b""])
  end
end
"
0994,rotting-oranges,"# frozen_string_literal: true

# 994. Rotting Oranges
# https://leetcode.com/problems/rotting-oranges
# Medium

=begin
You are given an m x n grid where each cell can have one of three values:

0 representing an empty cell,
1 representing a fresh orange, or
2 representing a rotten orange.
Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.

Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.

### Example 1:
Input: grid = [[2,1,1],[1,1,0],[0,1,1]]
Output: 4

### Example 2:
Input: grid = [[2,1,1],[0,1,1],[1,0,1]]
Output: -1
Explanation: The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.

### Example 3:
Input: grid = [[0,2]]
Output: 0
Explanation: Since there are already no fresh oranges at minute 0, the answer is just 0.

### Constraints:
* m == grid.length
* n == grid[i].length
* 1 <= m, n <= 10
* grid[i][j] is 0, 1, or 2.

=end

# @param {Integer[][]} grid
# @return {Integer}
def oranges_rotting(grid)
  row_count = grid.count
  column_count = grid[0].count

  queue = []
  fresh_count = 0

  row_count.times do |i|
    column_count.times do |j|
      queue << [i, j] if grid[i][j] == 2
      fresh_count += 1 if grid[i][j] == 1
    end
  end

  directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]
  level = 0

  while !queue.empty?
    level += 1
    queue.count.times do
      i, j = queue.shift
      directions.each do |d_i, d_j|
        if (0...row_count).cover?(i + d_i) &&
            (0...column_count).cover?(j + d_j) &&
            grid[i + d_i][j + d_j] == 1

          fresh_count -= 1
          grid[i + d_i][j + d_j] = 2
          queue << [i + d_i, j + d_j]
        end
      end
    end
  end

  fresh_count != 0 ? -1 : [level - 1, 0].max
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_oranges_rotting < Test::Unit::TestCase
  def test_
    assert_equal(4, oranges_rotting([[2, 1, 1], [1, 1, 0], [0, 1, 1]]))
    assert_equal(-1, oranges_rotting([[2, 1, 1], [0, 1, 1], [1, 0, 1]]))
    assert_equal(0, oranges_rotting([[0, 2]]))
  end
end
"
1004,max-consecutive-ones-iii,"# frozen_string_literal: true

# 1004. Max Consecutive Ones III
# https://leetcode.com/problems/max-consecutive-ones-iii
# Medium

=begin
Given a binary array nums and an integer k, return the maximum number of consecutive 1's in the array if you can flip at most k 0's.

Example 1:
Input: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2
Output: 6
Explanation: [1,1,1,0,0,1,1,1,1,1,1]
Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.

Example 2:
Input: nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3
Output: 10
Explanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.

Constraints:
1 <= nums.length <= 105
nums[i] is either 0 or 1.
0 <= k <= nums.length
=end

# @param {Integer[]} nums
# @param {Integer} k
# @return {Integer}
def longest_ones(nums, k)
  n = nums.size
  left = right = zeros = max = 0
  while right < n
    if nums[right] == 0
      zeros += 1
      while zeros > k
        if nums[left] == 0
          zeros -= 1
        end
        left += 1
      end
    end
    max = [max, right - left + 1].max
    right += 1
  end

  max
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_longest_ones < Test::Unit::TestCase
  def test_
    assert_equal 6, longest_ones([1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0], 2)
    assert_equal 10, longest_ones([0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1], 3)
  end
end
"
1011,capacity-to-ship-packages-within-d-days,"# frozen_string_literal: true

# 1011. Capacity To Ship Packages Within D Days
# https://leetcode.com/problems/capacity-to-ship-packages-within-d-days

# @param {Integer[]} weights
# @param {Integer} days
# @return {Integer}
def ship_within_days(weights, days)
  weight = weights.max
  sum = weights.sum

  while weight <= sum
    mid = (sum - weight) / 2 + weight
    cap = 0
    count = 1
    weights.each do |w|
      cap += w
      if cap > mid
        count += 1
        cap = w
      end
    end

    if count <= days
      sum = mid - 1
    else
      weight = mid + 1
    end
  end

  weight
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_ship_within_days < Test::Unit::TestCase
  def test_
    assert_equal 15, ship_within_days([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5)
    assert_equal 6, ship_within_days([3, 2, 2, 4, 1, 4], 3)
    assert_equal 3, ship_within_days([1, 2, 3, 1, 1], 4)
  end
end

# ********************#
#     Benchmark       #
# ********************#

require ""benchmark""

weights = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
days = 5
Benchmark.bm do |x|
  x.report(""ship_within_days: "") { ship_within_days(weights, days) }
end

# user     system      total        real
# ship_within_days:   0.000025   0.000006   0.000031 (  0.000023)
"
1020,number-of-enclaves,"# frozen_string_literal: true

# 1020. Number of Enclaves
# https://leetcode.com/problems/number-of-enclaves

=begin

You are given an m x n binary matrix grid, where 0 represents a sea cell and 1 represents a land cell.

A move consists of walking from one land cell to another adjacent (4-directionally) land cell or walking off the boundary of the grid.

Return the number of land cells in grid for which we cannot walk off the boundary of the grid in any number of moves.

### Example 1:
Input: grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]
Output: 3
Explanation: There are three 1s that are enclosed by 0s, and one 1 that is not enclosed because its on the boundary.

### Example 2:
Input: grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]
Output: 0
Explanation: All 1s are either on the boundary or can reach the boundary.

### Constraints:
* m == grid.length
* n == grid[i].length
* 1 <= m, n <= 500
* grid[i][j] is either 0 or 1.

=end

# Runtime 234 ms Beats 100%
# Memory 213.7 MB Beats 100%
# @param {Integer[][]} grid
# @return {Integer}
def num_enclaves(grid)
  m = grid.size
  n = grid[0].size
  q = []

  answer = 0
  (0...m).each do |i|
    (0...n).each do |j|
      answer += grid[i][j]
      if i * j == 0 || i == m - 1 || j == n - 1
        q.push([i, j])
      end
    end
  end

  while !q.empty?
    x, y = q.first
    q.shift

    if x < 0 || x == m || y < 0 || y == n || grid[x][y] != 1
      next
    end

    grid[x][y] = 0
    answer -= 1
    q.push([x + 1, y])
    q.push([x - 1, y])
    q.push([x, y + 1])
    q.push([x, y - 1])
  end

  answer
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_num_enclaves < Test::Unit::TestCase
  def test_
    assert_equal 3, num_enclaves([[0, 0, 0, 0], [1, 0, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0]])
    assert_equal 0, num_enclaves([[0, 1, 1, 0], [0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 0, 0]])
    assert_equal 3, num_enclaves([[0, 0, 0, 1, 1, 1, 0, 1, 0, 0], [1, 1, 0, 0, 0, 1, 0, 1, 1, 1], [0, 0, 0, 1, 1, 1, 0, 1, 0, 0], [0, 1, 1, 0, 0, 0, 1, 0, 1, 0], [0, 1, 1, 1, 1, 1, 0, 0, 1, 0], [0, 0, 1, 0, 1, 1, 1, 1, 0, 1], [0, 1, 1, 0, 0, 0, 1, 1, 1, 1], [0, 0, 1, 0, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0, 0, 0, 1]])
  end
end
"
1027,longest-arithmetic-subsequence,"# frozen_string_literal: true

# 1027. Longest Arithmetic Subsequence
# Medium
# https://leetcode.com/problems/longest-arithmetic-subsequence

=begin
Given an array nums of integers, return the length of the longest arithmetic subsequence in nums.

Note that:
  * A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.
  * A sequence seq is arithmetic if seq[i + 1] - seq[i] are all the same value (for 0 <= i < seq.length - 1).

Example 1:
Input: nums = [3,6,9,12]
Output: 4
Explanation:  The whole array is an arithmetic sequence with steps of length = 3.

Example 2:
Input: nums = [9,4,7,2,10]
Output: 3
Explanation:  The longest arithmetic subsequence is [4,7,10].

Example 3:
Input: nums = [20,1,15,3,10,5,8]
Output: 4
Explanation:  The longest arithmetic subsequence is [20,15,10,5].

Constraints:
  * 2 <= nums.length <= 1000
  * 0 <= nums[i] <= 500
=end

# @param {Integer[]} nums
# @return {Integer}
def longest_arith_seq_length(arr)
  tab = Array.new(arr.length) { |h, k| Hash.new(1) }

  (1...arr.length).each do |i|
    (0...i).each do |j|
      a, b = arr[i], arr[j]
      diff = b - a

      tab[i][diff] = tab[j][diff] + 1
    end
  end

  max = 0

  tab.each do |hash|
    max_val = hash.values.max || 0
    max = max_val if max_val > max
  end

  max
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_longest_arith_seq_length < Test::Unit::TestCase
  def test_
    assert_equal 4, longest_arith_seq_length([3, 6, 9, 12])
    assert_equal 3, longest_arith_seq_length([9, 4, 7, 2, 10])
    assert_equal 4, longest_arith_seq_length([20, 1, 15, 3, 10, 5, 8])
  end
end
"
1035,uncrossed-lines,"# frozen_string_literal: true

# 1035. Uncrossed Lines
# https://leetcode.com/problems/uncrossed-lines
# Medium

=begin
You are given two integer arrays nums1 and nums2. We write the integers of nums1 and nums2 (in the order they are given) on two separate horizontal lines.

We may draw connecting lines: a straight line connecting two numbers nums1[i] and nums2[j] such that:

nums1[i] == nums2[j], and
the line we draw does not intersect any other connecting (non-horizontal) line.
Note that a connecting line cannot intersect even at the endpoints (i.e., each number can only belong to one connecting line).

Return the maximum number of connecting lines we can draw in this way.

Example 1:
Input: nums1 = [1,4,2], nums2 = [1,2,4]
Output: 2
Explanation: We can draw 2 uncrossed lines as in the diagram.
We cannot draw 3 uncrossed lines, because the line from nums1[1] = 4 to nums2[2] = 4 will intersect the line from nums1[2]=2 to nums2[1]=2.

Example 2:
Input: nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]
Output: 3

Example 3:
Input: nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1]
Output: 2

Constraints:
1 <= nums1.length, nums2.length <= 500
1 <= nums1[i], nums2[j] <= 2000
=end

# @param {Integer[]} nums1
# @param {Integer[]} nums2
# @return {Integer}
def max_uncrossed_lines(nums1, nums2)
  r = Array.new(2) { [0] * (nums2.size + 1) }
  for x in nums1
    for y, j in nums2.each_with_index
      r[1][j + 1] = (x == y) ?
          1 + r[0][j] :
          [r[0][j + 1], r[1][j]].max
    end
    r.reverse!
  end
  r.first.last
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_max_uncrossed_lines < Test::Unit::TestCase
  def test_
    assert_equal 2, max_uncrossed_lines([1, 4, 2], [1, 2, 4])
    assert_equal 3, max_uncrossed_lines([2, 5, 1, 2, 5], [10, 5, 2, 1, 5, 2])
    assert_equal 2, max_uncrossed_lines([1, 3, 7, 1, 7, 5], [1, 9, 2, 5, 1])
  end
end
"
1046,last-stone-weight,"# frozen_string_literal: true

# 1046. Last Stone Weight
# https://leetcode.com/problems/last-stone-weight

=begin

You are given an array of integers stones where stones[i] is the weight of the ith stone.

We are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights x and y with x <= y. The result of this smash is:

If x == y, both stones are destroyed, and
If x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.
At the end of the game, there is at most one stone left.

Return the weight of the last remaining stone. If there are no stones left, return 0.

### Example 1:
Input: stones = [2,7,4,1,8,1]
Output: 1
Explanation:
We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,
we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,
we combine 2 and 1 to get 1 so the array converts to [1,1,1] then,
we combine 1 and 1 to get 0 so the array converts to [1] then that's the value of the last stone.

### Example 2:
Input: stones = [1]
Output: 1

### Constraints:
* 1 <= stones.length <= 30
* 1 <= stones[i] <= 1000

=end

# @param {Integer[]} stones
# @return {Integer}
def last_stone_weight(stones)
  while stones.size > 1
    stones.sort!
    a, b = stones.pop(2)
    stones.push(b - a) if b - a > 0
  end
  stones.empty? ? 0 : stones.first
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_last_stone_weight < Test::Unit::TestCase
  def test_
    assert_equal 1, last_stone_weight([2, 7, 4, 1, 8, 1])
    assert_equal 1, last_stone_weight([1])
  end
end
"
1048,longest-string-chain,"# frozen_string_literal: true

# 1048. Longest String Chain
# Medium
# https://leetcode.com/problems/longest-string-chain

=begin
You are given an array of words where each word consists of lowercase English letters.
wordA is a predecessor of wordB if and only if we can insert exactly one letter anywhere in wordA without changing the order of the other characters to make it equal to wordB.
For example, ""abc"" is a predecessor of ""abac"", while ""cba"" is not a predecessor of ""bcad"".
A word chain is a sequence of words [word1, word2, ..., wordk] with k >= 1, where word1 is a predecessor of word2, word2 is a predecessor of word3, and so on. A single word is trivially a word chain with k == 1.
Return the length of the longest possible word chain with words chosen from the given list of words.

Example 1:
Input: words = [""a"",""b"",""ba"",""bca"",""bda"",""bdca""]
Output: 4
Explanation: One of the longest word chains is [""a"",""ba"",""bda"",""bdca""].

Example 2:
Input: words = [""xbc"",""pcxbcf"",""xb"",""cxbc"",""pcxbc""]
Output: 5
Explanation: All the words can be put in a word chain [""xb"", ""xbc"", ""cxbc"", ""pcxbc"", ""pcxbcf""].

Example 3:
Input: words = [""abcd"",""dbqca""]
Output: 1
Explanation: The trivial word chain [""abcd""] is one of the longest word chains.
[""abcd"",""dbqca""] is not a valid word chain because the ordering of the letters is changed.

Constraints:
* 1 <= words.length <= 1000
* 1 <= words[i].length <= 16
* words[i] only consists of lowercase English letters.
=end

# @param {String[]} words
# @return {Integer}
def longest_str_chain(words)
  dp = {}

  words.sort_by { |word| word.length }.each do |word|
    temp = [0]
    word.length.times do |i|
      if dp[word[0...i] + word[i + 1..-1]]
        temp << dp[word[0...i] + word[i + 1..-1]]
      end
      dp[word] = temp.max + 1
    end
  end

  dp.values.max
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_longest_str_chain < Test::Unit::TestCase
  def test_
    assert_equal 4, longest_str_chain([""a"", ""b"", ""ba"", ""bca"", ""bda"", ""bdca""])
    assert_equal 5, longest_str_chain([""xbc"", ""pcxbcf"", ""xb"", ""cxbc"", ""pcxbc""])
    assert_equal 1, longest_str_chain([""abcd"", ""dbqca""])
  end
end
"
1071,greatest-common-divisor-of-strings,"# frozen_string_literal: true

# 1071. Greatest Common Divisor of Strings
# https://leetcode.com/problems/greatest-common-divisor-of-strings
# Easy

# @param {String} str1
# @param {String} str2
# @return {String}
def gcd_of_strings(str1, str2)
  return str1 if str1 == str2

  if str1.size >= str2.size
    long = str1
    short = str2
  else
    long = str2
    short = str1
  end
  len = short.size
  return """" unless short == long[0...len]

  gcd_of_strings(short, long[len..])
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_gcd_of_strings < Test::Unit::TestCase
  def test_
    assert_equal ""ABC"", gcd_of_strings(""ABCABC"", ""ABC"")
    assert_equal ""AB"", gcd_of_strings(""ABABAB"", ""ABAB"")
    assert_equal """", gcd_of_strings(""LEET"", ""CODE"")
  end
end
"
1091,shortest-path-in-binary-matrix,"# frozen_string_literal: true

# https://leetcode.com/problems/shortest-path-in-binary-matrix
# 1091. Shortest Path in Binary Matrix
# Medium

=begin
Given an n x n binary matrix grid, return the length of the shortest clear path in the matrix. If there is no clear path, return -1.

A clear path in a binary matrix is a path from the top-left cell (i.e., (0, 0)) to the bottom-right cell (i.e., (n - 1, n - 1)) such that:

* All the visited cells of the path are 0.
* All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).
The length of a clear path is the number of visited cells of this path.

Example 1:
Input: grid = [[0,1],[1,0]]
Output: 2

Example 2:
Input: grid = [[0,0,0],[1,1,0],[1,1,0]]
Output: 4

Example 3:
Input: grid = [[1,0,0],[1,1,0],[1,1,0]]
Output: -1

Constraints:
* n == grid.length
* n == grid[i].length
* 1 <= n <= 100
* grid[i][j] is 0 or 1
=end

# @param {Integer[][]} grid
# @return {Integer}
def shortest_path_binary_matrix(grid)
  n = grid.count
  return -1 if grid[0][0] > 0 || grid[n - 1][n - 1] > 0

  q = [[0, 0, 1]]
  grid[0][0] = 1

  q.each do |i, j, d|
    return d if i == n - 1 && j == n - 1

    [
      [i - 1, j - 1], [i - 1, j],
      [i - 1, j + 1], [i, j - 1],
      [i, j + 1], [i + 1, j - 1],
      [i + 1, j], [i + 1, j + 1]
    ].each do |x, y|
      if 0 <= x && x < n && 0 <= y && y < n && grid[x][y] == 0
        grid[x][y] = 1
        q << [x, y, d + 1]
      end
    end
  end

  -1
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_shortest_path_binary_matrix < Test::Unit::TestCase
  def test_
    assert_equal(2, shortest_path_binary_matrix([[0, 1], [1, 0]]))
    assert_equal(4, shortest_path_binary_matrix([[0, 0, 0], [1, 1, 0], [1, 1, 0]]))
    assert_equal(-1, shortest_path_binary_matrix([[1, 0, 0], [1, 1, 0], [1, 1, 0]]))
  end
end
"
1125,smallest-sufficient-team,"# frozen_string_literal: true

# 1125. Smallest Sufficient Team
# Hard
# https://leetcode.com/problems/smallest-sufficient-team

=begin
In a project, you have a list of required skills req_skills, and a list of people. The ith person people[i] contains a list of skills that the person has.
Consider a sufficient team: a set of people such that for every required skill in req_skills, there is at least one person in the team who has that skill. We can represent these teams by the index of each person.
* For example, team = [0, 1, 3] represents the people with skills people[0], people[1], and people[3].
Return any sufficient team of the smallest possible size, represented by the index of each person. You may return the answer in any order.
It is guaranteed an answer exists.

Example 1:
Input: req_skills = [""java"",""nodejs"",""reactjs""], people = [[""java""],[""nodejs""],[""nodejs"",""reactjs""]]
Output: [0,2]

Example 2:
Input: req_skills = [""algorithms"",""math"",""java"",""reactjs"",""csharp"",""aws""], people = [[""algorithms"",""math"",""java""],[""algorithms"",""math"",""reactjs""],[""java"",""csharp"",""aws""],[""reactjs"",""csharp""],[""csharp"",""math""],[""aws"",""java""]]
Output: [1,2]

Constraints:
* 1 <= req_skills.length <= 16
* 1 <= req_skills[i].length <= 16
* req_skills[i] consists of lowercase English letters.
* All the strings of req_skills are unique.
* 1 <= people.length <= 60
* 0 <= people[i].length <= 16
* 1 <= people[i][j].length <= 16
* people[i][j] consists of lowercase English letters.
* All the strings of people[i] are unique.
* Every skill in people[i] is a skill in req_skills.
* It is guaranteed a sufficient team exists.
=end

# @param {String[]} req_skills
# @param {String[][]} people
# @return {Integer[]}
def smallest_sufficient_team(req_skills, people)
  n = req_skills.size
  skill_map, dp = {}, Array.new(1 << n, [n + 1])

  req_skills.each_with_index { |rs, idx| skill_map[rs] = idx }

  people = people.map { |p| p.inject(0) { |acc, skill| acc | (1 << skill_map[skill]) } }

  dp[0] = [0, []]

  people.each_with_index do |skills, p|
    ((1 << req_skills.length) - 1).downto(0) do |i|
      nex = i | skills
      if dp[nex][0] > dp[i][0] + 1
        dp[nex] = [dp[i][0] + 1, dp[i][1] + [p]]
      end
    end
  end

  dp[(1 << req_skills.size) - 1][1]
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_smallest_sufficient_team < Test::Unit::TestCase
  def test_
    assert_equal [0, 2], smallest_sufficient_team([""java"", ""nodejs"", ""reactjs""], [[""java""], [""nodejs""], [""nodejs"", ""reactjs""]])
    assert_equal [1, 2], smallest_sufficient_team([""algorithms"", ""math"", ""java"", ""reactjs"", ""csharp"", ""aws""], [[""algorithms"", ""math"", ""java""], [""algorithms"", ""math"", ""reactjs""], [""java"", ""csharp"", ""aws""], [""reactjs"", ""csharp""], [""csharp"", ""math""], [""aws"", ""java""]])
  end
end
"
1129,shortest-path-with-alternating-colors,"# frozen_string_literal: true

# 1129. Shortest Path with Alternating Colors
# https://leetcode.com/problems/shortest-path-with-alternating-colors

# @param {Integer} n
# @param {Integer[][]} red_edges
# @param {Integer[][]} blue_edges
# @return {Integer[]}
def shortest_alternating_paths(n, red_edges, blue_edges)
  Graph.new(n, red_edges, blue_edges).shortest_alternating_paths
end

class Graph
  def initialize(n, red_edges, blue_edges)
    @n = n
    @graph_data = Array.new(@n) { { r: [], b: [] } }
    red_edges.each do |(from, to)|
      @graph_data[from][:r] << to
    end
    blue_edges.each do |(from, to)|
      @graph_data[from][:b] << to
    end
  end

  def shortest_alternating_paths
    queue = [[0, nil, 0]]
    visited_edges = {}
    result = Array.new(n) { -1 }

    while (node, parent_color, length = queue.shift)
      result[node] = length if result[node] == -1

      (%i(r b) - [parent_color]).each do |color|
        graph_data[node][color].each do |next_node|
          unless visited_edges.dig(node, next_node, color)
            visited_edges[node] ||= {}
            visited_edges[node][next_node] ||= {}
            visited_edges[node][next_node][color] = true
            queue << [next_node, color, length + 1]
          end
        end
      end
    end
    result
  end

  private
    attr_reader :graph_data, :n
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_shortest_alternating_paths < Test::Unit::TestCase
  def test_
    assert_equal [0, 1, -1], shortest_alternating_paths(3, [[0, 1], [1, 2]], [])
    assert_equal [0, 1, -1], shortest_alternating_paths(3, [[0, 1]], [[2, 1]])
  end
end
"
1137,n-th-tribonacci-number,"# frozen_string_literal: true

# 1137. N-th Tribonacci Number
# https://leetcode.com/problems/n-th-tribonacci-number
# Easy

=begin
The Tribonacci sequence Tn is defined as follows:

T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.

Given n, return the value of Tn.

Example 1:
Input: n = 4
Output: 4
Explanation:
T_3 = 0 + 1 + 1 = 2
T_4 = 1 + 1 + 2 = 4

Example 2:
Input: n = 25
Output: 1389537

Constraints:
0 <= n <= 37
The answer is guaranteed to fit within a 32-bit integer, ie. answer <= 2^31 - 1.
=end

# @param {Integer} n
# @return {Integer}
def tribonacci(n)
  arr = [0, 1, 1]

  arr.size.upto(n) { arr << arr.last(3).sum }

  arr[n]
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_tribonacci < Test::Unit::TestCase
  def test_
    assert_equal 4, tribonacci(4)
    assert_equal 1389537, tribonacci(25)
  end
end
"
1140,stone-game-ii,"# frozen_string_literal: true

# 1140. Stone Game II
# https://leetcode.com/problems/stone-game-ii/
# Medium

=begin
Alice and Bob continue their games with piles of stones.  There are a number of piles arranged in a row, and each pile has a positive integer number of stones piles[i].  The objective of the game is to end with the most stones.

Alice and Bob take turns, with Alice starting first.  Initially, M = 1.

On each player's turn, that player can take all the stones in the first X remaining piles, where 1 <= X <= 2M.  Then, we set M = max(M, X).

The game continues until all the stones have been taken.

Assuming Alice and Bob play optimally, return the maximum number of stones Alice can get.

Example 1:
Input: piles = [2,7,9,4,4]
Output: 10
Explanation:  If Alice takes one pile at the beginning, Bob takes two piles, then Alice takes 2 piles again. Alice can get 2 + 4 + 4 = 10 piles in total. If Alice takes two piles at the beginning, then Bob can take all three piles left. In this case, Alice get 2 + 7 = 9 piles in total. So we return 10 since it's larger.

Example 2:
Input: piles = [1,2,3,4,5,100]
Output: 104

Constraints:
1 <= piles.length <= 100
1 <= piles[i] <= 104
=end

# @param {Integer[]} piles
# @return {Integer}
def min(a, b)
  a < b ? a : b
end

def max(a, b)
  a > b ? a : b
end

def stone_game_ii(piles)
  ps = piles.reduce([0]) { |arr, num| arr << arr[-1] + num }
  z = ps.size
  game = Array.new(z) do |i|
    remaining_stones = ps[-1] - ps[i]
    Hash.new do |h, m|
      min_best_response = (i + 1..min(i + 2 * m, z)).map { game[_1][max(m, _1 - i)] }.min
      h[m] = remaining_stones - min_best_response
    end
  end << -> _ { 0 }

  game[0][1]
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_stone_game_ii < Test::Unit::TestCase
  def test_
    assert_equal 10, stone_game_ii([2, 7, 9, 4, 4])
    assert_equal 104, stone_game_ii([1, 2, 3, 4, 5, 100])
  end
end
"
1143,longest-common-subsequence,"# frozen_string_literal: true

# 1143. Longest Common Subsequence
# https://leetcode.com/problems/longest-common-subsequence
# Medium

=begin
Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.

A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.

For example, ""ace"" is a subsequence of ""abcde"".
A common subsequence of two strings is a subsequence that is common to both strings.

Example 1:
Input: text1 = ""abcde"", text2 = ""ace""
Output: 3
Explanation: The longest common subsequence is ""ace"" and its length is 3.

Example 2:
Input: text1 = ""abc"", text2 = ""abc""
Output: 3
Explanation: The longest common subsequence is ""abc"" and its length is 3.

Example 3:
Input: text1 = ""abc"", text2 = ""def""
Output: 0
Explanation: There is no such common subsequence, so the result is 0.

Constraints:
1 <= text1.length, text2.length <= 1000
text1 and text2 consist of only lowercase English characters.
=end

# @param {String} text1
# @param {String} text2
# @return {Integer}
def longest_common_subsequence(text1, text2)
  indices = {}
  text1.each_char.with_index { |char1, index1| (indices[char1] ||= []) << index1 }
  indices.transform_values!(&:reverse)

  result = []
  text2.each_char do |char2|
    indices[char2]&.each do |index1|
      index = result.bsearch_index { |val| val >= index1 }

      if index.nil?
        result << index1
      elsif result[index] > index1
        result[index] = index1
      end
    end
  end

  result.size
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_longest_common_subsequence < Test::Unit::TestCase
  def test_
    assert_equal 3, longest_common_subsequence(""abcde"", ""ace"")
    assert_equal 3, longest_common_subsequence(""abc"", ""abc"")
    assert_equal 0, longest_common_subsequence(""abc"", ""def"")
  end
end
"
1146,snapshot-array,"# frozen_string_literal: true

# https://leetcode.com/problems/snapshot-array/
# 1146. Snapshot Array
# Medium

=begin
Implement a SnapshotArray that supports the following interface:
* SnapshotArray(int length) initializes an array-like data structure with the given length. Initially, each element equals 0.
* void set(index, val) sets the element at the given index to be equal to val.
* int snap() takes a snapshot of the array and returns the snap_id: the total number of times we called snap() minus 1.
* int get(index, snap_id) returns the value at the given index, at the time we took the snapshot with the given snap_id

Example 1:
Input: [""SnapshotArray"",""set"",""snap"",""set"",""get""]
[[3],[0,5],[],[0,6],[0,0]]
Output: [null,null,0,null,5]
Explanation:
SnapshotArray snapshotArr = new SnapshotArray(3); // set the length to be 3
snapshotArr.set(0,5);  // Set array[0] = 5
snapshotArr.snap();  // Take a snapshot, return snap_id = 0
snapshotArr.set(0,6);
snapshotArr.get(0,0);  // Get the value of array[0] with snap_id = 0, return 5

Constraints:
* 1 <= length <= 5 * 104
* 0 <= index < length
* 0 <= val <= 109
* 0 <= snap_id < (the total number of times we call snap())
* At most 5 * 104 calls will be made to set, snap, and get.
=end

class SnapshotArray
=begin
  :type length: Integer
=end
  def initialize(length)
    @current_snapshot_id = 0
    @arr = Array.new(length) { [[-1, 0]] }
  end


=begin
  :type index: Integer
  :type val: Integer
  :rtype: Void
=end
  def set(index, val)
    @arr[index] << [@current_snapshot_id, val]
  end


=begin
  :rtype: Integer
=end
  def snap
    @current_snapshot_id += 1
    @current_snapshot_id - 1
  end


=begin
  :type index: Integer
  :type snap_id: Integer
  :rtype: Integer
=end
  def get(index, snap_id)
    snap_index = (@arr[index].bsearch_index { |saved_snapshot_id, _| saved_snapshot_id > snap_id } || @arr[index].size) - 1
    @arr[index][snap_index].last
  end
end

# Your SnapshotArray object will be instantiated and called as such:
# obj = SnapshotArray.new(length)
# obj.set(index, val)
# param_2 = obj.snap()
# param_3 = obj.get(index, snap_id)
"
1155,number-of-dice-rolls-with-target-sum,"# frozen_string_literal: true

# 1155. Number of Dice Rolls With Target Sum
# https://leetcode.com/problems/number-of-dice-rolls-with-target-sum

# @param {Integer} n
# @param {Integer} k
# @param {Integer} target
# @return {Integer}
def num_rolls_to_target(n, k, target)
  dp = Array.new(n).map { |x| Array.new(target + 1, 0) }

  # fill first row
  (1..target).each do |cell|
    dp[0][cell] = 1 if k >= cell
  end

  # fill the rest rows

  (1...n).each do |row|
    (1..target).each do |cell|
      (1..k).each do |i|
        dp[row][cell] += dp[row - 1][cell - i] if cell - i >= 0
      end
    end
  end

  dp[n - 1][target] % (10**9 + 7)
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_num_rolls_to_target < Test::Unit::TestCase
  def test_
    assert_equal 1, num_rolls_to_target(1, 6, 3)
    assert_equal 6, num_rolls_to_target(2, 6, 7)
    assert_equal 222616187, num_rolls_to_target(30, 30, 500)
  end
end
"
1160,find-words-that-can-be-formed-by-characters,"# frozen_string_literal: true

# 1160. Find Words That Can Be Formed by Characters
# Easy
# https://leetcode.com/problems/find-words-that-can-be-formed-by-characters

=begin
You are given an array of strings words and a string chars.
A string is good if it can be formed by characters from chars (each character can only be used once).
Return the sum of lengths of all good strings in words.

Example 1:
Input: words = [""cat"",""bt"",""hat"",""tree""], chars = ""atach""
Output: 6
Explanation: The strings that can be formed are ""cat"" and ""hat"" so the answer is 3 + 3 = 6.

Example 2:
Input: words = [""hello"",""world"",""leetcode""], chars = ""welldonehoneyr""
Output: 10
Explanation: The strings that can be formed are ""hello"" and ""world"" so the answer is 5 + 5 = 10.

Constraints:
1 <= words.length <= 1000
1 <= words[i].length, chars.length <= 100
words[i] and chars consist of lowercase English letters.
=end

# @param {String[]} words
# @param {String} chars
# @return {Integer}
def count_characters(words, chars)
  char_hash = {}
  chars.each_char do |char|
    char_hash[char] ||= 0
    char_hash[char] += 1
  end

  answer = 0
  words.each do |word|
    char_hash_clone = char_hash.clone

    has_all = true
    word.each_char do |c|
      if char_hash_clone[c] && (char_hash_clone[c] > 0)
        char_hash_clone[c] -= 1
      else
        has_all = false
        break
      end
    end

    if has_all
      answer += word.size
    end
  end

  answer
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_count_characters < Test::Unit::TestCase
  def test_
    assert_equal 6, count_characters([""cat"", ""bt"", ""hat"", ""tree""], ""atach"")
    assert_equal 10, count_characters([""hello"", ""world"", ""leetcode""], ""welldonehoneyr"")
  end
end
"
1161,maximum-level-sum-of-a-binary-tree,"# frozen_string_literal: true

# 1161. Maximum Level Sum of a Binary Tree
# https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree
# Medium

=begin
Given the root of a binary tree, the level of its root is 1, the level of its children is 2, and so on.

Return the smallest level x such that the sum of all the values of nodes at level x is maximal.

Example 1:
Input: root = [1,7,0,7,-8,null,null]
Output: 2
Explanation:
Level 1 sum = 1.
Level 2 sum = 7 + 0 = 7.
Level 3 sum = 7 + -8 = -1.
So we return the level with the maximum sum which is level 2.

Example 2:
Input: root = [989,null,10250,98693,-89388,null,null,null,-32127]
Output: 2

Constraints:
The number of nodes in the tree is in the range [1, 104].
-105 <= Node.val <= 105
=end

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root
# @return {Integer}
def max_level_sum(root)
  return 0 if root.nil?
  queue = [root]
  max_sum = -1000000
  max_level = level = 0
  while queue.any?
    size = queue.size
    sum = 0
    level += 1
    size.times {
      node = queue.shift
      sum += node.val
      queue.push(node.left) if node.left
      queue.push(node.right) if node.right
    }
    if max_sum < sum
      max_sum = sum
      max_level = level
    end
  end
  max_level
end
"
1162,as-far-from-land-as-possible,"# frozen_string_literal: true

# 1162. As Far from Land as Possible
# https://leetcode.com/problems/as-far-from-land-as-possible

# @param {Integer[][]} grid
# @return {Integer}
def max_distance(grid)
  queue = []
  grid.each_with_index { |row, i|
    row.each_with_index { |cell, j|
      queue << [i, j] if cell == 1
    }
  }
  n = grid.size
  hop_count = -1
  until queue.empty?
    queue.size.times {
      i, j = queue.shift
      [[i + 1, j], [i - 1, j], [i, j + 1], [i, j - 1]].each { |ii, jj|
        next if !ii.between?(0, n - 1) || !jj.between?(0, n - 1) || !grid[ii][jj].zero?
        queue << [ii, jj]
        grid[ii][jj] = 2
      }
    }
    hop_count += 1
  end
  hop_count.zero? ? -1 : hop_count
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_max_distance < Test::Unit::TestCase
  def test_
    assert_equal 2, max_distance([[1, 0, 1], [0, 0, 0], [1, 0, 1]])
    assert_equal 4, max_distance([[1, 0, 0], [0, 0, 0], [0, 0, 0]])
  end
end
"
1187,make-array-strictly-increasing,"# frozen_string_literal: true

# https://leetcode.com/problems/make-array-strictly-increasing
# 1187. Make Array Strictly Increasing
# Hard

=begin
Given two integer arrays arr1 and arr2, return the minimum number of operations (possibly zero) needed to make arr1 strictly increasing.

In one operation, you can choose two indices 0 <= i < arr1.length and 0 <= j < arr2.length and do the assignment arr1[i] = arr2[j].

If there is no way to make arr1 strictly increasing, return -1.

Example 1:
Input: arr1 = [1,5,3,6,7], arr2 = [1,3,2,4]
Output: 1
Explanation: Replace 5 with 2, then arr1 = [1, 2, 3, 6, 7].

Example 2:
Input: arr1 = [1,5,3,6,7], arr2 = [4,3,1]
Output: 2
Explanation: Replace 5 with 3 and then replace 3 with 4. arr1 = [1, 3, 4, 6, 7].

Example 3:
Input: arr1 = [1,5,3,6,7], arr2 = [1,6,3,3]
Output: -1
Explanation: You can't make arr1 strictly increasing.

Constraints:
* 1 <= arr1.length, arr2.length <= 2000
* 0 <= arr1[i], arr2[i] <= 10^9
=end

# @param {Integer[]} arr1
# @param {Integer[]} arr2
# @return {Integer}
def make_array_increasing(arr1, arr2)
  @arr1 = arr1
  @arr2 = arr2.uniq.sort
  @memo = {}

  res = swaps(0, -1)
  res == Float::INFINITY ? -1 : res
end

def swaps(i, val)
  return 0 if i == @arr1.length
  return @memo[[i, val]] if @memo[[i, val]]

  options = []

  if @arr1[i] > val
    options << swaps(i + 1, @arr1[i])
  end

  j = @arr2.bsearch_index { |num| num > val }

  options << (j ? swaps(i + 1, @arr2[j]) + 1 : Float::INFINITY)

  @memo[[i, val]] = options.min
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_make_array_increasing < Test::Unit::TestCase
  def test_
    assert_equal 1, make_array_increasing([1, 5, 3, 6, 7], [1, 3, 2, 4])
    assert_equal 2, make_array_increasing([1, 5, 3, 6, 7], [4, 3, 1])
    assert_equal(-1, make_array_increasing([1, 5, 3, 6, 7], [1, 6, 3, 3]))
  end
end
"
1203,sort-items-by-groups-respecting-dependencies,"# frozen_string_literal: true

# 1203. Sort Items by Groups Respecting Dependencies
# Hard
# https://leetcode.com/problems/sort-items-by-groups-respecting-dependencies

=begin
There are n items each belonging to zero or one of m groups where group[i] is the group that the i-th item belongs to and it's equal to -1 if the i-th item belongs to no group. The items and the groups are zero indexed. A group can have no item belonging to it.
Return a sorted list of the items such that:
The items that belong to the same group are next to each other in the sorted list.
There are some relations between these items where beforeItems[i] is a list containing all the items that should come before the i-th item in the sorted array (to the left of the i-th item).
Return any solution if there is more than one solution and return an empty list if there is no solution.

Example 1:
Input: n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]]
Output: [6,3,4,1,5,2,0,7]

Example 2:
Input: n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]]
Output: []
Explanation: This is the same as example 1 except that 4 needs to be before 6 in the sorted list.

Constraints:
* 1 <= m <= n <= 3 * 104
* group.length == beforeItems.length == n
* -1 <= group[i] <= m - 1
* 0 <= beforeItems[i].length <= n - 1
* 0 <= beforeItems[i][j] <= n - 1
* i != beforeItems[i][j]
* beforeItems[i] does not contain duplicates elements.
=end

# @param {Integer} n
# @param {Integer} m
# @param {Integer[]} group
# @param {Integer[][]} before_items
# @return {Integer[]}
def sort_items(n, m, group, before_items)
  @before_items = before_items
  @items_of_groups, @items_group = define_groups_for_minus_ones(m, group)

  @checked_group = {}
  @checked_item = {}
  @result = []

  @items_of_groups.each_with_index do |subgroup, index|
    next if @checked_group[index]
    @checking_group = Set.new
    return [] unless check_subgroup(subgroup, index)
  end

  rearrange_result
end

def rearrange_result
  @result.reverse.group_by { |item| @items_group[item] }.values.reverse.flat_map(&:reverse)
end

def define_groups_for_minus_ones(m, group)
  items_of_groups = []

  group_id = m
  items_group = group.map!.with_index do |item_group, item|
            if item_group == -1
              (items_of_groups[group_id] ||= []) << item
              group_id += 1
              group_id - 1
            else
              (items_of_groups[item_group] ||= []) << item
              item_group
            end
          end

  items_of_groups.map! { |main_group| main_group ? main_group.to_set : Set.new }

  [items_of_groups, items_group]
end

def check_subgroup(subgroup, group_index)
  return true if @checked_group[group_index]

  return false if @checking_group.include? group_index
  @checking_group << group_index

  subgroup.each do |item|
    checking_items = Set.new
    return false unless check_item(item, group_index, checking_items)
  end
  @checking_group.delete(group_index)

  @checked_group[group_index] = true
end

def check_item(item, group_index, checking_items)
  return false if checking_items.include? item
  checking_items << item

  return true if @checked_item[item]

  @before_items[item].each do |next_item|
    next_group_index = @items_group[next_item]

    if next_group_index == group_index
      return false unless check_item(next_item, group_index, checking_items)
    else
      return false unless check_subgroup(@items_of_groups[next_group_index], next_group_index)
    end
  end
  @result << item

  @checked_item[item] = true
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_sort_items < Test::Unit::TestCase
  def test_
    assert_equal [6, 3, 4, 1, 5, 2, 0, 7].sort, sort_items(8, 2,  [-1, -1, 1, 0, 0, 1, 0, -1], [[], [6], [5], [6], [3, 6], [], [], []]).sort
    assert_equal [], sort_items(8, 2,   [-1, -1, 1, 0, 0, 1, 0, -1], [[], [6], [5], [6], [3], [], [4], []])
  end
end
"
1207,unique-number-of-occurrences,"# frozen_string_literal: true

# 1207. Unique Number of Occurrences
# https://leetcode.com/problems/unique-number-of-occurrences
# Easy

=begin
Given an array of integers arr, return true if the number of occurrences of each value in the array is unique or false otherwise.

Example 1:
Input: arr = [1,2,2,1,1,3]
Output: true
Explanation: The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences.

Example 2:
Input: arr = [1,2]
Output: false

Example 3:
Input: arr = [-3,0,1,-3,1,1,1,-3,10,0]
Output: true

Constraints:
1 <= arr.length <= 1000
-1000 <= arr[i] <= 1000
=end

# @param {Integer[]} arr
# @return {Boolean}
def unique_occurrences(arr)
  !arr.tally.values.uniq!
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_unique_occurrences < Test::Unit::TestCase
  def test_
    assert_equal true, unique_occurrences([1, 2, 2, 1, 1, 3])
    assert_equal false, unique_occurrences([1, 2])
    assert_equal true, unique_occurrences([-3, 0, 1, -3, 1, 1, 1, -3, 10, 0])
  end
end
"
1218,longest-arithmetic-subsequence-of-given-difference,"# frozen_string_literal: true

# 1218. Longest Arithmetic Subsequence of Given Difference
# Medium
# https://leetcode.com/problems/longest-arithmetic-subsequence-of-given-difference

=begin
Given an integer array arr and an integer difference, return the length of the longest subsequence in arr which is an arithmetic sequence such that the difference between adjacent elements in the subsequence equals difference.
A subsequence is a sequence that can be derived from arr by deleting some or no elements without changing the order of the remaining elements.

Example 1:
Input: arr = [1,2,3,4], difference = 1
Output: 4
Explanation: The longest arithmetic subsequence is [1,2,3,4].

Example 2:
Input: arr = [1,3,5,7], difference = 1
Output: 1
Explanation: The longest arithmetic subsequence is any single element.

Example 3:
Input: arr = [1,5,7,8,5,3,4,2,1], difference = -2
Output: 4
Explanation: The longest arithmetic subsequence is [7,5,3,1].

Constraints:
* 1 <= arr.length <= 105
* -104 <= arr[i], difference <= 104
=end

# @param {Integer[]} arr
# @param {Integer} difference
# @return {Integer}
def longest_subsequence(arr, difference)
  counts = Hash.new(0)
  arr.reduce(0) do |max_size, num|
    counts[num] = counts[num - difference] + 1
    [max_size, counts[num]].max
  end
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_longest_subsequence < Test::Unit::TestCase
  def test_
    assert_equal 4, longest_subsequence([1, 2, 3, 4], 1)
    assert_equal 1, longest_subsequence([1, 3, 5, 7], 1)
    assert_equal 4, longest_subsequence([1, 5, 7, 8, 5, 3, 4, 2, 1], -2)
  end
end
"
1220,count-vowels-permutation,"# frozen_string_literal: true

# 1220. Count Vowels Permutation
# Hard
# https://leetcode.com/problems/count-vowels-permutation

=begin
Given an integer n, your task is to count how many strings of length n can be formed under the following rules:

Each character is a lower case vowel ('a', 'e', 'i', 'o', 'u')
Each vowel 'a' may only be followed by an 'e'.
Each vowel 'e' may only be followed by an 'a' or an 'i'.
Each vowel 'i' may not be followed by another 'i'.
Each vowel 'o' may only be followed by an 'i' or a 'u'.
Each vowel 'u' may only be followed by an 'a'.
Since the answer may be too large, return it modulo 10^9 + 7.

Example 1:
Input: n = 1
Output: 5
Explanation: All possible strings are: ""a"", ""e"", ""i"" , ""o"" and ""u"".

Example 2:
Input: n = 2
Output: 10
Explanation: All possible strings are: ""ae"", ""ea"", ""ei"", ""ia"", ""ie"", ""io"", ""iu"", ""oi"", ""ou"" and ""ua"".

Example 3:
Input: n = 5
Output: 68

Constraints:
1 <= n <= 2 * 10^4
=end

# @param {Integer} n
# @return {Integer}
def count_vowel_permutation(n)
  a = e = i = o = u = 1
  (2..n).each do
    a, e, i, o, u = e + i + u, a + i, e + o, i, i + o
  end
  (a + e + i + o + u) % 1000000007
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_count_vowel_permutation < Test::Unit::TestCase
  def test_
    assert_equal 5, count_vowel_permutation(1)
    assert_equal 10, count_vowel_permutation(2)
    assert_equal 68, count_vowel_permutation(5)
  end
end
"
1232,check-if-it-is-a-straight-line,"# frozen_string_literal: true

# https://leetcode.com/problems/check-if-it-is-a-straight-line
# 1232. Check If It Is a Straight Line
# Easy

=begin
You are given an array coordinates, coordinates[i] = [x, y], where [x, y] represents the coordinate of a point. Check if these points make a straight line in the XY plane.

Example 1:
Input: coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]
Output: true

Example 2:
Input: coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]
Output: false

Constraints:
* 2 <= coordinates.length <= 1000
* coordinates[i].length == 2
* -10^4 <= coordinates[i][0], coordinates[i][1] <= 10^4
* coordinates contains no duplicate point.
=end

# @param {Integer[][]} coordinates
# @return {Boolean}
def check_straight_line(coordinates)
  x1, y1 = coordinates.shift
  x2, y2 = coordinates.shift
  coordinates.each do |a, b|
    if (x2 - x1) * (b - y1) != (y2 - y1) * (a - x1)
      return false
    end
  end
  true
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_check_straight_line < Test::Unit::TestCase
  def test_
    assert_equal true, check_straight_line([[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7]])
    assert_equal false, check_straight_line([[1, 1], [2, 2], [3, 4], [4, 5], [5, 6], [7, 7]])
  end
end
"
1239,maximum-length-of-a-concatenated-string-with-unique-characters,"# frozen_string_literal: true

# 1239. Maximum Length of a Concatenated String with Unique Characters
# Medium
# https://leetcode.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters

=begin
You are given an array of strings arr. A string s is formed by the concatenation of a subsequence of arr that has unique characters.
Return the maximum possible length of s.
A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.

Example 1:
Input: arr = [""un"",""iq"",""ue""]
Output: 4
Explanation: All the valid concatenations are:
- """"
- ""un""
- ""iq""
- ""ue""
- ""uniq"" (""un"" + ""iq"")
- ""ique"" (""iq"" + ""ue"")
Maximum length is 4.

Example 2:
Input: arr = [""cha"",""r"",""act"",""ers""]
Output: 6
Explanation: Possible longest valid concatenations are ""chaers"" (""cha"" + ""ers"") and ""acters"" (""act"" + ""ers"").

Example 3:
Input: arr = [""abcdefghijklmnopqrstuvwxyz""]
Output: 26
Explanation: The only string in arr has all 26 characters.

Constraints:
1 <= arr.length <= 16
1 <= arr[i].length <= 26
arr[i] contains only lowercase English letters.
=end

# @param {String[]} arr
# @return {Integer}
AORD = ""a"".ord
def max_length(arr)
  arr.map! { _1.chars.map { |ch| ch.ord - AORD } }
  res = 0
  n = arr.length
  dfs = -> ary, idx do
    res = [res, ary.length].max
    return if idx == n
    ary2 = arr[idx]
    if ary2.length == ary2.uniq.length && !ary.intersect?(ary2)
      dfs.call(ary | ary2, idx + 1)
    end
    dfs.call(ary, idx + 1)
  end
  dfs.call([], 0)
  res
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_max_length < Test::Unit::TestCase
  def test_
    assert_equal 4, max_length([""un"", ""iq"", ""ue""])
    assert_equal 6, max_length([""cha"", ""r"", ""act"", ""ers""])
    assert_equal 26, max_length([""abcdefghijklmnopqrstuvwxyz""])
  end
end
"
1254,number-of-closed-islands,"# frozen_string_literal: true

# 1254. Number of Closed Islands
# https://leetcode.com/problems/number-of-closed-islands/

=begin

Given a 2D grid consists of 0s (land) and 1s (water).  An island is a maximal 4-directionally connected group of 0s and a closed island is an island totally (all left, top, right, bottom) surrounded by 1s.

Return the number of closed islands.

### Example 1:
Input: grid = [[1,1,1,1,1,1,1,0],
               [1,0,0,0,0,1,1,0],
               [1,0,1,0,1,1,1,0],
               [1,0,0,0,0,1,0,1],
               [1,1,1,1,1,1,1,0]]
Output: 2
Explanation:
Islands in gray are closed because they are completely surrounded by water (group of 1s).

### Example 2:
Input: grid = [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]]
Output: 1

### Example 3:

Input: grid = [[1,1,1,1,1,1,1],
               [1,0,0,0,0,0,1],
               [1,0,1,1,1,0,1],
               [1,0,1,0,1,0,1],
               [1,0,1,1,1,0,1],
               [1,0,0,0,0,0,1],
               [1,1,1,1,1,1,1]]
Output: 2

### Constraints:
* 1 <= grid.length, grid[0].length <= 100
* 0 <= grid[i][j] <=1

=end

# @param {Integer[][]} grid
# @return {Integer}
def closed_island(grid)
  (0...grid.size).each do |i|
    (0...grid[i].size).each do |j|
      if i * j == 0 || i == grid.size - 1 || j == grid[i].size - 1
        fill(grid, i, j)
      end
    end
  end

  res = 0

  (0...grid.size).each do |i|
    (0...grid[i].size).each do |j|
      if grid[i][j] == 0
        res += 1
        fill(grid, i, j)
      end
    end
  end

  res
end

def fill(g, x, y)
  if x < 0 || y < 0 || x >= g.size || y >= g[x].size || g[x][y] == 1
    return
  end

  g[x][y] = 1
  directions = [0, 1, 0, -1, 0]
  (0..3).each do |i|
    fill(g, x + directions[i], y + directions[i + 1])
  end
end


# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_closed_island < Test::Unit::TestCase
  def test_
    assert_equal 2, closed_island([[1, 1, 1, 1, 1, 1, 1, 0], [1, 0, 0, 0, 0, 1, 1, 0], [1, 0, 1, 0, 1, 1, 1, 0], [1, 0, 0, 0, 0, 1, 0, 1], [1, 1, 1, 1, 1, 1, 1, 0]])
    assert_equal 1, closed_island([[0, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 1, 1, 1, 0]])
    assert_equal 2, closed_island([[1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 1, 1, 1, 0, 1], [1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 1, 1, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1]])
  end
end
"
1266,minimum-time-visiting-all-points,"# frozen_string_literal: true

# 1266. Minimum Time Visiting All Points
# Easy
# https://leetcode.com/problems/minimum-time-visiting-all-points/

=begin
On a 2D plane, there are n points with integer coordinates points[i] = [xi, yi]. Return the minimum time in seconds to visit all the points in the order given by points.
You can move according to these rules:
* In 1 second, you can either:
  * move vertically by one unit,
  * move horizontally by one unit, or
  * move diagonally sqrt(2) units (in other words, move one unit vertically then one unit horizontally in 1 second).
* You have to visit the points in the same order as they appear in the array.
* You are allowed to pass through points that appear later in the order, but these do not count as visits.

Example 1:
Input: points = [[1,1],[3,4],[-1,0]]
Output: 7
Explanation: One optimal path is [1,1] -> [2,2] -> [3,3] -> [3,4] -> [2,3] -> [1,2] -> [0,1] -> [-1,0]
Time from [1,1] to [3,4] = 3 seconds
Time from [3,4] to [-1,0] = 4 seconds
Total time = 7 seconds

Example 2:
Input: points = [[3,2],[-2,2]]
Output: 5

Constraints:
points.length == n
1 <= n <= 100
points[i].length == 2
-1000 <= points[i][0], points[i][1] <= 1000
=end

# @param {Integer[][]} points
# @return {Integer}
def min_time_to_visit_all_points(points)
  result = 0
  (0...points.length - 1).each do |i|
    result += [(points[i][0] - points[i + 1][0]).abs, (points[i][1] - points[i + 1][1]).abs].max
  end
  result
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_min_time_to_visit_all_points < Test::Unit::TestCase
  def test_
    assert_equal 7, min_time_to_visit_all_points([[1, 1], [3, 4], [-1, 0]])
    assert_equal 5, min_time_to_visit_all_points([[3, 2], [-2, 2]])
  end
end
"
1268,search-suggestions-system,"# frozen_string_literal: true

# 1268. Search Suggestions System
# https://leetcode.com/problems/search-suggestions-system
# Medium

=begin
You are given an array of strings products and a string searchWord.

Design a system that suggests at most three product names from products after each character of searchWord is typed. Suggested products should have common prefix with searchWord. If there are more than three products with a common prefix return the three lexicographically minimums products.

Return a list of lists of the suggested products after each character of searchWord is typed.

Example 1:
Input: products = [""mobile"",""mouse"",""moneypot"",""monitor"",""mousepad""], searchWord = ""mouse""
Output: [[""mobile"",""moneypot"",""monitor""],[""mobile"",""moneypot"",""monitor""],[""mouse"",""mousepad""],[""mouse"",""mousepad""],[""mouse"",""mousepad""]]
Explanation: products sorted lexicographically = [""mobile"",""moneypot"",""monitor"",""mouse"",""mousepad""].
After typing m and mo all products match and we show user [""mobile"",""moneypot"",""monitor""].
After typing mou, mous and mouse the system suggests [""mouse"",""mousepad""].

Example 2:
Input: products = [""havana""], searchWord = ""havana""
Output: [[""havana""],[""havana""],[""havana""],[""havana""],[""havana""],[""havana""]]
Explanation: The only word ""havana"" will be always suggested while typing the search word.

Constraints:
1 <= products.length <= 1000
1 <= products[i].length <= 3000
1 <= sum(products[i].length) <= 2 * 104
All the strings of products are unique.
products[i] consists of lowercase English letters.
1 <= searchWord.length <= 1000
searchWord consists of lowercase English letters.
=end

# @param {String[]} products
# @param {String} search_word
# @return {String[][]}
def suggested_products(products, search_word)
  products = products.sort!
  result = []

  search_word.length.times do |i|
    sub_str = search_word[0..i]
    temp = []

    products.each do |word|
      temp << word if word.start_with?(sub_str)
    end

    result << temp[0...3]
  end

  result
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_suggested_products < Test::Unit::TestCase
  def test_
    assert_equal [[""mobile"", ""moneypot"", ""monitor""], [""mobile"", ""moneypot"", ""monitor""], [""mouse"", ""mousepad""], [""mouse"", ""mousepad""], [""mouse"", ""mousepad""]], suggested_products([""mobile"", ""mouse"", ""moneypot"", ""monitor"", ""mousepad""], ""mouse"")
    assert_equal [[""havana""], [""havana""], [""havana""], [""havana""], [""havana""], [""havana""]], suggested_products([""havana""], ""havana"")
  end
end
"
1269,number-of-ways-to-stay-in-the-same-place-after-some-steps,"# frozen_string_literal: true

# 1269. Number of Ways to Stay in the Same Place After Some Steps
# Hard
# https://leetcode.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps

=begin
You have a pointer at index 0 in an array of size arrLen. At each step, you can move 1 position to the left, 1 position to the right in the array, or stay in the same place (The pointer should not be placed outside the array at any time).
Given two integers steps and arrLen, return the number of ways such that your pointer is still at index 0 after exactly steps steps. Since the answer may be too large, return it modulo 10^9 + 7.

Example 1:
Input: steps = 3, arrLen = 2
Output: 4
Explanation: There are 4 differents ways to stay at index 0 after 3 steps.
Right, Left, Stay
Stay, Right, Left
Right, Stay, Left
Stay, Stay, Stay

Example 2:
Input: steps = 2, arrLen = 4
Output: 2
Explanation: There are 2 differents ways to stay at index 0 after 2 steps
Right, Left
Stay, Stay

Example 3:
Input: steps = 4, arrLen = 2
Output: 8

Constraints:
1 <= steps <= 500
1 <= arrLen <= 106
=end

# @param {Integer} steps
# @param {Integer} arr_len
# @return {Integer}
MOD = 10**9 + 7
def num_ways(steps, arr_len)
  max_pos = [steps / 2, arr_len - 1].min
  (dp = Array.new(max_pos + 3, 0))[1] = 1
  steps.times.inject(dp) { |dp, i|
    [0] + dp.each_cons(3).collect { |c| c.sum % MOD } + [0]
  }[1]
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_num_ways < Test::Unit::TestCase
  def test_
    assert_equal 4, num_ways(3, 2)
    assert_equal 2, num_ways(2, 4)
    assert_equal 8, num_ways(4, 2)
  end
end
"
1282,group-the-people-given-the-group-size-they-belong-to,"# frozen_string_literal: true

# 1282. Group the People Given the Group Size They Belong To
# Medium
# https://leetcode.com/problems/group-the-people-given-the-group-size-they-belong-to

=begin
There are n people that are split into some unknown number of groups. Each person is labeled with a unique ID from 0 to n - 1.
You are given an integer array groupSizes, where groupSizes[i] is the size of the group that person i is in. For example, if groupSizes[1] = 3, then person 1 must be in a group of size 3.
Return a list of groups such that each person i is in a group of size groupSizes[i].
Each person should appear in exactly one group, and every person must be in a group. If there are multiple answers, return any of them. It is guaranteed that there will be at least one valid solution for the given input.

Example 1:
Input: groupSizes = [3,3,3,3,3,1,3]
Output: [[5],[0,1,2],[3,4,6]]
Explanation:
The first group is [5]. The size is 1, and groupSizes[5] = 1.
The second group is [0,1,2]. The size is 3, and groupSizes[0] = groupSizes[1] = groupSizes[2] = 3.
The third group is [3,4,6]. The size is 3, and groupSizes[3] = groupSizes[4] = groupSizes[6] = 3.
Other possible solutions are [[2,1,6],[5],[0,4,3]] and [[5],[0,6,2],[4,3,1]].

Example 2:
Input: groupSizes = [2,1,3,3,3,2]
Output: [[1],[0,5],[2,3,4]]


Constraints:
* groupSizes.length == n
* 1 <= n <= 500
* 1 <= groupSizes[i] <= n
=end

# @param {Integer[]} group_sizes
# @return {Integer[][]}
def group_the_people(group_sizes)
  people = Hash.new() { |h, k| h[k] = Array.new }
  groups = []
  group_sizes.each.with_index { |size, idx| people[size] << idx }
  people.each { |size, ids| groups << ids.pop(size) until ids.empty? }
  groups
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_group_the_people < Test::Unit::TestCase
  def test_
    assert_equal [[5], [0, 1, 2], [3, 4, 6]].sort, group_the_people([3, 3, 3, 3, 3, 1, 3]).sort
    assert_equal [[1], [0, 5], [2, 3, 4]].sort, group_the_people([2, 1, 3, 3, 3, 2]).sort
  end
end
"
1287,element-appearing-more-than-25-in-sorted-array,"# frozen_string_literal: true

# 1287. Element Appearing More Than 25% In Sorted Array
# Easy
# https://leetcode.com/problems/element-appearing-more-than-25-in-sorted-array

=begin
Given an integer array sorted in non-decreasing order, there is exactly one integer in the array that occurs more than 25% of the time, return that integer.

Example 1:
Input: arr = [1,2,2,6,6,6,6,7,10]
Output: 6

Example 2:
Input: arr = [1,1]
Output: 1

Constraints:
1 <= arr.length <= 104
0 <= arr[i] <= 105
=end

# @param {Integer[]} arr
# @return {Integer}
def find_special_integer(arr)
  return arr[0] if arr.size < 3

  size = arr.size
  appearance = size.fdiv(4)

  counter = 1
  (1...size).each do |i|
    value = arr[i]
    if arr[i - 1] == value
      counter += 1
    else
      counter = 1
    end
    return value if appearance < counter
  end
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_find_special_integer < Test::Unit::TestCase
  def test_
    assert_equal 6, find_special_integer([1, 2, 2, 6, 6, 6, 6, 7, 10])
    assert_equal 1, find_special_integer([1, 1])
  end
end
"
1312,minimum-insertion-steps-to-make-a-string-palindrome,"# frozen_string_literal: true

# 1312. Minimum Insertion Steps to Make a String Palindrome
# https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/
# Hard

=begin
Given a string s. In one step you can insert any character at any index of the string.

Return the minimum number of steps to make s palindrome.

A Palindrome String is one that reads the same backward as well as forward.

Example 1:
Input: s = ""zzazz""
Output: 0
Explanation: The string ""zzazz"" is already palindrome we do not need any insertions.

Example 2:
Input: s = ""mbadm""
Output: 2
Explanation: String can be ""mbdadbm"" or ""mdbabdm"".

Example 3:
Input: s = ""leetcode""
Output: 5
Explanation: Inserting 5 characters the string becomes ""leetcodocteel"".

Constraints:
* 1 <= s.length <= 500
* s consists of lowercase English letters.

=end

# @param {String} s
# @return {Integer}
def min_insertions(s, r = s.reverse)
  return 0 if s == r
  dp = Array.new(s.size + 1) { Array.new(r.size + 1) }
  (s.size + 1).times do |i|
    (r.size + 1).times do |j|
      if i == 0 || j == 0
        dp[i][j] = 0
      elsif s[i - 1] == r[j - 1]
        dp[i][j] = 1 + dp[i - 1][j - 1]
      else
        dp[i][j] = [dp[i][j - 1], dp[i - 1][j]].max
      end
    end
  end
  s.size - dp[-1][-1]
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_min_insertions < Test::Unit::TestCase
  def test_
    assert_equal(0, min_insertions(""zzazz""))
    assert_equal(2, min_insertions(""mbadm""))
    assert_equal(5, min_insertions(""leetcode""))
  end
end
"
1318,minimum-flips-to-make-a-or-b-equal-to-c,"# frozen_string_literal: true

# 1318. Minimum Flips to Make a OR b Equal to c
# https://leetcode.com/problems/minimum-flips-to-make-a-or-b-equal-to-c
# Medium

=begin
Given 3 positives numbers a, b and c. Return the minimum flips required in some bits of a and b to make ( a OR b == c ). (bitwise OR operation).
Flip operation consists of change any single bit 1 to 0 or change the bit 0 to 1 in their binary representation.

Example 1:
Input: a = 2, b = 6, c = 5
Output: 3
Explanation: After flips a = 1 , b = 4 , c = 5 such that (a OR b == c)

Example 2:
Input: a = 4, b = 2, c = 7
Output: 1

Example 3:
Input: a = 1, b = 2, c = 3
Output: 0

Constraints:
1 <= a <= 10^9
1 <= b <= 10^9
1 <= c <= 10^9
=end

# @param {Integer} a
# @param {Integer} b
# @param {Integer} c
# @return {Integer}
def min_flips(a, b, c)
  a, b, c = make_bits(a), make_bits(b), make_bits(c)
  count = 0
  c.each_with_index do |bit, i|
    if bit == 1
      count += 1 unless a[i] == 1 || b[i] == 1
    else
      count += a[i] + b[i]
    end
  end
  count
end

def make_bits(n)
  arr = []
  30.times do
    arr.unshift(n % 2)
    n /= 2
  end
  arr
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_min_flips < Test::Unit::TestCase
  def test_
    assert_equal 3, min_flips(2, 6, 5)
    assert_equal 1, min_flips(4, 2, 7)
    assert_equal 0, min_flips(1, 2, 3)
  end
end
"
1319,number-of-operations-to-make-network-connected,"# frozen_string_literal: true

# 1319. Number of Operations to Make Network Connected
# https://leetcode.com/problems/number-of-operations-to-make-network-connected

=begin

There are n computers numbered from 0 to n - 1 connected by ethernet cables connections forming a network where connections[i] = [ai, bi] represents a connection between computers ai and bi. Any computer can reach any other computer directly or indirectly through the network.

You are given an initial computer network connections. You can extract certain cables between two directly connected computers, and place them between any pair of disconnected computers to make them directly connected.

Return the minimum number of times you need to do this in order to make all the computers connected. If it is not possible, return -1.

### Example 1
Input: n = 4, connections = [[0,1],[0,2],[1,2]]
Output: 1
Explanation: Remove cable between computer 1 and 2 and place between computers 1 and 3.

### Example 2
Input: n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]]
Output: 2

### Example 3
Input: n = 6, connections = [[0,1],[0,2],[0,3],[1,2]]
Output: -1
Explanation: There are not enough cables.

### Constraints:

* 1 <= n <= 105
* 1 <= connections.length <= min(n * (n - 1) / 2, 105)
* connections[i].length == 2
* 0 <= ai, bi < n
* ai != bi
* There are no repeated connections.
* No two computers are connected by more than one cable.

=end

# Runtime 135 ms, Beats 100%
# Memory 215.3 MB, Beats 100%
# @param {Integer} n
# @param {Integer[][]} connections
# @return {Integer}
def make_connected(n, connections)
  return -1 if connections.size < n - 1

  number = n
  ds = Array.new(n, -1)

  connections.each do |c|
    i = find(ds, c[0])
    j = find(ds, c[1])

    if i != j
      if ds[j] < ds[i]
        i, j = j, i
      end

      ds[i] += ds[j]
      ds[j] = i
      number -= 1
    end
  end

  number - 1
end

def find(ds, i)
  ds[i] < 0 ? i : ds[i] = find(ds, ds[i])
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_make_connected < Test::Unit::TestCase
  def test_
    assert_equal 1, make_connected(4, [[0, 1], [0, 2], [1, 2]])
    assert_equal 2, make_connected(6, [[0, 1], [0, 2], [0, 3], [1, 2], [1, 3]])
    assert_equal(-1, make_connected(6, [[0, 1], [0, 2], [0, 3], [1, 2]]))
  end
end
"
1326,minimum-number-of-taps-to-open-to-water-a-garden,"# frozen_string_literal: true

# 1326. Minimum Number of Taps to Open to Water a Garden
# Hard
# https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden

=begin
There is a one-dimensional garden on the x-axis. The garden starts at the point 0 and ends at the point n. (i.e The length of the garden is n).
There are n + 1 taps located at points [0, 1, ..., n] in the garden.
Given an integer n and an integer array ranges of length n + 1 where ranges[i] (0-indexed) means the i-th tap can water the area [i - ranges[i], i + ranges[i]] if it was open.
Return the minimum number of taps that should be open to water the whole garden, If the garden cannot be watered return -1.

Example 1:
Input: n = 5, ranges = [3,4,1,1,0,0]
Output: 1
Explanation: The tap at point 0 can cover the interval [-3,3]
The tap at point 1 can cover the interval [-3,5]
The tap at point 2 can cover the interval [1,3]
The tap at point 3 can cover the interval [2,4]
The tap at point 4 can cover the interval [4,4]
The tap at point 5 can cover the interval [5,5]
Opening Only the second tap will water the whole garden [0,5]

Example 2:
Input: n = 3, ranges = [0,0,0,0]
Output: -1
Explanation: Even if you activate all the four taps you cannot water the whole garden.

Constraints:
1 <= n <= 104
ranges.length == n + 1
0 <= ranges[i] <= 100
=end

# @param {Integer} n
# @param {Integer[]} ranges
# @return {Integer}
def min_taps(n, ranges)
  intervals = ranges.filter_map.with_index { |range, index| [index - range, index + range] if range > 0 }
  intervals.sort_by!(&:first)

  garden_max_index = n
  intervals << [garden_max_index, garden_max_index]

  count = 0
  current_index = 0
  next_index = 0
  intervals.each do |start_index, end_index|
    return -1 if start_index > next_index

    if start_index > current_index
      count += 1
      current_index = next_index
    end

    next_index = end_index if end_index > next_index
  end

  count
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_min_taps < Test::Unit::TestCase
  def test_
    assert_equal 1, min_taps(5, [3, 4, 1, 1, 0, 0])
    assert_equal(-1, min_taps(3, [0, 0, 0, 0]))
  end
end
"
1337,the-k-weakest-rows-in-a-matrix,"# frozen_string_literal: true

# 1337. The K Weakest Rows in a Matrix
# Easy
# https://leetcode.com/problems/the-k-weakest-rows-in-a-matrix

=begin
You are given an m x n binary matrix mat of 1's (representing soldiers) and 0's (representing civilians). The soldiers are positioned in front of the civilians. That is, all the 1's will appear to the left of all the 0's in each row.
A row i is weaker than a row j if one of the following is true:
The number of soldiers in row i is less than the number of soldiers in row j.
Both rows have the same number of soldiers and i < j.
Return the indices of the k weakest rows in the matrix ordered from weakest to strongest.

Example 1:
Input: mat =
[[1,1,0,0,0],
 [1,1,1,1,0],
 [1,0,0,0,0],
 [1,1,0,0,0],
 [1,1,1,1,1]],
k = 3
Output: [2,0,3]
Explanation:
The number of soldiers in each row is:
- Row 0: 2
- Row 1: 4
- Row 2: 1
- Row 3: 2
- Row 4: 5
The rows ordered from weakest to strongest are [2,0,3,1,4].

Example 2:
Input: mat =
[[1,0,0,0],
 [1,1,1,1],
 [1,0,0,0],
 [1,0,0,0]],
k = 2
Output: [0,2]
Explanation:
The number of soldiers in each row is:
- Row 0: 1
- Row 1: 4
- Row 2: 1
- Row 3: 1
The rows ordered from weakest to strongest are [0,2,3,1].

Constraints:
* m == mat.length
* n == mat[i].length
* 2 <= n, m <= 100
* 1 <= k <= m
* matrix[i][j] is either 0 or 1.
=end

# @param {Integer[][]} mat
# @param {Integer} k
# @return {Integer[]}
def k_weakest_rows(mat, k)
  strength = mat.each_with_index.map { |row, i| [row.sum, i] }

  strength.sort_by! { |row| [row[0], row[1]] }

  strength.first(k).map { |row| row[1] }
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_k_weakest_rows < Test::Unit::TestCase
  def test_
    assert_equal [2, 0, 3], k_weakest_rows(
      [[1, 1, 0, 0, 0],
      [1, 1, 1, 1, 0],
      [1, 0, 0, 0, 0],
      [1, 1, 0, 0, 0],
      [1, 1, 1, 1, 1]], 3)
    assert_equal [0, 2], k_weakest_rows(
      [[1, 0, 0, 0],
      [1, 1, 1, 1],
      [1, 0, 0, 0],
      [1, 0, 0, 0]], 2)
  end
end
"
1345,jump-game-iv,"# frozen_string_literal: true

# 1345. Jump Game IV
# https://leetcode.com/problems/jump-game-iv

# @param {Integer[]} arr
# @return {Integer}
def min_jumps(arr)
  return 0 if (t = arr.size - 1) < 1
  g = arr.each_index.group_by { arr[_1] }
  s, q, v = 0, [0], [false] * t
  v[0] = true
  loop do
    (s += 1; q.size).times do
      i = q.shift
      c = (g[arr[i]] || []) << i + 1
      g.delete arr[i]
      c << i - 1 if i > 0
      c.each do | x |
        return s if x == t
        next if v[x]
        v[x] = true
        q << x
      end
    end
  end
end

def min_jumps1(arr)
  @d = false
  last_index = arr.size - 1
  return 0 if arr.size <= 1
  graph = {}
  arr.each_with_index do |value, index|
    graph[value] ||= []
    graph[value].push(index)
  end
  layer = [0]
  used = {}
  used[0] = true
  step = 0
  while ! layer.empty?
    nxt = []
    layer.each do |i|
      return step if last_index == i
      [i + 1, i - 1].each do |j|
        if j.between?(0, last_index) && (!used[j])
          used[j] = true
          nxt.push(j)
        end
      end
      graph[arr[i]].each do |j|
        if ! used[j]
          used[j] = true
          nxt.push(j)
        end
      end
      # Most important line!
      graph[arr[i]].clear()
    end
    step += 1
    layer = nxt
  end
end

# @param {Integer[]} arr
# @return {Integer}
def min_jumps2(arr)
  arr_count = arr.count

  graph = Hash.new { |h, k| h[k] = [] }
  arr_count.times do |i|
    graph[arr[i]] << i
  end

  src = 0
  dest = arr_count - 1

  visited = Set.new
  visited << src

  queue = []
  queue << [src, 0]

  until queue.empty?
    node, dist = queue.shift
    return dist if node == dest

    ([node - 1, node + 1] + graph[arr[node]].reverse).each do |child|
      if 0 <= child &&
          child < arr_count &&
          child != node &&
          !visited.include?(child)

        visited << child
        return dist + 1 if child == dest
        queue << [child, dist + 1]
      end
    end
  end

  -1
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_min_jumps < Test::Unit::TestCase
  def test_
    assert_equal 3, min_jumps([100, -23, -23, 404, 100, 23, 23, 23, 3, 404])
    assert_equal 0, min_jumps([7])
    assert_equal 1, min_jumps([7, 6, 9, 6, 9, 6, 9, 7])

    assert_equal 3, min_jumps1([100, -23, -23, 404, 100, 23, 23, 23, 3, 404])
    assert_equal 0, min_jumps1([7])
    assert_equal 1, min_jumps1([7, 6, 9, 6, 9, 6, 9, 7])

    assert_equal 3, min_jumps2([100, -23, -23, 404, 100, 23, 23, 23, 3, 404])
    assert_equal 0, min_jumps2([7])
    assert_equal 1, min_jumps2([7, 6, 9, 6, 9, 6, 9, 7])
  end
end

# ********************#
#     Benchmark       #
# ********************#

require ""benchmark""

arr = [100, -23, -23, 404, 100, 23, 23, 23, 3, 404]
Benchmark.bm do |x|
  x.report(""min_jumps: "") { min_jumps(arr) }
  x.report(""min_jumps1: "") { min_jumps1(arr) }
  x.report(""min_jumps2: "") { min_jumps2(arr) }
end

# user     system      total        real
# min_jumps:   0.000029   0.000005   0.000034 (  0.000029)
# min_jumps1:   0.000040   0.000008   0.000048 (  0.000048)
# min_jumps2:   0.001512   0.000000   0.001512 (  0.001514)
"
1351,count-negative-numbers-in-a-sorted-matrix,"# frozen_string_literal: true

# https://leetcode.com/problems/count-negative-numbers-in-a-sorted-matrix
# 1351. Count Negative Numbers in a Sorted Matrix
# Easy

=begin
Given a m x n matrix grid which is sorted in non-increasing order both row-wise and column-wise, return the number of negative numbers in grid.

Example 1:
Input: grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]
Output: 8
Explanation: There are 8 negatives number in the matrix.

Example 2:
Input: grid = [[3,2],[1,0]]
Output: 0
=end

# @param {Integer[][]} grid
# @return {Integer}
def count_negatives(grid)
  grid.reduce(0) do |sum, row|
    row.each do |column|
        sum += 1 if column < 0
      end
    sum
  end
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_count_negatives < Test::Unit::TestCase
  def test_
    assert_equal 8, count_negatives([[4, 3, 2, -1], [3, 2, 1, -1], [1, 1, -1, -2], [-1, -1, -2, -3]])
    assert_equal 0, count_negatives([[3, 2], [1, 0]])
  end
end
"
1359,count-all-valid-pickup-and-delivery-options,"# frozen_string_literal: true

# 1359. Count All Valid Pickup and Delivery Options
# Hard
# https://leetcode.com/problems/count-all-valid-pickup-and-delivery-options

=begin
Given n orders, each order consist in pickup and delivery services.
Count all valid pickup/delivery possible sequences such that delivery(i) is always after of pickup(i).
Since the answer may be too large, return it modulo 10^9 + 7.

Example 1:
Input: n = 1
Output: 1
Explanation: Unique order (P1, D1), Delivery 1 always is after of Pickup 1.

Example 2:
Input: n = 2
Output: 6
Explanation: All possible orders:
(P1,P2,D1,D2), (P1,P2,D2,D1), (P1,D1,P2,D2), (P2,P1,D1,D2), (P2,P1,D2,D1) and (P2,D2,P1,D1).
This is an invalid order (P1,D2,P2,D1) because Pickup 2 is after of Delivery 2.

Example 3:
Input: n = 3
Output: 90

Constraints:
* 1 <= n <= 500
=end

# @param {Integer} n
# @return {Integer}
def count_orders(n)
  ans = 1
  mod = (10**9) + 7
  (1..n).each do |i|
    ans *= i * (2 * i - 1)
    ans %= mod
  end
  ans
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_count_orders < Test::Unit::TestCase
  def test_
    assert_equal 1, count_orders(1)
    assert_equal 6, count_orders(2)
    assert_equal 90, count_orders(3)
  end
end
"
1361,validate-binary-tree-nodes,"# frozen_string_literal: true

# 1361. Validate Binary Tree Nodes
# Medium
# https://leetcode.com/problems/validate-binary-tree-nodes

=begin
You have n binary tree nodes numbered from 0 to n - 1 where node i has two children leftChild[i] and rightChild[i], return true if and only if all the given nodes form exactly one valid binary tree.
If node i has no left child then leftChild[i] will equal -1, similarly for the right child.
Note that the nodes have no values and that we only use the node numbers in this problem.

Example 1:
Input: n = 4, leftChild = [1,-1,3,-1], rightChild = [2,-1,-1,-1]
Output: true

Example 2:
Input: n = 4, leftChild = [1,-1,3,-1], rightChild = [2,3,-1,-1]
Output: false

Example 3:
Input: n = 2, leftChild = [1,0], rightChild = [-1,-1]
Output: false

Constraints:
n == leftChild.length == rightChild.length
1 <= n <= 104
-1 <= leftChild[i], rightChild[i] <= n - 1
=end

# @param {Integer} n
# @param {Integer[]} left_child
# @param {Integer[]} right_child
# @return {Boolean}
def validate_binary_tree_nodes(n, left_child, right_child)
  parents, children = [], Array.new(n) { |_| Array.new }
  [left_child, right_child].each do |childs|
    childs.each_with_index do |c, i|
      next if c.negative?
      parents[c] ||= i
      return false if parents[c] != i
      return false if children[i].include?(c)
      children[i] << c
    end
  end

  return false unless n.times.collect { |p| parents[p].nil? ? 1 : 0 }.sum == 1

  root = n.times.inject(nil) do |r, p|
    return false if parents[p].nil? && !r.nil?
    parents[p].nil? ? p : r
  end
  visited, cur = Set[root], Set[root]
  until cur.empty? do
    cur = cur.inject(Set[]) do |r, c|
      cc = children[c]
      return false if cc.any? { |ccc| visited.include?(ccc) }
      visited.merge(cc)
      r.merge(cc)
    end
  end

  visited.size == n
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_validate_binary_tree_nodes < Test::Unit::TestCase
  def test_
    assert_equal true, validate_binary_tree_nodes(4, [1, -1, 3, -1], [2, -1, -1, -1])
    assert_equal false, validate_binary_tree_nodes(4, [1, -1, 3, -1], [2, 3, -1, -1])
    assert_equal false, validate_binary_tree_nodes(4, [1, 0], [-1, -1])
  end
end
"
1372,longest-zigzag-path-in-a-binary-tree,"# frozen_string_literal: true

# 1372. Longest ZigZag Path in a Binary Tree
# https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree
# Medium

=begin

You are given the root of a binary tree.

A ZigZag path for a binary tree is defined as follow:

Choose any node in the binary tree and a direction (right or left).
If the current direction is right, move to the right child of the current node; otherwise, move to the left child.
Change the direction from right to left or from left to right.
Repeat the second and third steps until you can't move in the tree.
Zigzag length is defined as the number of nodes visited - 1. (A single node has a length of 0).

Return the longest ZigZag path contained in that tree.

### Example 1:
Input: root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1]
Output: 3
Explanation: Longest ZigZag path in blue nodes (right -> left -> right).

### Example 2:
Input: root = [1,1,1,null,1,null,null,1,1,null,1]
Output: 4
Explanation: Longest ZigZag path in blue nodes (left -> right -> left -> right).

### Example 3:
Input: root = [1]
Output: 0

### Constraints:
* The number of nodes in the tree is in the range [1, 5 * 104].
* 1 <= Node.val <= 100

=end

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root
# @return {Integer}
def longest_zig_zag(root)
  nodes = []
  queue = [root]
  until queue.empty?
    ele = queue.shift
    nodes << ele
    if ele.left
      ele.left.val = ""l""
      queue << ele.left
    end
    if ele.right
      ele.right.val = ""r""
      queue << ele.right
    end
  end
  nodes.map! { |node| [left_path(node), right_path(node)].max }
  nodes.max
end

def left_path(node)
  return 0 if node.val == ""r""
  i = 0
  while node.left && node.left.right
    node = node.left.right
    i += 2
  end
  node.left ? i + 1 : i
end

def right_path(node)
  return 0 if node.val == ""l""
  i = 0
  while node.right && node.right.left
    node = node.right.left
    i += 2
  end
  node.right ? i + 1 : i
end
"
1376,time-needed-to-inform-all-employees,"# frozen_string_literal: true

# https://leetcode.com/problems/time-needed-to-inform-all-employees
# 1376. Time Needed to Inform All Employees
# Medium

=begin
A company has n employees with a unique ID for each employee from 0 to n - 1. The head of the company is the one with headID.

Each employee has one direct manager given in the manager array where manager[i] is the direct manager of the i-th employee, manager[headID] = -1. Also, it is guaranteed that the subordination relationships have a tree structure.

The head of the company wants to inform all the company employees of an urgent piece of news. He will inform his direct subordinates, and they will inform their subordinates, and so on until all employees know about the urgent news.

The i-th employee needs informTime[i] minutes to inform all of his direct subordinates (i.e., After informTime[i] minutes, all his direct subordinates can start spreading the news).

Return the number of minutes needed to inform all the employees about the urgent news.

Example 1:
Input: n = 1, headID = 0, manager = [-1], informTime = [0]
Output: 0
Explanation: The head of the company is the only employee in the company.

Example 2:
Input: n = 6, headID = 2, manager = [2,2,-1,2,2,2], informTime = [0,0,1,0,0,0]
Output: 1
Explanation: The head of the company with id = 2 is the direct manager of all the employees in the company and needs 1 minute to inform them all.
The tree structure of the employees in the company is shown.

Constraints:
* 1 <= n <= 105
* 0 <= headID < n
* manager.length == n
* 0 <= manager[i] < n
* manager[headID] == -1
* informTime.length == n
* 0 <= informTime[i] <= 1000
* informTime[i] == 0 if employee i has no subordinates.
* It is guaranteed that all the employees can be informed.
=end

# @param {Integer} n
# @param {Integer} head_id
# @param {Integer[]} manager
# @param {Integer[]} inform_time
# @return {Integer}
def num_of_minutes(n, head_id, manager, inform_time)
  @res = 0
  (0...n).each { |i| process(i, head_id, manager, inform_time) if inform_time[i] == 0 }
  @res
end

def process(cur, head, manager, inform_time)
  sum = 0
  while cur != head
    cur = manager[cur]
    sum += inform_time[cur]
  end
  @res = [@res, sum].max
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_num_of_minutes < Test::Unit::TestCase
  def test_
    assert_equal 0, num_of_minutes(1, 0, [-1], [0])
    assert_equal 1, num_of_minutes(6, 2, [2, 2, -1, 2, 2, 2], [0, 0, 1, 0, 0, 0])
  end
end
"
1396,design-underground-system,"# frozen_string_literal: true

# 1396. Design Underground System
# https://leetcode.com/problems/design-underground-system
# Medium

=begin
An underground railway system is keeping track of customer travel times between different stations. They are using this data to calculate the average time it takes to travel from one station to another.

Implement the UndergroundSystem class:

* void checkIn(int id, string stationName, int t)
  * A customer with a card ID equal to id, checks in at the station stationName at time t.
  * A customer can only be checked into one place at a time.
* void checkOut(int id, string stationName, int t)
  * A customer with a card ID equal to id, checks out from the station stationName at time t.
* double getAverageTime(string startStation, string endStation)
  * Returns the average time it takes to travel from startStation to endStation.
  * The average time is computed from all the previous traveling times from startStation to endStation that happened directly, meaning a check in at startStation followed by a check out from endStation.
  * The time it takes to travel from startStation to endStation may be different from the time it takes to travel from endStation to startStation.
  * There will be at least one customer that has traveled from startStation to endStation before getAverageTime is called.
You may assume all calls to the checkIn and checkOut methods are consistent. If a customer checks in at time t1 then checks out at time t2, then t1 < t2. All events happen in chronological order.

Example 1:
Input
[""UndergroundSystem"",""checkIn"",""checkIn"",""checkIn"",""checkOut"",""checkOut"",""checkOut"",""getAverageTime"",""getAverageTime"",""checkIn"",""getAverageTime"",""checkOut"",""getAverageTime""]
[[],[45,""Leyton"",3],[32,""Paradise"",8],[27,""Leyton"",10],[45,""Waterloo"",15],[27,""Waterloo"",20],[32,""Cambridge"",22],[""Paradise"",""Cambridge""],[""Leyton"",""Waterloo""],[10,""Leyton"",24],[""Leyton"",""Waterloo""],[10,""Waterloo"",38],[""Leyton"",""Waterloo""]]
Output
[null,null,null,null,null,null,null,14.00000,11.00000,null,11.00000,null,12.00000]
Explanation
UndergroundSystem undergroundSystem = new UndergroundSystem();
undergroundSystem.checkIn(45, ""Leyton"", 3);
undergroundSystem.checkIn(32, ""Paradise"", 8);
undergroundSystem.checkIn(27, ""Leyton"", 10);
undergroundSystem.checkOut(45, ""Waterloo"", 15);  // Customer 45 ""Leyton"" -> ""Waterloo"" in 15-3 = 12
undergroundSystem.checkOut(27, ""Waterloo"", 20);  // Customer 27 ""Leyton"" -> ""Waterloo"" in 20-10 = 10
undergroundSystem.checkOut(32, ""Cambridge"", 22); // Customer 32 ""Paradise"" -> ""Cambridge"" in 22-8 = 14
undergroundSystem.getAverageTime(""Paradise"", ""Cambridge""); // return 14.00000. One trip ""Paradise"" -> ""Cambridge"", (14) / 1 = 14
undergroundSystem.getAverageTime(""Leyton"", ""Waterloo"");    // return 11.00000. Two trips ""Leyton"" -> ""Waterloo"", (10 + 12) / 2 = 11
undergroundSystem.checkIn(10, ""Leyton"", 24);
undergroundSystem.getAverageTime(""Leyton"", ""Waterloo"");    // return 11.00000
undergroundSystem.checkOut(10, ""Waterloo"", 38);  // Customer 10 ""Leyton"" -> ""Waterloo"" in 38-24 = 14
undergroundSystem.getAverageTime(""Leyton"", ""Waterloo"");    // return 12.00000. Three trips ""Leyton"" -> ""Waterloo"", (10 + 12 + 14) / 3 = 12

Example 2:
Input
[""UndergroundSystem"",""checkIn"",""checkOut"",""getAverageTime"",""checkIn"",""checkOut"",""getAverageTime"",""checkIn"",""checkOut"",""getAverageTime""]
[[],[10,""Leyton"",3],[10,""Paradise"",8],[""Leyton"",""Paradise""],[5,""Leyton"",10],[5,""Paradise"",16],[""Leyton"",""Paradise""],[2,""Leyton"",21],[2,""Paradise"",30],[""Leyton"",""Paradise""]]
Output
[null,null,null,5.00000,null,null,5.50000,null,null,6.66667]
Explanation
UndergroundSystem undergroundSystem = new UndergroundSystem();
undergroundSystem.checkIn(10, ""Leyton"", 3);
undergroundSystem.checkOut(10, ""Paradise"", 8); // Customer 10 ""Leyton"" -> ""Paradise"" in 8-3 = 5
undergroundSystem.getAverageTime(""Leyton"", ""Paradise""); // return 5.00000, (5) / 1 = 5
undergroundSystem.checkIn(5, ""Leyton"", 10);
undergroundSystem.checkOut(5, ""Paradise"", 16); // Customer 5 ""Leyton"" -> ""Paradise"" in 16-10 = 6
undergroundSystem.getAverageTime(""Leyton"", ""Paradise""); // return 5.50000, (5 + 6) / 2 = 5.5
undergroundSystem.checkIn(2, ""Leyton"", 21);
undergroundSystem.checkOut(2, ""Paradise"", 30); // Customer 2 ""Leyton"" -> ""Paradise"" in 30-21 = 9
undergroundSystem.getAverageTime(""Leyton"", ""Paradise""); // return 6.66667, (5 + 6 + 9) / 3 = 6.66667

Constraints:
* 1 <= id, t <= 106
* 1 <= stationName.length, startStation.length, endStation.length <= 10
* All strings consist of uppercase and lowercase English letters and digits.
* There will be at most 2 * 104 calls in total to checkIn, checkOut, and getAverageTime.
* Answers within 10-5 of the actual value will be accepted.
=end

class UndergroundSystem
  def initialize
    @check = {}
    @time = {}
  end

=begin
  :type id: Integer
  :type station_name: String
  :type t: Integer
  :rtype: Void
=end
  def check_in(id, station_name, t)
    @check[id] = [station_name, t]
  end


=begin
  :type id: Integer
  :type station_name: String
  :type t: Integer
  :rtype: Void
=end
  def check_out(id, station_name, t)
    station_prev, t_prev = @check[id]
    t_diff = t - t_prev

    if @time[[station_prev, station_name]]
      total_time, station_i = @time[[station_prev, station_name]]
      @time[[station_prev, station_name]] = [total_time + t_diff, station_i + 1]
    else
      @time[[station_prev, station_name]] = [t_diff, 1]
    end
  end


=begin
  :type start_station: String
  :type end_station: String
  :rtype: Float
=end
  def get_average_time(start_station, end_station)
    total_time, station_i = @time[[start_station, end_station]]
    total_time.to_f / station_i
  end
end

# Your UndergroundSystem object will be instantiated and called as such:
# obj = UndergroundSystem.new()
# obj.check_in(id, station_name, t)
# obj.check_out(id, station_name, t)
# param_3 = obj.get_average_time(start_station, end_station)
"
1402,reducing-dishes,"# frozen_string_literal: true

# 1402. Reducing Dishes
# https://leetcode.com/problems/reducing-dishes

=begin

A chef has collected data on the satisfaction level of his n dishes. Chef can cook any dish in 1 unit of time.

Like-time coefficient of a dish is defined as the time taken to cook that dish including previous dishes multiplied by its satisfaction level i.e. time[i] * satisfaction[i].

Return the maximum sum of like-time coefficient that the chef can obtain after dishes preparation.

Dishes can be prepared in any order and the chef can discard some dishes to get this maximum value.

### Example 1:
Input: satisfaction = [-1,-8,0,5,-9]
Output: 14
Explanation: After Removing the second and last dish, the maximum total like-time coefficient will be equal to (-1*1 + 0*2 + 5*3 = 14).
Each dish is prepared in one unit of time.

### Example 2:
Input: satisfaction = [4,3,2]
Output: 20
Explanation: Dishes can be prepared in any order, (2*1 + 3*2 + 4*3 = 20)

### Example 3:
Input: satisfaction = [-1,-4,-5]
Output: 0
Explanation: People do not like the dishes. No dish is prepared.

### Constraints:
* n == satisfaction.length
* 1 <= n <= 500
* -1000 <= satisfaction[i] <= 1000

=end

# Runtime: 86 ms
# Memory: 211.1 MB
# @param {Integer[]} satisfaction
# @return {Integer}
def max_satisfaction(satisfaction)
  max = sum = 0
  satisfaction.sort.reverse_each { |num| max += sum if 0 < sum += num }
  max
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_max_satisfaction < Test::Unit::TestCase
  def test_
    assert_equal 14, max_satisfaction([-1, -8, 0, 5, -9])
    assert_equal 20, max_satisfaction([4, 3, 2])
    assert_equal 0, max_satisfaction([-1, -4, -5])
  end
end
"
1406,stone-game-iii,"# frozen_string_literal: true

# 1406. Stone Game III
# https://leetcode.com/problems/stone-game-iii
# Hard

=begin
Alice and Bob continue their games with piles of stones. There are several stones arranged in a row, and each stone has an associated value which is an integer given in the array stoneValue.

Alice and Bob take turns, with Alice starting first. On each player's turn, that player can take 1, 2, or 3 stones from the first remaining stones in the row.

The score of each player is the sum of the values of the stones taken. The score of each player is 0 initially.

The objective of the game is to end with the highest score, and the winner is the player with the highest score and there could be a tie. The game continues until all the stones have been taken.

Assume Alice and Bob play optimally.

Return ""Alice"" if Alice will win, ""Bob"" if Bob will win, or ""Tie"" if they will end the game with the same score.

Example 1:
Input: values = [1,2,3,7]
Output: ""Bob""
Explanation: Alice will always lose. Her best move will be to take three piles and the score become 6. Now the score of Bob is 7 and Bob wins.

Example 2:
Input: values = [1,2,3,-9]
Output: ""Alice""
Explanation: Alice must choose all the three piles at the first move to win and leave Bob with negative score.
If Alice chooses one pile her score will be 1 and the next move Bob's score becomes 5. In the next move, Alice will take the pile with value = -9 and lose.
If Alice chooses two piles her score will be 3 and the next move Bob's score becomes 3. In the next move, Alice will take the pile with value = -9 and also lose.
Remember that both play optimally so here Alice will choose the scenario that makes her win.

Example 3:
Input: values = [1,2,3,6]
Output: ""Tie""
Explanation: Alice cannot win this game. She can end the game in a draw if she decided to choose all the first three piles, otherwise she will lose.

Constraints:
* 1 <= stoneValue.length <= 5 * 104
* -1000 <= stoneValue[i] <= 1000
=end

# @param {Integer[]} stone_value
# @return {String}
def stone_game_iii(stone_value)
  responses = [0, 0, 0]
  sum = 0
  stone_value.reverse_each do
    sum += _1
    responses.unshift(sum - responses.min).pop
  end
  %w[Tie Alice Bob][responses[0] * 2 <=> sum]
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_stone_game_iii < Test::Unit::TestCase
  def test_
    assert_equal ""Bob"", stone_game_iii([1, 2, 3, 7])
    assert_equal ""Alice"", stone_game_iii([1, 2, 3, -9])
    assert_equal ""Tie"", stone_game_iii([1, 2, 3, 6])
  end
end
"
1416,restore-the-array,"# frozen_string_literal: true

# 1416. Restore The Array
# https://leetcode.com/problems/restore-the-array/description/
# Hard

=begin
A program was supposed to print an array of integers. The program forgot to print whitespaces and the array is printed as a string of digits s and all we know is that all integers in the array were in the range [1, k] and there are no leading zeros in the array.

Given the string s and the integer k, return the number of the possible arrays that can be printed as s using the mentioned program. Since the answer may be very large, return it modulo 109 + 7.

Example 1:
Input: s = ""1000"", k = 10000
Output: 1
Explanation: The only possible array is [1000]

Example 2:
Input: s = ""1000"", k = 10
Output: 0
Explanation: There cannot be an array that was printed this way and has all integer >= 1 and <= 10.

Example 3:
Input: s = ""1317"", k = 2000
Output: 8
Explanation: Possible arrays are [1317],[131,7],[13,17],[1,317],[13,1,7],[1,31,7],[1,3,17],[1,3,1,7]

Constraints:
1 <= s.length <= 105
s consists of only digits and does not contain leading zeros.
1 <= k <= 109
=end

# @param {String} s
# @param {Integer} k
# @return {Integer}
MOD = 10**9 + 7
def number_of_arrays(s, k)
  left = -1
  arr = [1] * s.size
  window_number = window_sum = 0
  for right in 0...s.size
    window_number = window_number * 10 + s[right].to_i
    while window_number > k
      window_sum -= arr[left] if s[left + 1] != ""0""
      window_sum %= MOD
      left += 1
      window_number %= 10**(right - left)
    end
    if window_number == 0
      return 0
    end
    window_sum += arr[right - 1] if s[right] != ""0""
    window_sum %= MOD
    arr[right] = window_sum
  end
  arr[-1]
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_number_of_arrays < Test::Unit::TestCase
  def test_
    assert_equal 1, number_of_arrays(""1000"", 10000)
    assert_equal 0, number_of_arrays(""1000"", 10)
    assert_equal 8, number_of_arrays(""1317"", 2000)
  end
end
"
1420,build-array-where-you-can-find-the-maximum-exactly-k-comparisons,"# frozen_string_literal: true

# 1420. Build Array Where You Can Find The Maximum Exactly K Comparisons
# Hard
# https://leetcode.com/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons

=begin
You are given three integers n, m and k. Consider the following algorithm to find the maximum element of an array of positive integers:
You should build the array arr which has the following properties:
* arr has exactly n integers.
* 1 <= arr[i] <= m where (0 <= i < n).
* After applying the mentioned algorithm to arr, the value search_cost is equal to k.
Return the number of ways to build the array arr under the mentioned conditions. As the answer may grow large, the answer must be computed modulo 109 + 7.

Example 1:
Input: n = 2, m = 3, k = 1
Output: 6
Explanation: The possible arrays are [1, 1], [2, 1], [2, 2], [3, 1], [3, 2] [3, 3]

Example 2:
Input: n = 5, m = 2, k = 3
Output: 0
Explanation: There are no possible arrays that satisify the mentioned conditions.

Example 3:
Input: n = 9, m = 1, k = 1
Output: 1
Explanation: The only possible array is [1, 1, 1, 1, 1, 1, 1, 1, 1]

Constraints:
* 1 <= n <= 50
* 1 <= m <= 100
* 0 <= k <= n
=end

# @param {Integer} n
# @param {Integer} m
# @param {Integer} k
# @return {Integer}
MOD = 1_000_000_007

def num_of_arrays(n, m, k)
  dp = Array.new(n + 1) { Array.new(m + 1) { Array.new(k + 1, 0) } }

  1.upto(m) do |i|
    dp[1][i][1] = 1
  end

  2.upto(n) do |len|
    1.upto(m) do |max_val|
      1.upto(k) do |cost|
        sum = 0
        1.upto(max_val - 1) do |i|
          sum = (sum + dp[len - 1][i][cost - 1]) % MOD
        end
        dp[len][max_val][cost] = (dp[len - 1][max_val][cost] * max_val + sum) % MOD
      end
    end
  end

  ans = 0
  1.upto(m) do |i|
    ans = (ans + dp[n][i][k]) % MOD
  end

  ans
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_num_of_arrays < Test::Unit::TestCase
  def test_
    assert_equal 6, num_of_arrays(2, 3, 1)
    assert_equal 0, num_of_arrays(5, 2, 3)
    assert_equal 1, num_of_arrays(9, 1, 1)
  end
end
"
1422,maximum-score-after-splitting-a-string,"# frozen_string_literal: true

# 1422. Maximum Score After Splitting a String
# Easy
# https://leetcode.com/problems/maximum-score-after-splitting-a-string

=begin
Given a string s of zeros and ones, return the maximum score after splitting the string into two non-empty substrings (i.e. left substring and right substring).
The score after splitting a string is the number of zeros in the left substring plus the number of ones in the right substring.

Example 1:
Input: s = ""011101""
Output: 5
Explanation:
All possible ways of splitting s into two non-empty substrings are:
left = ""0"" and right = ""11101"", score = 1 + 4 = 5
left = ""01"" and right = ""1101"", score = 1 + 3 = 4
left = ""011"" and right = ""101"", score = 1 + 2 = 3
left = ""0111"" and right = ""01"", score = 1 + 1 = 2
left = ""01110"" and right = ""1"", score = 2 + 1 = 3

Example 2:
Input: s = ""00111""
Output: 5
Explanation: When left = ""00"" and right = ""111"", we get the maximum score = 2 + 3 = 5

Example 3:
Input: s = ""1111""
Output: 3

Constraints:
2 <= s.length <= 500
The string s consists of characters '0' and '1' only.
=end

# @param {String} s
# @return {Integer}
def max_score(s)
  result = 0
  (0...s.length - 1).each do |i|
    current_score = 0
    (0..i).each do |j|
      current_score += 1 if s[j] == ""0""
    end
    (i + 1...s.length).each do |j|
      current_score += 1 if s[j] == ""1""
    end
    result = [result, current_score].max
  end
  result
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_max_score < Test::Unit::TestCase
  def test_
    assert_equal 5, max_score(""011101"")
    assert_equal 5, max_score(""00111"")
    assert_equal 3, max_score(""1111"")
  end
end
"
1424,diagonal-traverse-ii,"# frozen_string_literal: true

# 1424. Diagonal Traverse II
# Medium
# https://leetcode.com/problems/diagonal-traverse-ii

=begin
Given a 2D integer array nums, return all elements of nums in diagonal order as shown in the below images.

Example 1:
Input: nums = [[1,2,3],[4,5,6],[7,8,9]]
Output: [1,4,2,7,5,3,8,6,9]

Example 2
Input: nums = [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]
Output: [1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]

Constraints:
1 <= nums.length <= 105
1 <= nums[i].length <= 105
1 <= sum(nums[i].length) <= 105
1 <= nums[i][j] <= 105
=end

# @param {Integer[][]} nums
# @return {Integer[]}
def find_diagonal_order(a)
  r, z = [], a.size
  a.each_with_index do | v, i |
    p = z - i
    v.each_with_index do
      r << [(i + _2 << 20) | p, _1]
    end
  end
  r.sort_by!(&:first).map!(&:last)
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_find_diagonal_order < Test::Unit::TestCase
  def test_
    assert_equal [1, 4, 2, 7, 5, 3, 8, 6, 9], find_diagonal_order([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    assert_equal [1, 6, 2, 8, 7, 3, 9, 4, 12, 10, 5, 13, 11, 14, 15, 16], find_diagonal_order([[1, 2, 3, 4, 5], [6, 7], [8], [9, 10, 11], [12, 13, 14, 15, 16]])
  end
end
"
1425,constrained-subsequence-sum,"# 1425. Constrained Subsequence Sum
# Hard
# https://leetcode.com/problems/constrained-subsequence-sum

=begin
Given an integer array nums and an integer k, return the maximum sum of a non-empty subsequence of that array such that for every two consecutive integers in the subsequence, nums[i] and nums[j], where i < j, the condition j - i <= k is satisfied.
A subsequence of an array is obtained by deleting some number of elements (can be zero) from the array, leaving the remaining elements in their original order.

Example 1:
Input: nums = [10,2,-10,5,20], k = 2
Output: 37
Explanation: The subsequence is [10, 2, 5, 20].

Example 2:
Input: nums = [-1,-2,-3], k = 1
Output: -1
Explanation: The subsequence must be non-empty, so we choose the largest number.

Example 3:
Input: nums = [10,-2,-10,-5,20], k = 2
Output: 23
Explanation: The subsequence is [10, -2, -5, 20].

Constraints:
1 <= k <= nums.length <= 105
-104 <= nums[i] <= 104
=end

# frozen_string_literal: true

# @param {Integer[]} nums
# @param {Integer} k
# @return {Integer}
def constrained_subset_sum(nums, k)
  max_sum = nums[0]
  max_sum_queue = []

  nums.each_with_index do |num, i|
    nums[i] += max_sum_queue.empty? ? 0 : max_sum_queue.first
    max_sum = [max_sum, nums[i]].max

    while !max_sum_queue.empty? && nums[i] > max_sum_queue.last
      max_sum_queue.pop
    end

    if nums[i] > 0
      max_sum_queue << nums[i]
    end

    if i >= k && !max_sum_queue.empty? && max_sum_queue.first == nums[i - k]
      max_sum_queue.shift
    end
  end

  max_sum
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_constrained_subset_sum < Test::Unit::TestCase
  def test_
    assert_equal 37, constrained_subset_sum([10, 2, -10, 5, 20], 2)
    assert_equal(-1, constrained_subset_sum([-1, -2, -3], 1))
    assert_equal 23, constrained_subset_sum([10, -2, -10, -5, 20], 2)
  end
end
"
1431,kids-with-the-greatest-number-of-candies,"# frozen_string_literal: true

# 1431. Kids With the Greatest Number of Candies
# https://leetcode.com/problems/kids-with-the-greatest-number-of-candies/
# Easy

=begin

There are n kids with candies. You are given an integer array candies, where each candies[i] represents the number of candies the ith kid has, and an integer extraCandies, denoting the number of extra candies that you have.

Return a boolean array result of length n, where result[i] is true if, after giving the ith kid all the extraCandies, they will have the greatest number of candies among all the kids, or false otherwise.

Note that multiple kids can have the greatest number of candies.

### Example 1:
Input: candies = [2,3,5,1,3], extraCandies = 3
Output: [true,true,true,false,true]
Explanation: If you give all extraCandies to:
- Kid 1, they will have 2 + 3 = 5 candies, which is the greatest among the kids.
- Kid 2, they will have 3 + 3 = 6 candies, which is the greatest among the kids.
- Kid 3, they will have 5 + 3 = 8 candies, which is the greatest among the kids.
- Kid 4, they will have 1 + 3 = 4 candies, which is not the greatest among the kids.
- Kid 5, they will have 3 + 3 = 6 candies, which is the greatest among the kids.

### Example 2:
Input: candies = [4,2,1,1,2], extraCandies = 1
Output: [true,false,false,false,false]
Explanation: There is only 1 extra candy.
Kid 1 will always have the greatest number of candies, even if a different kid is given the extra candy.

### Example 3:
Input: candies = [12,1,12], extraCandies = 10
Output: [true,false,true]

### Constraints:
* n == candies.length
* 2 <= n <= 100
* 1 <= candies[i] <= 100
* 1 <= extraCandies <= 50

=end

# @param {Integer[]} candies
# @param {Integer} extra_candies
# @return {Boolean[]}
def kids_with_candies(candies, extra_candies)
  candies.each_with_object(candies.max).map { |c, max| c + extra_candies >= max }
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_kids_with_candies < Test::Unit::TestCase
  def test_
    assert_equal [true, true, true, false, true], kids_with_candies([2, 3, 5, 1, 3], 3)
    assert_equal [true, false, false, false, false], kids_with_candies([4, 2, 1, 1, 2], 1)
    assert_equal [true, false, true], kids_with_candies([12, 1, 12], 10)
  end
end
"
1436,destination-city,"# frozen_string_literal: true

# 1436. Destination City
# Easy
# https://leetcode.com/problems/destination-city

=begin
You are given the array paths, where paths[i] = [cityAi, cityBi] means there exists a direct path going from cityAi to cityBi. Return the destination city, that is, the city without any path outgoing to another city.
It is guaranteed that the graph of paths forms a line without any loop, therefore, there will be exactly one destination city.

Example 1:
Input: paths = [[""London"",""New York""],[""New York"",""Lima""],[""Lima"",""Sao Paulo""]]
Output: ""Sao Paulo""
Explanation: Starting at ""London"" city you will reach ""Sao Paulo"" city which is the destination city. Your trip consist of: ""London"" -> ""New York"" -> ""Lima"" -> ""Sao Paulo"".

Example 2:
Input: paths = [[""B"",""C""],[""D"",""B""],[""C"",""A""]]
Output: ""A""
Explanation: All possible trips are:
""D"" -> ""B"" -> ""C"" -> ""A"".
""B"" -> ""C"" -> ""A"".
""C"" -> ""A"".
""A"".
Clearly the destination city is ""A"".

Example 3:
Input: paths = [[""A"",""Z""]]
Output: ""Z""

Constraints:
1 <= paths.length <= 100
paths[i].length == 2
1 <= cityAi.length, cityBi.length <= 10
cityAi != cityBi
All strings consist of lowercase and uppercase English letters and the space character.
=end

# @param {String[][]} paths
# @return {String}
def dest_city(paths)
  path_hash = paths.to_h
  (path_hash.values - path_hash.keys).first
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_dest_city < Test::Unit::TestCase
  def test_
    assert_equal ""Sao Paulo"", dest_city([[""London"", ""New York""], [""New York"", ""Lima""], [""Lima"", ""Sao Paulo""]])
    assert_equal ""A"", dest_city([[""B"", ""C""], [""D"", ""B""], [""C"", ""A""]])
    assert_equal ""Z"", dest_city([[""A"", ""Z""]])
  end
end
"
1441,build-an-array-with-stack-operations,"# frozen_string_literal: true

# 1441. Build an Array With Stack Operations
# Medium
# https://leetcode.com/problems/build-an-array-with-stack-operations

=begin
You are given an integer array target and an integer n.

You have an empty stack with the two following operations:

""Push"": pushes an integer to the top of the stack.
""Pop"": removes the integer on the top of the stack.
You also have a stream of the integers in the range [1, n].
Use the two stack operations to make the numbers in the stack (from the bottom to the top) equal to target. You should follow the following rules:
* If the stream of the integers is not empty, pick the next integer from the stream and push it to the top of the stack.
* If the stack is not empty, pop the integer at the top of the stack.
* If, at any moment, the elements in the stack (from the bottom to the top) are equal to target, do not read new integers from the stream and do not do more operations on the stack.
Return the stack operations needed to build target following the mentioned rules. If there are multiple valid answers, return any of them.

Example 1:
Input: target = [1,3], n = 3
Output: [""Push"",""Push"",""Pop"",""Push""]
Explanation: Initially the stack s is empty. The last element is the top of the stack.
Read 1 from the stream and push it to the stack. s = [1].
Read 2 from the stream and push it to the stack. s = [1,2].
Pop the integer on the top of the stack. s = [1].
Read 3 from the stream and push it to the stack. s = [1,3].

Example 2:
Input: target = [1,2,3], n = 3
Output: [""Push"",""Push"",""Push""]
Explanation: Initially the stack s is empty. The last element is the top of the stack.
Read 1 from the stream and push it to the stack. s = [1].
Read 2 from the stream and push it to the stack. s = [1,2].
Read 3 from the stream and push it to the stack. s = [1,2,3].

Example 3:
Input: target = [1,2], n = 4
Output: [""Push"",""Push""]
Explanation: Initially the stack s is empty. The last element is the top of the stack.
Read 1 from the stream and push it to the stack. s = [1].
Read 2 from the stream and push it to the stack. s = [1,2].
Since the stack (from the bottom to the top) is equal to target, we stop the stack operations.
The answers that read integer 3 from the stream are not accepted.

Constraints:
1 <= target.length <= 100
1 <= n <= 100
1 <= target[i] <= n
target is strictly increasing.
=end

# @param {Integer[]} target
# @param {Integer} n
# @return {String[]}
def build_array(target, n)
  ops = []
  index = 0
  arr = []
  for i in (1..n) do
    break if arr == target
    arr << i
    index += 1
    ops << ""Push""
    if (target[index - 1] != i) && (arr.size > 0)
      arr.pop
      ops << ""Pop""
      index -= 1
    end
  end
  ops
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_build_array < Test::Unit::TestCase
  def test_
    assert_equal [""Push"", ""Push"", ""Pop"", ""Push""], build_array([1, 3], 3)
    assert_equal [""Push"", ""Push"", ""Push""], build_array([1, 2, 3], 3)
    assert_equal [""Push"", ""Push""], build_array([1, 2], 4)
  end
end
"
1444,number-of-ways-of-cutting-a-pizza,"# frozen_string_literal: true

# 1444. Number of Ways of Cutting a Pizza
# https://leetcode.com/problems/number-of-ways-of-cutting-a-pizza

=begin

Given a rectangular pizza represented as a rows x cols matrix containing the following characters: 'A' (an apple) and '.' (empty cell) and given the integer k. You have to cut the pizza into k pieces using k-1 cuts.

For each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.

Return the number of ways of cutting the pizza such that each piece contains at least one apple. Since the answer can be a huge number, return this modulo 10^9 + 7.

### Example 1:
Input: pizza = [""A.."",""AAA"",""...""], k = 3
Output: 3
Explanation: The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.

### Example 2:
Input: pizza = [""A.."",""AA."",""...""], k = 3
Output: 1

### Example 3:
Input: pizza = [""A.."",""A.."",""...""], k = 1
Output: 1

### Constraints:

* 1 <= rows, cols <= 50
* rows == pizza.length
* cols == pizza[i].length
* 1 <= k <= 10
* pizza consists of characters 'A' and '.' only.

=end

# Runtime: 200 ms
# Memory: 211.4 MB
# @param {String[]} pizza
# @param {Integer} k
# @return {Integer}
def ways(pizza, k)
  r, c = pizza.size, pizza[0].size
  ap = Array.new(r + 1).map { Array.new(c + 1, 0) }
  (0...r).reverse_each do |i|
    (0...c).reverse_each do |j|
      x = ?A == pizza[i][j] ? 1 : 0
      ap[i][j] = x + ap[i + 1][j] + ap[i][j + 1] - ap[i + 1][j + 1]
    end
  end
  dp = Array.new(k).map { Array.new(r).map { Array.new(c, 0) } }
  dp[0] = Array.new(r).map.with_index { |_, i| Array.new(c).map.with_index { |_, j| ap[i][j] > 0 ? 1 : 0 } }
  mod = 1000000007
  (1...k).each do |rmn|
    (0...r).each do |i|
      (0...c).each do |j|
        val = 0
        (i + 1...r).each do |ni|
          val += dp[rmn - 1][ni][j] if ap[i][j] - ap[ni][j] > 0
        end
        (j + 1...c).each do |nj|
          val += dp[rmn - 1][i][nj] if ap[i][j] - ap[i][nj] > 0
        end
        dp[rmn][i][j] = val % mod
      end
    end
  end
  dp[k - 1][0][0]
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_ways < Test::Unit::TestCase
  def test_
    assert_equal 3, ways([""A.."", ""AAA"", ""...""], 3)
    assert_equal 1, ways([""A.."", ""AA."", ""...""], 3)
    assert_equal 1, ways([""A.."", ""A.."", ""...""], 1)
  end
end
"
1448,count-good-nodes-in-binary-tree,"# frozen_string_literal: true

# 1448. Count Good Nodes in Binary Tree
# https://leetcode.com/problems/count-good-nodes-in-binary-tree
# Medium

=begin
Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.

Return the number of good nodes in the binary tree.

Example 1:
Input: root = [3,1,4,3,null,1,5]
Output: 4
Explanation: Nodes in blue are good.
Root Node (3) is always a good node.
Node 4 -> (3,4) is the maximum value in the path starting from the root.
Node 5 -> (3,4,5) is the maximum value in the path
Node 3 -> (3,1,3) is the maximum value in the path.

Example 2:
Input: root = [3,3,null,4,2]
Output: 3
Explanation: Node 2 -> (3, 3, 2) is not good, because ""3"" is higher than it.

Example 3:
Input: root = [1]
Output: 1
Explanation: Root is considered as good.

Constraints:
The number of nodes in the binary tree is in the range [1, 10^5].
Each node's value is between [-10^4, 10^4].
=end

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root
# @return {Integer}
def good_nodes(root)
  @count = 0
  dfs(root, [])

  @count
end

def dfs(root, arr)
  return if root.nil?

  @count += 1 if arr.all? { |a| a <= root.val }
  arr << root.val

  dfs(root.left, arr)
  dfs(root.right, arr)

  arr.pop
end
"
1456,maximum-number-of-vowels-in-a-substring-of-given-length,"# frozen_string_literal: true

# 1456. Maximum Number of Vowels in a Substring of Given Length
# https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length
# Medium

=begin
Given a string s and an integer k, return the maximum number of vowel letters in any substring of s with length k.

Vowel letters in English are 'a', 'e', 'i', 'o', and 'u'.

Example 1:
Input: s = ""abciiidef"", k = 3
Output: 3
Explanation: The substring ""iii"" contains 3 vowel letters.

Example 2:
Input: s = ""aeiou"", k = 2
Output: 2
Explanation: Any substring of length 2 contains 2 vowels.

Example 3:
Input: s = ""leetcode"", k = 3
Output: 2
Explanation: ""lee"", ""eet"" and ""ode"" contain 2 vowels.

Constraints:
1 <= s.length <= 105
s consists of lowercase English letters.
1 <= k <= s.length
=end

# @param {String} s
# @param {Integer} k
# @return {Integer}
def max_vowels(s, k)
  (0..s.length - k).map { |i| s[i..i + k - 1].count(""aeiou"") }.max
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_max_vowels < Test::Unit::TestCase
  def test_
    assert_equal 3, max_vowels(""abciiidef"", 3)
    assert_equal 2, max_vowels(""aeiou"", 2)
    assert_equal 2, max_vowels(""leetcode"", 3)
  end
end
"
1457,pseudo-palindromic-paths-in-a-binary-tree,"# frozen_string_literal: true

# 1457. Pseudo-Palindromic Paths in a Binary Tree
# Medium
# https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree

=begin
Given a binary tree where node values are digits from 1 to 9. A path in the binary tree is said to be pseudo-palindromic if at least one permutation of the node values in the path is a palindrome.
Return the number of pseudo-palindromic paths going from the root node to leaf nodes.

Example 1:
Input: root = [2,3,1,3,1,null,1]
Output: 2
Explanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the red path [2,3,3], the green path [2,1,1], and the path [2,3,1]. Among these paths only red path and green path are pseudo-palindromic paths since the red path [2,3,3] can be rearranged in [3,2,3] (palindrome) and the green path [2,1,1] can be rearranged in [1,2,1] (palindrome).

Example 2:
Input: root = [2,1,1,1,3,null,null,null,null,null,1]
Output: 1
Explanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the green path [2,1,1], the path [2,1,3,1], and the path [2,1]. Among these paths only the green path is pseudo-palindromic since [2,1,1] can be rearranged in [1,2,1] (palindrome).

Example 3:
Input: root = [9]
Output: 1

Constraints:
The number of nodes in the tree is in the range [1, 105].
1 <= Node.val <= 9
=end

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root
# @return {Integer}
def pseudo_palindromic_paths (root)
  @answer = 0
  @counter = Array.new(10, 0)
  backtracking(root)
  @answer
end

def backtracking(node)
  @counter[node.val] += 1
  if node.left.nil? && node.right.nil?
    @answer += 1 if palindromic?
  else
    backtracking(node.left) if node.left
    backtracking(node.right) if node.right
  end
  @counter[node.val] -= 1
end

def palindromic?
  even, odd = 0, 0
  @counter.each do |val|
    next if 0 == val
    if val.even?
      even += 1
    else
      odd += 1
    end
  end
  odd <= 1
end
"
1458,max-dot-product-of-two-subsequences,"# frozen_string_literal: true

# 1458. Max Dot Product of Two Subsequences
# Hard
# https://leetcode.com/problems/max-dot-product-of-two-subsequences

=begin
Given two arrays nums1 and nums2.
Return the maximum dot product between non-empty subsequences of nums1 and nums2 with the same length.
A subsequence of a array is a new array which is formed from the original array by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, [2,3,5] is a subsequence of [1,2,3,4,5] while [1,5,3] is not).

Example 1:
Input: nums1 = [2,1,-2,5], nums2 = [3,0,-6]
Output: 18
Explanation: Take subsequence [2,-2] from nums1 and subsequence [3,-6] from nums2.
Their dot product is (2*3 + (-2)*(-6)) = 18.

Example 2:
Input: nums1 = [3,-2], nums2 = [2,-6,7]
Output: 21
Explanation: Take subsequence [3] from nums1 and subsequence [7] from nums2.
Their dot product is (3*7) = 21.

Example 3:
Input: nums1 = [-1,-1], nums2 = [1,1]
Output: -1
Explanation: Take subsequence [-1] from nums1 and subsequence [1] from nums2.
Their dot product is -1.

Constraints:
1 <= nums1.length, nums2.length <= 500
-1000 <= nums1[i], nums2[i] <= 1000
=end

# @param {Integer[]} nums1
# @param {Integer[]} nums2
# @return {Integer}
def max_dot_product(nums1, nums2)
  min1, max1 = nums1.minmax
  min2, max2 = nums2.minmax
  return max1 * min2 if max1 < 0 && min2 > 0
  return min1 * max2 if min1 > 0 && max2 < 0
  dp = Array.new(nums1.size + 1) { Array.new(nums2.size + 1, 0) }
  (0...nums1.size).reverse_each do |i|
    (0...nums2.size).reverse_each do |j|
      tmp = nums1[i] * nums2[j] + dp[i + 1][j + 1]
      dp[i][j] = [tmp, dp[i + 1][j], dp[i][j + 1]].max
    end
  end
  dp[0][0]
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_max_dot_product < Test::Unit::TestCase
  def test_
    assert_equal 18, max_dot_product([2, 1, -2, 5], [3, 0, -6])
    assert_equal 21, max_dot_product([3, -2], [2, -6, 7])
    assert_equal(-1, max_dot_product([-1, -1], [1, 1]))
  end
end
"
1464,maximum-product-of-two-elements-in-an-array,"# frozen_string_literal: true

# 1464. Maximum Product of Two Elements in an Array
# Easy
# https://leetcode.com/problems/maximum-product-of-two-elements-in-an-array

=begin
Given the array of integers nums, you will choose two different indices i and j of that array. Return the maximum value of (nums[i]-1)*(nums[j]-1).

Example 1:
Input: nums = [3,4,5,2]
Output: 12
Explanation: If you choose the indices i=1 and j=2 (indexed from 0), you will get the maximum value, that is, (nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12.

Example 2:
Input: nums = [1,5,4,5]
Output: 16
Explanation: Choosing the indices i=1 and j=3 (indexed from 0), you will get the maximum value of (5-1)*(5-1) = 16.

Example 3:
Input: nums = [3,7]
Output: 12

Constraints:
2 <= nums.length <= 500
1 <= nums[i] <= 10^3
=end

# @param {Integer[]} nums
# @return {Integer}
def max_product(nums)
  vice = max = 0
  nums.each do |num|
    next if num < vice
    vice, max = [num, max].minmax
  end
  (vice - 1) * (max - 1)
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_max_product < Test::Unit::TestCase
  def test_
    assert_equal 12, max_product([3, 4, 5, 2])
    assert_equal 16, max_product([1, 5, 4, 5])
    assert_equal 12, max_product([3, 7])
  end
end
"
1466,eorder-routes-to-make-all-paths-lead-to-the-city-zero,"# frozen_string_literal: true

# 1466. Reorder Routes to Make All Paths Lead to the City Zero
# https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero

=begin

There are n cities numbered from 0 to n - 1 and n - 1 roads such that there is only one way to travel between two different cities (this network form a tree). Last year, The ministry of transport decided to orient the roads in one direction because they are too narrow.

Roads are represented by connections where connections[i] = [ai, bi] represents a road from city ai to city bi.

This year, there will be a big event in the capital (city 0), and many people want to travel to this city.

Your task consists of reorienting some roads such that each city can visit the city 0. Return the minimum number of edges changed.

It's guaranteed that each city can reach city 0 after reorder.

### Example 1:
Input: n = 6, connections = [[0,1],[1,3],[2,3],[4,0],[4,5]]
Output: 3
Explanation: Change the direction of edges show in red such that each node can reach the node 0 (capital).

### Example 2:
Input: n = 5, connections = [[1,0],[1,2],[3,2],[3,4]]
Output: 2
Explanation: Change the direction of edges show in red such that each node can reach the node 0 (capital).

### Example 3:
Input: n = 3, connections = [[1,0],[2,0]]
Output: 0

=end

# Runtime 396 ms
# Memory 234 MB
# @param {Integer} n
# @param {Integer[][]} connections
# @return {Integer}
def min_reorder(n, connections)
  al = {}
  connections.each do |c|
    al[c[0]] = al[c[0]].to_a + [c[1]]
    al[c[1]] = al[c[1]].to_a + [-c[0]]
  end

  dfs(al, [], 0)
end

def dfs(al, visited, from)
  change = 0
  visited[from] = true

  al[from].each do |to|
    unless visited[to.abs]
      change += dfs(al, visited, to.abs) + (to > 0 ? 1 : 0)
    end
  end

  change
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_min_reorder < Test::Unit::TestCase
  def test_
    assert_equal 3, min_reorder(6, [[0, 1], [1, 3], [2, 3], [4, 0], [4, 5]])
    assert_equal 2, min_reorder(5, [[1, 0], [1, 2], [3, 2], [3, 4]])
    assert_equal 0, min_reorder(3, [[1, 0], [2, 0]])
  end
end
"
1470,shuffle-the-array,"# frozen_string_literal: true

# 1470. Shuffle the Array
# https://leetcode.com/problems/shuffle-the-array

# @param {Integer[]} nums
# @param {Integer} n
# @return {Integer[]}
def shuffle(nums, n)
  result = []

  n.times do |i|
    result << nums[i]
    result << nums[i + n]
  end

  result
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_shuffle < Test::Unit::TestCase
  def test_
    assert_equal [2, 3, 5, 4, 1, 7], shuffle([2, 5, 1, 3, 4, 7], 3)
    assert_equal [1, 4, 2, 3, 3, 2, 4, 1], shuffle([1, 2, 3, 4, 4, 3, 2, 1], 4)
    assert_equal [1, 2, 1, 2], shuffle([1, 1, 2, 2], 2)
  end
end
"
1472,design-browser-history,"# frozen_string_literal: true

# 1472. Design Browser History
# https://leetcode.com/problems/design-browser-history

=begin

You have a browser of one tab where you start on the homepage and you can visit another url, get back in the history number of steps or move forward in the history number of steps.

Implement the BrowserHistory class:

* BrowserHistory(string homepage) Initializes the object with the homepage of the browser.
* void visit(string url) Visits url from the current page. It clears up all the forward history.
* string back(int steps) Move steps back in history. If you can only return x steps in the history and steps > x, you will return only x steps. Return the current url after moving back in history at most steps.
* string forward(int steps) Move steps forward in history. If you can only forward x steps in the history and steps > x, you will forward only x steps. Return the current url after forwarding in history at most steps.

### Constraints:

* 1 <= homepage.length <= 20
* 1 <= url.length <= 20
* 1 <= steps <= 100
* homepage and url consist of  '.' or lower case English letters.
* At most 5000 calls will be made to visit, back, and forward.

=end

class BrowserHistory
=begin
  :type homepage: String
=end
  def initialize(homepage)
    @sites = [homepage]
    @cur = 0
  end


=begin
  :type String
  :rtype: Void
=end
  def visit(url)
    @cur += 1
    # @sites[@cur..@sites.length] = nil
    @sites = @sites.slice(0, @cur)
    @sites[@cur] = url
  end


=begin
  :type steps: Integer
  :rtype: String
=end
  def back(steps)
    @cur = [@cur - steps, 0].max
    @sites[@cur]
  end


=begin
  :type steps: Integer
  :rtype: String
=end
  def forward(steps)
    @cur = [@cur + steps, @sites.length - 1].min
    @sites[@cur]
  end
end

# Your BrowserHistory object will be instantiated and called as such:
# obj = BrowserHistory.new(homepage)
# obj.visit(url)
# param_2 = obj.back(steps)
# param_3 = obj.forward(steps)
"
1480,running-sum-of-1d-array,"# frozen_string_literal: true

# 1480. Running Sum of 1d Array
# https://leetcode.com/problems/running-sum-of-1d-array

=begin

Given an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]nums[i]).

Return the running sum of nums.

### Example 1:
Input: nums = [1,2,3,4]
Output: [1,3,6,10]
Explanation: Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4].

### Example 2:
Input: nums = [1,1,1,1,1]
Output: [1,2,3,4,5]
Explanation: Running sum is obtained as follows: [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1].

### Example 3:
Input: nums = [3,1,2,10,1]
Output: [3,4,6,16,17]

### Constraints:

* 1 <= nums.length <= 1000
* -10^6 <= nums[i] <= 10^6
=end

# Runtime 96 ms
# Memory 211.1 MB
# @param {Integer[]} nums
# @return {Integer[]}
def running_sum(nums)
  nums.reduce([]) { _1 << _2 + (_1.last || 0) }
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_running_sum < Test::Unit::TestCase
  def test_
    assert_equal [1, 3, 6, 10], running_sum([1, 2, 3, 4])
    assert_equal [1, 2, 3, 4, 5], running_sum([1, 1, 1, 1, 1])
    assert_equal [3, 4, 6, 16, 17], running_sum([3, 1, 2, 10, 1])
  end
end
"
1489,find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree,"# frozen_string_literal: true

# 1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree
# Hard
# https://leetcode.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree

=begin
Given a weighted undirected connected graph with n vertices numbered from 0 to n - 1, and an array edges where edges[i] = [ai, bi, weighti] represents a bidirectional and weighted edge between nodes ai and bi. A minimum spanning tree (MST) is a subset of the graph's edges that connects all vertices without cycles and with the minimum possible total edge weight.
Find all the critical and pseudo-critical edges in the given graph's minimum spanning tree (MST). An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge. On the other hand, a pseudo-critical edge is that which can appear in some MSTs but not all.
Note that you can return the indices of the edges in any order.

Example 1:
Input: n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]
Output: [[0,1],[2,3,4,5]]
Explanation: The figure above describes the graph.
The following figure shows all the possible MSTs:
Notice that the two edges 0 and 1 appear in all MSTs, therefore they are critical edges, so we return them in the first list of the output.
The edges 2, 3, 4, and 5 are only part of some MSTs, therefore they are considered pseudo-critical edges. We add them to the second list of the output.

Example 2:
Input: n = 4, edges = [[0,1,1],[1,2,1],[2,3,1],[0,3,1]]
Output: [[],[0,1,2,3]]
Explanation: We can observe that since all 4 edges have equal weight, choosing any 3 edges from the given 4 will yield an MST. Therefore all 4 edges are pseudo-critical.

Constraints:
* 2 <= n <= 100
* 1 <= edges.length <= min(200, n * (n - 1) / 2)
* edges[i].length == 3
* 0 <= ai < bi < n
* 1 <= weighti <= 1000
* All pairs (ai, bi) are distinct.
=end

# @param {Integer} n
# @param {Integer[][]} edges
# @return {Integer[][]}
def find_critical_and_pseudo_critical_edges(n, e)
  return [[*n.pred.times], []] if e.size == n.pred
  e.each_with_index { _1 << _2 } .sort_by! { _1[-2] }
  msu = -> s, sf do
    p, c, r = n.times.to_a, [1] * n, 0
    f = -> x { p[x] == x ? x : (p[x] = f.(p[x])) }
    u = Proc.new do | a, b, x, i |
      next if (ra = f.(a)) == (rb = f.(b))
      ra, rb = rb, ra if c[ra] < c[rb]
      r += x; p[rb] = ra
      return r if (c[ra] += c[rb]) == n
    end
    u.(*e[s]) if !sf && s < e.size
    s = e[s].last if s < e.size
    e.each do | a, b, x, i |
      next if i == s
      u.(a, b, x, i)
    end
    1e6
  end
  t, c, p = msu.(200, false), [], []
  e.size.times do | s |
    i = e[s].last
    c << i if t < msu.(s, true)
    p << i if t == msu.(s, false)
  end
  [c, p - c]
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_length_of_longest_substring < Test::Unit::TestCase
  def test_
    assert_equal [[0, 1], [2, 3, 4, 5]], find_critical_and_pseudo_critical_edges(5, [[0, 1, 1], [1, 2, 1], [2, 3, 2], [0, 3, 2], [0, 4, 3], [3, 4, 3], [1, 4, 6]])
    assert_equal [[], [0, 1, 2, 3]], find_critical_and_pseudo_critical_edges(4, [[0, 1, 1], [1, 2, 1], [2, 3, 1], [0, 3, 1]])
  end
end
"
1491,average-salary-excluding-the-minimum-and-maximum-salary,"# frozen_string_literal: true

# 1491. Average Salary Excluding the Minimum and Maximum Salary
# https://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary
# Easy

=begin
You are given an array of unique integers salary where salary[i] is the salary of the ith employee.

Return the average salary of employees excluding the minimum and maximum salary. Answers within 10-5 of the actual answer will be accepted.

Example 1:
Input: salary = [4000,3000,1000,2000]
Output: 2500.00000
Explanation: Minimum salary and maximum salary are 1000 and 4000 respectively.
Average salary excluding minimum and maximum salary is (2000+3000) / 2 = 2500

Example 2:
Input: salary = [1000,2000,3000]
Output: 2000.00000
Explanation: Minimum salary and maximum salary are 1000 and 3000 respectively.
Average salary excluding minimum and maximum salary is (2000) / 1 = 2000

Constraints:
* 3 <= salary.length <= 100
* 1000 <= salary[i] <= 106
* All the integers of salary are unique.
=end

# @param {Integer[]} salary
# @return {Float}
def average(salary)
  (salary.sum - salary.minmax.sum) / (salary.size - 2.0)
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_average < Test::Unit::TestCase
  def test_
    assert_equal 2500.0, average([4000, 3000, 1000, 2000])
    assert_equal 2000.0, average([1000, 2000, 3000])
  end
end
"
1493,longest-subarray-of-1s-after-deleting-one-element,"# frozen_string_literal: true

# 1493. Longest Subarray of 1's After Deleting One Element
# https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element
# Medium

=begin
Given a binary array nums, you should delete one element from it.

Return the size of the longest non-empty subarray containing only 1's in the resulting array. Return 0 if there is no such subarray.

Example 1:
Input: nums = [1,1,0,1]
Output: 3
Explanation: After deleting the number in position 2, [1,1,1] contains 3 numbers with value of 1's.

Example 2:
Input: nums = [0,1,1,1,0,1,1,0,1]
Output: 5
Explanation: After deleting the number in position 4, [0,1,1,1,1,1,0,1] longest subarray with value of 1's is [1,1,1,1,1].

Example 3:
Input: nums = [1,1,1]
Output: 2
Explanation: You must delete one element.

Constraints:
1 <= nums.length <= 105
nums[i] is either 0 or 1.
=end

# @param {Integer[]} nums
# @return {Integer}
def longest_subarray(nums)
  left = 0
  right = 0
  k = 1
  max = 0

  n = nums.size
  while right < n
    if nums[right] == 0
      k -= 1
      while k < 0
        k += 1 if nums[left] == 0
        left += 1
      end
    end
    max = [max, right - left].max

    right += 1
  end

  max
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_longest_subarray < Test::Unit::TestCase
  def test_
    assert_equal 3, longest_subarray([1, 1, 0, 1])
    assert_equal 5, longest_subarray([0, 1, 1, 1, 0, 1, 1, 0, 1])
    assert_equal 2, longest_subarray([1, 1, 1])
  end
end
"
1498,number-of-subsequences-that-satisfy-the-given-sum-condition,"# frozen_string_literal: true

# 1498. Number of Subsequences That Satisfy the Given Sum Condition
# https://leetcode.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition
# Medium

=begin
You are given an array of integers nums and an integer target.

Return the number of non-empty subsequences of nums such that the sum of the minimum and maximum element on it is less or equal to target. Since the answer may be too large, return it modulo 109 + 7.

Example 1:
Input: nums = [3,5,6,7], target = 9
Output: 4
Explanation: There are 4 subsequences that satisfy the condition.
[3] -> Min value + max value <= target (3 + 3 <= 9)
[3,5] -> (3 + 5 <= 9)
[3,5,6] -> (3 + 6 <= 9)
[3,6] -> (3 + 6 <= 9)

Example 2:
Input: nums = [3,3,6,8], target = 10
Output: 6
Explanation: There are 6 subsequences that satisfy the condition. (nums can have repeated numbers).
[3] , [3] , [3,3], [3,6] , [3,6] , [3,3,6]

Example 3:
Input: nums = [2,3,3,4,6,7], target = 12
Output: 61
Explanation: There are 63 non-empty subsequences, two of them do not satisfy the condition ([6,7], [7]).
Number of valid subsequences (63 - 2 = 61).

Constraints:
1 <= nums.length <= 105
1 <= nums[i] <= 106
1 <= target <= 106
=end

# @param {Integer[]} nums
# @param {Integer} target
# @return {Integer}
def num_subseq(nums, target)
  nums.sort!

  result = 0

  nums.each_with_index do |num, index|
    break if (num * 2) > target

    max_index = (nums.bsearch_index { |num_searched| num_searched > (target - num) } || nums.size) - 1
    result += 2**(max_index - index)
  end

  result % (10**9 + 7)
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_num_subseq < Test::Unit::TestCase
  def test_
    assert_equal 4, num_subseq([3, 5, 6, 7], 9)
    assert_equal 6, num_subseq([3, 3, 6, 8], 10)
    assert_equal 61, num_subseq([2, 3, 3, 4, 6, 7], 12)
  end
end
"
1502,can-make-arithmetic-progression-from-sequence,"# frozen_string_literal: true

# https://leetcode.com/problems/can-make-arithmetic-progression-from-sequence
# 1502. Can Make Arithmetic Progression From Sequence
# Easy

=begin
A sequence of numbers is called an arithmetic progression if the difference between any two consecutive elements is the same.

Given an array of numbers arr, return true if the array can be rearranged to form an arithmetic progression. Otherwise, return false.

Example 1:
Input: arr = [3,5,1]
Output: true
Explanation: We can reorder the elements as [1,3,5] or [5,3,1] with differences 2 and -2 respectively, between each consecutive elements.

Example 2:
Input: arr = [1,2,4]
Output: false
Explanation: There is no way to reorder the elements to obtain an arithmetic progression.

Constraints:
* 2 <= arr.length <= 1000
* -106 <= arr[i] <= 106
=end

# @param {Integer[]} arr
# @return {Boolean}
def can_make_arithmetic_progression(arr)
  arr.sort!
  diff = arr[1] - arr[0]
  for i in 1..(arr.length - 2)
    return false if arr[i + 1] - arr[i] != diff
  end

  true
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_can_make_arithmetic_progression < Test::Unit::TestCase
  def test_
    assert_equal true, can_make_arithmetic_progression([3, 5, 1])
    assert_equal false, can_make_arithmetic_progression([1, 2, 4])
  end
end
"
1503,last-moment-before-all-ants-fall-out-of-a-plank,"# frozen_string_literal: true

# 1503. Last Moment Before All Ants Fall Out of a Plank
# Medium
# https://leetcode.com/problems/last-moment-before-all-ants-fall-out-of-a-plank

=begin
We have a wooden plank of the length n units. Some ants are walking on the plank, each ant moves with a speed of 1 unit per second. Some of the ants move to the left, the other move to the right.

When two ants moving in two different directions meet at some point, they change their directions and continue moving again. Assume changing directions does not take any additional time.
When an ant reaches one end of the plank at a time t, it falls out of the plank immediately.
Given an integer n and two integer arrays left and right, the positions of the ants moving to the left and the right, return the moment when the last ant(s) fall out of the plank.

Example 1:
Input: n = 4, left = [4,3], right = [0,1]
Output: 4
Explanation: In the image above:
-The ant at index 0 is named A and going to the right.
-The ant at index 1 is named B and going to the right.
-The ant at index 3 is named C and going to the left.
-The ant at index 4 is named D and going to the left.
The last moment when an ant was on the plank is t = 4 seconds. After that, it falls immediately out of the plank. (i.e., We can say that at t = 4.0000000001, there are no ants on the plank).

Example 2:
Input: n = 7, left = [], right = [0,1,2,3,4,5,6,7]
Output: 7
Explanation: All ants are going to the right, the ant at index 0 needs 7 seconds to fall.

Example 3:
Input: n = 7, left = [0,1,2,3,4,5,6,7], right = []
Output: 7
Explanation: All ants are going to the left, the ant at index 7 needs 7 seconds to fall.

Constraints:
1 <= n <= 104
0 <= left.length <= n + 1
0 <= left[i] <= n
0 <= right.length <= n + 1
0 <= right[i] <= n
1 <= left.length + right.length <= n + 1
All values of left and right are unique, and each value can appear only in one of the two arrays.
=end

# @param {Integer} n
# @param {Integer[]} left
# @param {Integer[]} right
# @return {Integer}
def get_last_moment(n, left, right)
  t = 0

  unless left.empty?
    t = left.max
  end

  unless right.empty?
    t = [t, n - right.min].max
  end
  t
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_get_last_moment < Test::Unit::TestCase
  def test_
    assert_equal 4, get_last_moment(4, [4, 3], [0, 1])
    assert_equal 7, get_last_moment(7, [], [0, 1, 2, 3, 4, 5, 6, 7])
    assert_equal 7, get_last_moment(7, [0, 1, 2, 3, 4, 5, 6, 7], [])
  end
end
"
1514,path-with-maximum-probability,"# frozen_string_literal: true

# 1514. Path with Maximum Probability
# Medium
# https://leetcode.com/problems/path-with-maximum-probability

=begin
You are given an undirected weighted graph of n nodes (0-indexed), represented by an edge list where edges[i] = [a, b] is an undirected edge connecting the nodes a and b with a probability of success of traversing that edge succProb[i].
Given two nodes start and end, find the path with the maximum probability of success to go from start to end and return its success probability.
If there is no path from start to end, return 0. Your answer will be accepted if it differs from the correct answer by at most 1e-5.

Example 1:
Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2
Output: 0.25000
Explanation: There are two paths from start to end, one having a probability of success = 0.2 and the other has 0.5 * 0.5 = 0.25.

Example 2:
Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2
Output: 0.30000

Example 3:
Input: n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2
Output: 0.00000
Explanation: There is no path between 0 and 2.

Constraints:
* 2 <= n <= 10^4
* 0 <= start, end < n
* start != end
* 0 <= a, b < n
* a != b
* 0 <= succProb.length == edges.length <= 2*10^4
* 0 <= succProb[i] <= 1
* There is at most one edge between every two nodes.
=end

# @param {Integer} n
# @param {Integer[][]} edges
# @param {Float[]} succ_prob
# @param {Integer} start_path
# @param {Integer} end_path
# @return {Float}
def max_probability(_, edges, succ_prob, start_path, end_path)
  graph = Hash.new { |h, k| h[k] = [] }
  edges.each.with_index { |(f, t), i|
    prob = succ_prob[i]
    graph[f] << [t, prob]
    graph[t] << [f, prob]
  }

  q = [[1, start_path]]
  v = Set[]

  while (path_prob, node = q.shift)
    next unless v.add?(node)
    return path_prob if node == end_path
    graph[node].each { |node, edge_prob|
      prob = path_prob * edge_prob
      rec = [prob, node]
      i = q.bsearch_index { |q_prob, _| prob > q_prob } || q.size
      q.insert(i, rec)
    }
  end

  0
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_max_probability < Test::Unit::TestCase
  def test_
    assert_equal 0.25000, max_probability(3, [[0, 1], [1, 2], [0, 2]], [0.5, 0.5, 0.2], 0, 2)
    assert_equal 0.30000, max_probability(3, [[0, 1], [1, 2], [0, 2]], [0.5, 0.5, 0.3], 0, 2)
    assert_equal 0.00000, max_probability(3, [[0, 1]], [0.5], 0, 2)
  end
end
"
1523,count-odd-numbers-in-an-interval-range,"# frozen_string_literal: true

# 1523. Count Odd Numbers in an Interval Range
# https://leetcode.com/problems/count-odd-numbers-in-an-interval-range

# @param {Integer} low
# @param {Integer} high
# @return {Integer}
def count_odds(low, high)
  low += 1 if low % 2 == 0

  low > high ? 0 : ((high - low) / 2) + 1
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_count_odds < Test::Unit::TestCase
  def test_
    assert_equal 3, count_odds(3, 7)
    assert_equal 1, count_odds(8, 10)
  end
end
"
1535,find-the-winner-of-an-array-game,"# frozen_string_literal: true

# 1535. Find the Winner of an Array Game
# Medium
# https://leetcode.com/problems/find-the-winner-of-an-array-game

=begin
Given an integer array arr of distinct integers and an integer k.
A game will be played between the first two elements of the array (i.e. arr[0] and arr[1]). In each round of the game, we compare arr[0] with arr[1], the larger integer wins and remains at position 0, and the smaller integer moves to the end of the array. The game ends when an integer wins k consecutive rounds.
Return the integer which will win the game.
It is guaranteed that there will be a winner of the game.

Example 1:
Input: arr = [2,1,3,5,4,6,7], k = 2
Output: 5
Explanation: Let's see the rounds of the game:
Round |       arr       | winner | win_count
  1   | [2,1,3,5,4,6,7] | 2      | 1
  2   | [2,3,5,4,6,7,1] | 3      | 1
  3   | [3,5,4,6,7,1,2] | 5      | 1
  4   | [5,4,6,7,1,2,3] | 5      | 2
So we can see that 4 rounds will be played and 5 is the winner because it wins 2 consecutive games.

Example 2:
Input: arr = [3,2,1], k = 10
Output: 3
Explanation: 3 will win the first 10 rounds consecutively.

Constraints:
2 <= arr.length <= 105
1 <= arr[i] <= 106
arr contains distinct integers.
1 <= k <= 109
=end

# @param {Integer[]} arr
# @param {Integer} k
# @return {Integer}
def get_winner(arr, k)
  max_val, count = arr[0], 0
  (1...arr.length).each do |i|
    if max_val < arr[i]
      max_val = arr[i]
      count = 0
    end
    count += 1
    return max_val if count == k
  end
  max_val
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_get_winner < Test::Unit::TestCase
  def test_
    assert_equal 5, get_winner([2, 1, 3, 5, 4, 6, 7], 2)
    assert_equal 3, get_winner([3, 2, 1], 10)
  end
end
"
1539,kth-missing-positive-number,"# frozen_string_literal: true

# 1539. Kth Missing Positive Number
# https://leetcode.com/problems/kth-missing-positive-number

# @param {Integer[]} arr
# @param {Integer} k
# @return {Integer}
def find_kth_positive(arr, k)
  left = 0
  right = arr.length

  while left < right
    middle = (left + right) / 2

    if arr[middle] - 1 - middle < k
      left = middle + 1
    else
      right = middle
    end
  end

  left + k
end

# @param {Integer[]} arr
# @param {Integer} k
# @return {Integer}
def find_kth_positive1(arr, k)
  ((1..(arr.last || 0) + k).to_a - arr)[k - 1]
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""

class Test_find_kth_positive < Test::Unit::TestCase
  def test_
    assert_equal 9, find_kth_positive([2, 3, 4, 7, 11], 5)
    assert_equal 6, find_kth_positive([1, 2, 3, 4], 2)

    assert_equal 9, find_kth_positive1([2, 3, 4, 7, 11], 5)
    assert_equal 6, find_kth_positive1([1, 2, 3, 4], 2)
  end
end

# ********************#
#     Benchmark       #
# ********************#

require ""benchmark""

arr = [1, 2, 3, 4, 7, 10, 11]
k = 5
Benchmark.bm do |x|
  x.report(""find_kth_positive: "") { find_kth_positive(arr, k) }
  x.report(""find_kth_positive1: "") { find_kth_positive1(arr, k) }
end

# user     system      total        real
# find_kth_positive:   0.000012   0.000003   0.000015 (  0.000010)
# find_kth_positive1:   0.000015   0.000003   0.000018 (  0.000017)
"
1547,minimum-cost-to-cut-a-stick,"# frozen_string_literal: true

# 1547. Minimum Cost to Cut a Stick
# https://leetcode.com/problems/minimum-cost-to-cut-a-stick
# Hard

=begin
Given a wooden stick of length n units. The stick is labelled from 0 to n. For example, a stick of length 6 is labelled as follows:

Given an integer array cuts where cuts[i] denotes a position you should perform a cut at.

You should perform the cuts in order, you can change the order of the cuts as you wish.

The cost of one cut is the length of the stick to be cut, the total cost is the sum of costs of all cuts. When you cut a stick, it will be split into two smaller sticks (i.e. the sum of their lengths is the length of the stick before the cut). Please refer to the first example for a better explanation.

Return the minimum total cost of the cuts.

Example 1:
Input: n = 7, cuts = [1,3,4,5]
Output: 16
Explanation: Using cuts order = [1, 3, 4, 5] as in the input leads to the following scenario:
The first cut is done to a rod of length 7 so the cost is 7. The second cut is done to a rod of length 6 (i.e. the second part of the first cut), the third is done to a rod of length 4 and the last cut is to a rod of length 3. The total cost is 7 + 6 + 4 + 3 = 20.
Rearranging the cuts to be [3, 5, 1, 4] for example will lead to a scenario with total cost = 16 (as shown in the example photo 7 + 4 + 3 + 2 = 16).

Example 2:
Input: n = 9, cuts = [5,6,1,4,2]
Output: 22
Explanation: If you try the given cuts ordering the cost will be 25.
There are much ordering with total cost <= 25, for example, the order [4, 6, 5, 2, 1] has total cost = 22 which is the minimum possible.:

Constraints:
* 2 <= n <= 106
* 1 <= cuts.length <= min(n - 1, 100)
* 1 <= cuts[i] <= n - 1
* All the integers in cuts array are distinct.
=end

# @param {Integer} n
# @param {Integer[]} cuts
# @return {Integer}
def min_cost(n, cuts)
  cuts = [0] + cuts + [n]
  cuts.sort!

  m = cuts.length

  memo = Array.new(m) { Array.new(m) { 0 } }

  (2..m - 1).each do |diff|
    (0..m - diff - 1).each do |left|
      right = left + diff
      ans = (left + 1..right - 1).map do |mid|
        memo[left][mid] + memo[mid][right]
      end.min
      ans += cuts[right] - cuts[left]
      memo[left][right] = ans
    end
  end

  memo[0][m - 1]
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""

class Test_min_cost < Test::Unit::TestCase
  def test_
    assert_equal 16, min_cost(7, [1, 3, 4, 5])
    assert_equal 22, min_cost(9, [5, 6, 1, 4, 2])
  end
end
"
1557,minimum-number-of-vertices-to-reach-all-nodes,"# frozen_string_literal: true

# 1557. Minimum Number of Vertices to Reach All Nodes
# https://leetcode.com/problems/minimum-number-of-vertices-to-reach-all-nodes
# Medium

=begin
Given a directed acyclic graph, with n vertices numbered from 0 to n-1, and an array edges where edges[i] = [fromi, toi] represents a directed edge from node fromi to node toi.

Find the smallest set of vertices from which all nodes in the graph are reachable. It's guaranteed that a unique solution exists.

Notice that you can return the vertices in any order.

Example 1:
Input: n = 6, edges = [[0,1],[0,2],[2,5],[3,4],[4,2]]
Output: [0,3]
Explanation: It's not possible to reach all the nodes from a single vertex. From 0 we can reach [0,1,2,5]. From 3 we can reach [3,4,2,5]. So we output [0,3].

Example 2:
Input: n = 5, edges = [[0,1],[2,1],[3,1],[1,4],[2,4]]
Output: [0,2,3]
Explanation: Notice that vertices 0, 3 and 2 are not reachable from any other node, so we must include them. Also any of these vertices can reach nodes 1 and 4.

Constraints:
2 <= n <= 10^5
1 <= edges.length <= min(10^5, n * (n - 1) / 2)
edges[i].length == 2
0 <= fromi, toi < n
All pairs (fromi, toi) are distinct.
=end

# @param {Integer} n
# @param {Integer[][]} edges
# @return {Integer[]}
def find_smallest_set_of_vertices(n, edges)
  (0...n).to_a - edges.map(&:last)
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""

class Test_find_smallest_set_of_vertices < Test::Unit::TestCase
  def test_
    assert_equal [0, 3], find_smallest_set_of_vertices(6, [[0, 1], [0, 2], [2, 5], [3, 4], [4, 2]])
    assert_equal [0, 2, 3], find_smallest_set_of_vertices(5, [[0, 1], [2, 1], [3, 1], [1, 4], [2, 4]])
  end
end
"
1561,maximum-number-of-coins-you-can-get,"# frozen_string_literal: true

# 1561. Maximum Number of Coins You Can Get
# Medium
# https://leetcode.com/problems/maximum-number-of-coins-you-can-get

=begin
There are 3n piles of coins of varying size, you and your friends will take piles of coins as follows:
* In each step, you will choose any 3 piles of coins (not necessarily consecutive).
* Of your choice, Alice will pick the pile with the maximum number of coins.
* You will pick the next pile with the maximum number of coins.
* Your friend Bob will pick the last pile.
* Repeat until there are no more piles of coins.
Given an array of integers piles where piles[i] is the number of coins in the ith pile.
Return the maximum number of coins that you can have.

Example 1:
Input: piles = [2,4,1,2,7,8]
Output: 9
Explanation: Choose the triplet (2, 7, 8), Alice Pick the pile with 8 coins, you the pile with 7 coins and Bob the last one.
Choose the triplet (1, 2, 4), Alice Pick the pile with 4 coins, you the pile with 2 coins and Bob the last one.
The maximum number of coins which you can have are: 7 + 2 = 9.
On the other hand if we choose this arrangement (1, 2, 8), (2, 4, 7) you only get 2 + 4 = 6 coins which is not optimal.

Example 2:
Input: piles = [2,4,5]
Output: 4

Example 3:
Input: piles = [9,8,7,6,5,1,2,3,4]
Output: 18

Constraints:
3 <= piles.length <= 105
piles.length % 3 == 0
1 <= piles[i] <= 104
=end

# @param {Integer[]} piles
# @return {Integer}
def max_coins(piles)
  piles.sort!

  j = 0
  i = piles.length - 2
  sum = 0

  while i > j do
    sum += piles[i]
    i -= 2
    j += 1
  end

  sum
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_max_coins < Test::Unit::TestCase
  def test_
    assert_equal 9, max_coins([2, 4, 1, 2, 7, 8])
    assert_equal 4, max_coins([2, 4, 5])
    assert_equal 18, max_coins([9, 8, 7, 6, 5, 1, 2, 3, 4])
  end
end
"
1569,number-of-ways-to-reorder-array-to-get-same-bst,"# frozen_string_literal: true

# https://leetcode.com/problems/number-of-ways-to-reorder-array-to-get-same-bst
# 1569. Number of Ways to Reorder Array to Get Same BST
# Medium

=begin
Given an array nums that represents a permutation of integers from 1 to n. We are going to construct a binary search tree (BST) by inserting the elements of nums in order into an initially empty BST. Find the number of different ways to reorder nums so that the constructed BST is identical to that formed from the original array nums.
* For example, given nums = [2,1,3], we will have 2 as the root, 1 as a left child, and 3 as a right child. The array [2,3,1] also yields the same BST but [3,2,1] yields a different BST.
Return the number of ways to reorder nums such that the BST formed is identical to the original BST formed from nums.

Since the answer may be very large, return it modulo 109 + 7.

Example 1:
Input: nums = [2,1,3]
Output: 1
Explanation: We can reorder nums to be [2,3,1] which will yield the same BST. There are no other ways to reorder nums which will yield the same BST.

Example 2:
Input: nums = [3,4,5,1,2]
Output: 5
Explanation: The following 5 arrays will yield the same BST:
[3,1,2,4,5]
[3,1,4,2,5]
[3,1,4,5,2]
[3,4,1,2,5]
[3,4,1,5,2]

Example 3:
Input: nums = [1,2,3]
Output: 0
Explanation: There are no other orderings of nums that will yield the same BST.

Constraints:
* 1 <= nums.length <= 1000
* 1 <= nums[i] <= nums.length
* All integers in nums are distinct.
=end

# @param {Integer[]} nums
# @return {Integer}
MOD = 1_000_000_007

def num_of_ways(nums)
  bst_permutations(nums) - 1
end

def bst_permutations(nums)
  if nums.empty?
    1
  else
    root_val = nums.shift
    partitions = nums.partition { _1 < root_val }
    comb(*partitions.map(&:size)) * partitions.map { bst_permutations _1 }.reduce(:*) % MOD
  end
end

def comb(a, b)
  if a > b
    comb(b, a)
  else
    (b + 1..b + a).reduce(1, :*) / (1..a).reduce(1, :*)
  end
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""

class Test_num_of_ways < Test::Unit::TestCase
  def test_
    assert_equal 1, num_of_ways([2, 1, 3])
    assert_equal 5, num_of_ways([3, 4, 5, 1, 2])
    assert_equal 0, num_of_ways([1, 2, 3])
  end
end
"
1572,matrix-diagonal-sum,"# frozen_string_literal: true

# 1572. Matrix Diagonal Sum
# https://leetcode.com/problems/matrix-diagonal-sum
# Easy

=begin
Given a square matrix mat, return the sum of the matrix diagonals.

Only include the sum of all the elements on the primary diagonal and all the elements on the secondary diagonal that are not part of the primary diagonal.

Example 1:
Input: mat = [[1,2,3],
              [4,5,6],
              [7,8,9]]
Output: 25
Explanation: Diagonals sum: 1 + 5 + 9 + 3 + 7 = 25
Notice that element mat[1][1] = 5 is counted only once.

Example 2:
Input: mat = [[1,1,1,1],
              [1,1,1,1],
              [1,1,1,1],
              [1,1,1,1]]
Output: 8

Example 3:
Input: mat = [[5]]
Output: 5

Constraints:
n == mat.length == mat[i].length
1 <= n <= 100
1 <= mat[i][j] <= 100
=end

# @param {Integer[][]} mat
# @return {Integer}
def diagonal_sum(mat)
  size = mat.size
  sum = 0
  (0...size).each { |i| sum += mat[i][i] + mat[i][size - 1 - i] }
  if size.odd?
    sum -= mat[size / 2][size / 2]
  end
  sum
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""

class Test_diagonal_sum < Test::Unit::TestCase
  def test_
    assert_equal 25, diagonal_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    assert_equal 8, diagonal_sum([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]])
    assert_equal 5, diagonal_sum([[5]])
  end
end
"
1575,count-all-possible-routes,"# frozen_string_literal: true

# 1575. Count All Possible Routes
# Hard
# https://leetcode.com/problems/count-all-possible-routes

=begin
You are given an array of distinct positive integers locations where locations[i] represents the position of city i. You are also given integers start, finish and fuel representing the starting city, ending city, and the initial amount of fuel you have, respectively.
At each step, if you are at city i, you can pick any city j such that j != i and 0 <= j < locations.length and move to city j. Moving from city i to city j reduces the amount of fuel you have by |locations[i] - locations[j]|. Please notice that |x| denotes the absolute value of x.
Notice that fuel cannot become negative at any point in time, and that you are allowed to visit any city more than once (including start and finish).
Return the count of all possible routes from start to finish. Since the answer may be too large, return it modulo 109 + 7.

Example 1:
Input: locations = [2,3,6,8,4], start = 1, finish = 3, fuel = 5
Output: 4
Explanation: The following are all possible routes, each uses 5 units of fuel:
1 -> 3
1 -> 2 -> 3
1 -> 4 -> 3
1 -> 4 -> 2 -> 3

Example 2:
Input: locations = [4,3,1], start = 1, finish = 0, fuel = 6
Output: 5
Explanation: The following are all possible routes:
1 -> 0, used fuel = 1
1 -> 2 -> 0, used fuel = 5
1 -> 2 -> 1 -> 0, used fuel = 5
1 -> 0 -> 1 -> 0, used fuel = 3
1 -> 0 -> 1 -> 0 -> 1 -> 0, used fuel = 5

Example 3:
Input: locations = [5,2,1], start = 0, finish = 2, fuel = 3
Output: 0
Explanation: It is impossible to get from 0 to 2 using only 3 units of fuel since the shortest route needs 4 units of fuel.

Constraints:
* 2 <= locations.length <= 100
* 1 <= locations[i] <= 109
* All integers in locations are distinct.
* 0 <= start, finish < locations.length
* 1 <= fuel <= 200
=end

# @param {Integer[]} locations
# @param {Integer} start
# @param {Integer} finish
# @param {Integer} fuel
# @return {Integer}
def count_routes(locations, start, finish, fuel)
  mod = 1000000007

  @memo = Array.new(locations.length) { {} }
  @locations = locations
  @finish = finish
  num_routes(start, fuel) % mod
end

def num_routes(curr, fuel)
  return @memo[curr][fuel] if @memo[curr][fuel]
  return 0 if fuel < 0

  val = @locations[curr]
  options = []

  @locations.each_with_index do |location, i|
    if i != curr
      options << num_routes(i, fuel - (location - val).abs)
    end
  end

  @memo[curr][fuel] = options.sum + (curr == @finish ? 1 : 0)
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_count_routes < Test::Unit::TestCase
  def test_
    assert_equal 4, count_routes([2, 3, 6, 8, 4], 1, 3, 5)
    assert_equal 5, count_routes([4, 3, 1], 1, 0, 6)
    assert_equal 0, count_routes([5, 2, 1], 0, 2, 3)
  end
end
"
1579,remove-max-number-of-edges-to-keep-graph-fully-traversable,"# frozen_string_literal: true

# 1579. Remove Max Number of Edges to Keep Graph Fully Traversable
# https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable
# Hard

=begin
Alice and Bob have an undirected graph of n nodes and three types of edges:

Type 1: Can be traversed by Alice only.
Type 2: Can be traversed by Bob only.
Type 3: Can be traversed by both Alice and Bob.
Given an array edges where edges[i] = [typei, ui, vi] represents a bidirectional edge of type typei between nodes ui and vi, find the maximum number of edges you can remove so that after removing the edges, the graph can still be fully traversed by both Alice and Bob. The graph is fully traversed by Alice and Bob if starting from any node, they can reach all other nodes.

Return the maximum number of edges you can remove, or return -1 if Alice and Bob cannot fully traverse the graph.

Example 1:
Input: n = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]
Output: 2
Explanation: If we remove the 2 edges [1,1,2] and [1,1,3]. The graph will still be fully traversable by Alice and Bob. Removing any additional edge will not make it so. So the maximum number of edges we can remove is 2.

Example 2:
Input: n = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]]
Output: 0
Explanation: Notice that removing any edge will not make the graph fully traversable by Alice and Bob.

Example 3:
Input: n = 4, edges = [[3,2,3],[1,1,2],[2,3,4]]
Output: -1
Explanation: In the current graph, Alice cannot reach node 4 from the other nodes. Likewise, Bob cannot reach 1. Therefore it's impossible to make the graph fully traversable.

Constraints:
* 1 <= n <= 105
* 1 <= edges.length <= min(105, 3 * n * (n - 1) / 2)
* edges[i].length == 3
* 1 <= typei <= 3
* 1 <= ui < vi <= n
* All tuples (typei, ui, vi) are distinct.
=end

# @param {Integer} n
# @param {Integer[][]} edges
# @return {Integer}
def max_num_edges_to_remove(n, edges)
  nodes = Array.new(n) { |index| Node.new(index) }

  alice_edges_count = 0
  bob_edges_count = 0
  both_edges_count = 0

  edges.each do |type, first_node_index, second_node_index|
    first_node_index -= 1
    second_node_index -= 1

    if type == 1
      alice_edges_count += 1
      nodes[first_node_index].next_nodes[:alice] << nodes[second_node_index]
      nodes[second_node_index].next_nodes[:alice] << nodes[first_node_index]
    elsif type == 2
      bob_edges_count += 1
      nodes[first_node_index].next_nodes[:bob] << nodes[second_node_index]
      nodes[second_node_index].next_nodes[:bob] << nodes[first_node_index]
    else

      both_edges_count += 1
      nodes[first_node_index].next_nodes[:both] << nodes[second_node_index]
      nodes[second_node_index].next_nodes[:both] << nodes[first_node_index]
    end
  end

  return -1 if check_nodes_for_one_person(nodes, :alice) == -1
  return -1 if check_nodes_for_one_person(nodes, :bob) == -1

  needed_individual_edges_count = check_both_edges_only(nodes)

  alice_edges_count + bob_edges_count + (both_edges_count - (n - 1)) - needed_individual_edges_count
end

def check_nodes_for_one_person(nodes, label)
  @checked = Array.new(nodes.size, nil)
  check_node(nodes[0], label)

  -1 if @checked.include? nil
end

def check_both_edges_only(nodes)
  @checked = Array.new(nodes.size, nil)
  @checked.each_with_index do |_, node_val|
    next if @checked[node_val]

    check_both(nodes[node_val], node_val)
  end

  @checked.uniq.count - 1
end

def check_node(node, label)
  return if @checked[node.val]

  @checked[node.val] = true
  node.next_nodes[label].each do |next_node|
    check_node(next_node, label)
  end

  node.next_nodes[:both].each do |next_node|
    check_node(next_node, label)
  end
end

def check_both(node, label)
  return if @checked[node.val]

  @checked[node.val] = label

  node.next_nodes[:both].each do |next_node|
    check_both(next_node, label)
  end
end

class Node
  attr_reader :val, :next_nodes

  def initialize(val)
    @val = val
    @next_nodes = { alice: [], bob: [], both: [] }
  end
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_max_num_edges_to_remove < Test::Unit::TestCase
  def test_
    assert_equal 2, max_num_edges_to_remove(4, [[3, 1, 2], [3, 2, 3], [1, 1, 3], [1, 2, 4], [1, 1, 2], [2, 3, 4]])
    assert_equal 0, max_num_edges_to_remove(4, [[3, 1, 2], [3, 2, 3], [1, 1, 4], [2, 1, 4]])
    assert_equal(-1, max_num_edges_to_remove(4, [[3, 2, 3], [1, 1, 2], [2, 3, 4]]))
  end
end
"
1584,min-cost-to-connect-all-points,"# frozen_string_literal: true

# 1584. Min Cost to Connect All Points
# Medium
# https://leetcode.com/problems/min-cost-to-connect-all-points

=begin
You are given an array points representing integer coordinates of some points on a 2D-plane, where points[i] = [xi, yi].
The cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance between them: |xi - xj| + |yi - yj|, where |val| denotes the absolute value of val.
Return the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points.

Example 1:
Input: points = [[0,0],[2,2],[3,10],[5,2],[7,0]]
Output: 20
Explanation:
We can connect the points as shown above to get the minimum cost of 20.
Notice that there is a unique path between every pair of points.

Example 2:
Input: points = [[3,12],[-2,5],[-4,1]]
Output: 18

Constraints:
* 1 <= points.length <= 1000
* -106 <= xi, yi <= 106
* All pairs (xi, yi) are distinct.
=end

# @param {Integer[][]} points
# @return {Integer}
# @param {Integer[][]} points
# @return {Integer}
def min_cost_connect_points(points)
  return 0 if points.length == 1

  min_dist = Array.new(points.length, Float::MAX)
  cost = 0
  cur = 0
  connected_edges = 1
  len = points.length
  visited = Array.new(len, false)
  visited[0] = true
  while connected_edges < points.length
    min_edge = Float::MAX
    next_edge = -1
    (0..points.length - 1).each do |i|
      next if i == cur
      if !visited[i]
        dist = (points[cur][0] - points[i][0]).abs + (points[cur][1] - points[i][1]).abs
        min_dist[i] = [dist, min_dist[i]].min
        if min_edge > min_dist[i]
          min_edge = min_dist[i]
          next_edge = i
        end
      end
    end
    cost = cost + min_edge
    cur = next_edge
    visited[cur] = true
    connected_edges = connected_edges + 1
  end
  cost
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_min_cost_connect_points < Test::Unit::TestCase
  def test_
    assert_equal 20, min_cost_connect_points([[0, 0], [2, 2], [3, 10], [5, 2], [7, 0]])
    assert_equal 18, min_cost_connect_points([[3, 12], [-2, 5], [-4, 1]])
  end
end
"
1601,maximum-number-of-achievable-transfer-requests,"# frozen_string_literal: true

# 1601. Maximum Number of Achievable Transfer Requests
# Hard
# https://leetcode.com/problems/maximum-number-of-achievable-transfer-requests

=begin
We have n buildings numbered from 0 to n - 1. Each building has a number of employees. It's transfer season, and some employees want to change the building they reside in.
You are given an array requests where requests[i] = [fromi, toi] represents an employee's request to transfer from building fromi to building toi.
All buildings are full, so a list of requests is achievable only if for each building, the net change in employee transfers is zero. This means the number of employees leaving is equal to the number of employees moving in. For example if n = 3 and two employees are leaving building 0, one is leaving building 1, and one is leaving building 2, there should be two employees moving to building 0, one employee moving to building 1, and one employee moving to building 2.
Return the maximum number of achievable requests.

Example 1:
Input: n = 5, requests = [[0,1],[1,0],[0,1],[1,2],[2,0],[3,4]]
Output: 5
Explantion: Let's see the requests:
From building 0 we have employees x and y and both want to move to building 1.
From building 1 we have employees a and b and they want to move to buildings 2 and 0 respectively.
From building 2 we have employee z and they want to move to building 0.
From building 3 we have employee c and they want to move to building 4.
From building 4 we don't have any requests.
We can achieve the requests of users x and b by swapping their places.
We can achieve the requests of users y, a and z by swapping the places in the 3 buildings.

Example 2:
Input: n = 3, requests = [[0,0],[1,2],[2,1]]
Output: 3
Explantion: Let's see the requests:
From building 0 we have employee x and they want to stay in the same building 0.
From building 1 we have employee y and they want to move to building 2.
From building 2 we have employee z and they want to move to building 1.
We can achieve all the requests.

Example 3:
Input: n = 4, requests = [[0,3],[3,1],[1,2],[2,0]]
Output: 4
=end

# @param {Integer} n
# @param {Integer[][]} requests
# @return {Integer}
def maximum_requests(n, requests)
  b = [nil] * n
  for c in (0..requests.size).reverse_each
    requests.combination(c).each do | v |
      b.fill 0
      v.each do | i, j |
        b[i] -= 1
        b[j] += 1
      end
      return c if b.all?(&:zero?)
    end
  end
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_maximum_requests < Test::Unit::TestCase
  def test_
    assert_equal 5, maximum_requests(5, [[0, 1], [1, 0], [0, 1], [1, 2], [2, 0], [3, 4]])
    assert_equal 3, maximum_requests(3, [[0, 0], [1, 2], [2, 1]])
    assert_equal 4, maximum_requests(4, [[0, 3], [3, 1], [1, 2], [2, 0]])
  end
end
"
1603,design-parking-system,"# frozen_string_literal: true

# 1603. Design Parking System
# https://leetcode.com/problems/design-parking-system
# Easy

=begin
Design a parking system for a parking lot. The parking lot has three kinds of parking spaces: big, medium, and small, with a fixed number of slots for each size.
Implement the ParkingSystem class:
* ParkingSystem(int big, int medium, int small) Initializes object of the ParkingSystem class. The number of slots for each parking space are given as part of the constructor.
* bool addCar(int carType) Checks whether there is a parking space of carType for the car that wants to get into the parking lot. carType can be of three kinds: big, medium, or small, which are represented by 1, 2, and 3 respectively. A car can only park in a parking space of its carType. If there is no space available, return false, else park the car in that size space and return true.

Example 1:
Input
[""ParkingSystem"", ""addCar"", ""addCar"", ""addCar"", ""addCar""]
[[1, 1, 0], [1], [2], [3], [1]]
Output
[null, true, true, false, false]
Explanation
ParkingSystem parkingSystem = new ParkingSystem(1, 1, 0);
parkingSystem.addCar(1); // return true because there is 1 available slot for a big car
parkingSystem.addCar(2); // return true because there is 1 available slot for a medium car
parkingSystem.addCar(3); // return false because there is no available slot for a small car
parkingSystem.addCar(1); // return false because there is no available slot for a big car. It is already occupied.

Constraints:
* 0 <= big, medium, small <= 1000
* carType is 1, 2, or 3
* At most 1000 calls will be made to addCar
=end

class ParkingSystem
=begin
    :type big: Integer
    :type medium: Integer
    :type small: Integer
=end
  def initialize(big, medium, small)
    @space = [big, medium, small]
  end

=begin
    :type car_type: Integer
    :rtype: Boolean
=end
  def add_car(car_type)
    -1 < @space[car_type - 1] -= 1
  end
end

# Your ParkingSystem object will be instantiated and called as such:
# obj = ParkingSystem.new(big, medium, small)
# param_1 = obj.add_car(car_type)
"
1611,minimum-one-bit-operations-to-make-integers-zero,"# frozen_string_literal: true

# 1611. Minimum One Bit Operations to Make Integers Zero
# Hard
# https://leetcode.com/problems/minimum-one-bit-operations-to-make-integers-zero

=begin
Given an integer n, you must transform it into 0 using the following operations any number of times:
* Change the rightmost (0th) bit in the binary representation of n.
* Change the ith bit in the binary representation of n if the (i-1)th bit is set to 1 and the (i-2)th through 0th bits are set to 0.
Return the minimum number of operations to transform n into 0.

Example 1:
Input: n = 3
Output: 2
Explanation: The binary representation of 3 is ""11"".
""11"" -> ""01"" with the 2nd operation since the 0th bit is 1.
""01"" -> ""00"" with the 1st operation.

Example 2:
Input: n = 6
Output: 4
Explanation: The binary representation of 6 is ""110"".
""110"" -> ""010"" with the 2nd operation since the 1st bit is 1 and 0th through 0th bits are 0.
""010"" -> ""011"" with the 1st operation.
""011"" -> ""001"" with the 2nd operation since the 0th bit is 1.
""001"" -> ""000"" with the 1st operation.

Constraints:
0 <= n <= 109
=end

# @param {Integer} n
# @return {Integer}
def minimum_one_bit_operations(n)
  result = 0
  temp = n
  while temp != 0
    result ^= temp
    temp = temp / 2
  end
  result
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_minimum_one_bit_operations < Test::Unit::TestCase
  def test_
    assert_equal 2, minimum_one_bit_operations(3)
    assert_equal 4, minimum_one_bit_operations(6)
  end
end
"
1615,maximal-network-rank,"# frozen_string_literal: true

# 1615. Maximal Network Rank
# Medium
# https://leetcode.com/problems/maximal-network-rank

=begin
There is an infrastructure of n cities with some number of roads connecting these cities. Each roads[i] = [ai, bi] indicates that there is a bidirectional road between cities ai and bi.
The network rank of two different cities is defined as the total number of directly connected roads to either city. If a road is directly connected to both cities, it is only counted once.
The maximal network rank of the infrastructure is the maximum network rank of all pairs of different cities.
Given the integer n and the array roads, return the maximal network rank of the entire infrastructure.

Example 1:
Input: n = 4, roads = [[0,1],[0,3],[1,2],[1,3]]
Output: 4
Explanation: The network rank of cities 0 and 1 is 4 as there are 4 roads that are connected to either 0 or 1. The road between 0 and 1 is only counted once.

Example 2:
Input: n = 5, roads = [[0,1],[0,3],[1,2],[1,3],[2,3],[2,4]]
Output: 5
Explanation: There are 5 roads that are connected to cities 1 or 2.

Example 3:
Input: n = 8, roads = [[0,1],[1,2],[2,3],[2,4],[5,6],[5,7]]
Output: 5
Explanation: The network rank of 2 and 5 is 5. Notice that all the cities do not have to be connected.

Constraints:
* 2 <= n <= 100
* 0 <= roads.length <= n * (n - 1) / 2
* roads[i].length == 2
* 0 <= ai, bi <= n-1
* ai != bi
=end

# @param {Integer} n
# @param {Integer[][]} roads
# @return {Integer}
def maximal_network_rank(n, roads)
  digit_rank = Array.new(n, 0)
  is_connected = Array.new(n) { Array.new(n, false) }
  max_rank = 0

  roads.each do |road|
    a, b = road
    digit_rank[a] += 1
    digit_rank[b] += 1
    is_connected[a][b] = true
    is_connected[b][a] = true
  end

  for i in 0...n
    for j in i + 1...n
      rank = digit_rank[i] + digit_rank[j]
      # remove the double count of the common road
      rank -= 1 if is_connected[i][j]
      max_rank = [max_rank, rank].max
    end
  end

  max_rank
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_maximal_network_rank < Test::Unit::TestCase
  def test_
    assert_equal 4, maximal_network_rank(4, [[0, 1], [0, 3], [1, 2], [1, 3]])
    assert_equal 5, maximal_network_rank(5, [[0, 1], [0, 3], [1, 2], [1, 3], [2, 3], [2, 4]])
    assert_equal 5, maximal_network_rank(8, [[0, 1], [1, 2], [2, 3], [2, 4], [5, 6], [5, 7]])
  end
end
"
1630,arithmetic-subarrays,"# frozen_string_literal: true

# 1630. Arithmetic Subarrays
# Medium
# https://leetcode.com/problems/arithmetic-subarrays

=begin
A sequence of numbers is called arithmetic if it consists of at least two elements, and the difference between every two consecutive elements is the same. More formally, a sequence s is arithmetic if and only if s[i+1] - s[i] == s[1] - s[0] for all valid i.
For example, these are arithmetic sequences:
| 1, 3, 5, 7, 9
| 7, 7, 7, 7
| 3, -1, -5, -9
The following sequence is not arithmetic:
| 1, 1, 2, 5, 7
You are given an array of n integers, nums, and two arrays of m integers each, l and r, representing the m range queries, where the ith query is the range [l[i], r[i]]. All the arrays are 0-indexed.

Return a list of boolean elements answer, where answer[i] is true if the subarray nums[l[i]], nums[l[i]+1], ... , nums[r[i]] can be rearranged to form an arithmetic sequence, and false otherwise.

Example 1:
Input: nums = [4,6,5,9,3,7], l = [0,0,2], r = [2,3,5]
Output: [true,false,true]
Explanation:
In the 0th query, the subarray is [4,6,5]. This can be rearranged as [6,5,4], which is an arithmetic sequence.
In the 1st query, the subarray is [4,6,5,9]. This cannot be rearranged as an arithmetic sequence.
In the 2nd query, the subarray is [5,9,3,7]. This can be rearranged as [3,5,7,9], which is an arithmetic sequence.

Example 2:
Input: nums = [-12,-9,-3,-12,-6,15,20,-25,-20,-15,-10], l = [0,1,6,4,8,7], r = [4,4,9,7,9,10]
Output: [false,true,false,false,true,true]

Constraints:
n == nums.length
m == l.length
m == r.length
2 <= n <= 500
1 <= m <= 500
0 <= l[i] < r[i] < n
-105 <= nums[i] <= 105
=end

# @param {Integer[]} nums
# @param {Integer[]} l
# @param {Integer[]} r
# @return {Boolean[]}
def check_arithmetic_subarrays(nums, l, r)
  result = []

  for i in(0).upto(l.size - 1)
    left = l[i]
    right = r[i]
    arr = nums[left..right].sort!
    distence = arr[1] - arr[0]
    arithmetic = true
    for j in(0).upto(arr.size - 2)
      if (arr[j + 1] - arr[j]) != distence
        arithmetic = false
        break
      end
    end
    result << arithmetic
  end

  result
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_check_arithmetic_subarrays < Test::Unit::TestCase
  def test_
    assert_equal [true, false, true], check_arithmetic_subarrays(
      [4, 6, 5, 9, 3, 7],
      [0, 0, 2],
      [2, 3, 5]
    )
    assert_equal [false, true, false, false, true, true], check_arithmetic_subarrays(
      [-12, -9, -3, -12, -6, 15, 20, -25, -20, -15, -10],
      [0, 1, 6, 4, 8, 7],
      [4, 4, 9, 7, 9, 10]
    )
  end
end
"
1631,path-with-minimum-effort,"# frozen_string_literal: true

# 1631. Path With Minimum Effort
# Medium
# https://leetcode.com/problems/path-with-minimum-effort

=begin
You are a hiker preparing for an upcoming hike. You are given heights, a 2D array of size rows x columns, where heights[row][col] represents the height of cell (row, col). You are situated in the top-left cell, (0, 0), and you hope to travel to the bottom-right cell, (rows-1, columns-1) (i.e., 0-indexed). You can move up, down, left, or right, and you wish to find a route that requires the minimum effort.
A route's effort is the maximum absolute difference in heights between two consecutive cells of the route.
Return the minimum effort required to travel from the top-left cell to the bottom-right cell.

Example 1:
Input: heights = [[1,2,2],[3,8,2],[5,3,5]]
Output: 2
Explanation: The route of [1,3,5,3,5] has a maximum absolute difference of 2 in consecutive cells.
This is better than the route of [1,2,2,2,5], where the maximum absolute difference is 3.

Example 2:
Input: heights = [[1,2,3],[3,8,4],[5,3,5]]
Output: 1
Explanation: The route of [1,2,3,4,5] has a maximum absolute difference of 1 in consecutive cells, which is better than route [1,3,5,3,5].

Example 3:
Input: heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]
Output: 0
Explanation: This route does not require any effort.

Constraints:
* rows == heights.length
* columns == heights[i].length
* 1 <= rows, columns <= 100
* 1 <= heights[i][j] <= 106
=end

# @param {Integer[][]} heights
# @return {Integer}
def minimum_effort_path(heights)
  h = heights.size
  w = heights[0].size
  queue = [[0, 0]]
  cost = Array.new(h).map { Array.new(w, Float::INFINITY) }
  cost[0][0] = 0
  directions = [[1, 0], [0, 1], [-1, 0], [0, -1]]
  inside = ->(rr, cc) { rr.between?(0, h - 1) && cc.between?(0, w - 1) }
  while ! queue.empty?
    r, c = queue.pop()
    curr_h = heights[r][c]
    curr_c = cost[r][c]
    directions.each do |(dr, dc)|
      r1, c1 = r + dr, c + dc
      if inside[r1, c1]
        nh = heights[r1][c1]
        nc = (curr_h - nh).abs > curr_c ? (curr_h - nh).abs : curr_c
        if nc < cost[r1][c1]
          cost[r1][c1] = nc
          queue.unshift [r1, c1]
        end
      end
    end
  end
  cost[h - 1][w - 1]
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_minimum_effort_path < Test::Unit::TestCase
  def test_
    assert_equal 2, minimum_effort_path([[1, 2, 2], [3, 8, 2], [5, 3, 5]])
    assert_equal 1, minimum_effort_path([[1, 2, 3], [3, 8, 4], [5, 3, 5]])
    assert_equal 0, minimum_effort_path([[1, 2, 1, 1, 1], [1, 2, 1, 2, 1], [1, 2, 1, 2, 1], [1, 2, 1, 2, 1], [1, 1, 1, 2, 1]])
  end
end
"
1637,widest-vertical-area-between-two-points-containing-no-points,"# frozen_string_literal: true

# 1637. Widest Vertical Area Between Two Points Containing No Points
# Medium
# https://leetcode.com/problems/widest-vertical-area-between-two-points-containing-no-points

=begin
Given n points on a 2D plane where points[i] = [xi, yi], Return the widest vertical area between two points such that no points are inside the area.
A vertical area is an area of fixed-width extending infinitely along the y-axis (i.e., infinite height). The widest vertical area is the one with the maximum width.
Note that points on the edge of a vertical area are not considered included in the area.

Example 1:
Input: points = [[8,7],[9,9],[7,4],[9,7]]
Output: 1
Explanation: Both the red and the blue area are optimal.

Example 2:
Input: points = [[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]]
Output: 3

Constraints:
n == points.length
2 <= n <= 105
points[i].length == 2
0 <= xi, yi <= 109
=end

# @param {Integer[][]} points
# @return {Integer}
def max_width_of_vertical_area(points)
  points.sort! { |a, b| a[0] - b[0] }

  max_width = 0

  (1...points.length).each do |i|
    width = points[i][0] - points[i - 1][0]
    max_width = [max_width, width].max
  end

  max_width
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_max_width_of_vertical_area < Test::Unit::TestCase
  def test_
    assert_equal 1, max_width_of_vertical_area([[8, 7], [9, 9], [7, 4], [9, 7]])
    assert_equal 3, max_width_of_vertical_area([[3, 1], [9, 0], [1, 0], [1, 4], [5, 3], [8, 8]])
  end
end
"
1639,number-of-ways-to-form-a-target-string-given-a-dictionary,"# frozen_string_literal: true

# 1639. Number of Ways to Form a Target String Given a Dictionary
# https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary
# Hard

=begin

You are given a list of strings of the same length words and a string target.

Your task is to form target using the given words under the following rules:

* target should be formed from left to right.
* To form the ith character (0-indexed) of target, you can choose the kth character of the jth string in words if target[i] = words[j][k].
* Once you use the kth character of the jth string of words, you can no longer use the xth character of any string in words where x <= k. In other words, all characters to the left of or at index k become unusuable for every string.
* Repeat the process until you form the string target.
Notice that you can use multiple characters from the same string in words provided the conditions above are met.

Return the number of ways to form target from words. Since the answer may be too large, return it modulo 109 + 7.

### Example 1:
Input: words = [""acca"",""bbbb"",""caca""], target = ""aba""
Output: 6
Explanation: There are 6 ways to form target.
""aba"" -> index 0 (""acca""), index 1 (""bbbb""), index 3 (""caca"")
""aba"" -> index 0 (""acca""), index 2 (""bbbb""), index 3 (""caca"")
""aba"" -> index 0 (""acca""), index 1 (""bbbb""), index 3 (""acca"")
""aba"" -> index 0 (""acca""), index 2 (""bbbb""), index 3 (""acca"")
""aba"" -> index 1 (""caca""), index 2 (""bbbb""), index 3 (""acca"")
""aba"" -> index 1 (""caca""), index 2 (""bbbb""), index 3 (""caca"")

### Example 2:
Input: words = [""abba"",""baab""], target = ""bab""
Output: 4
Explanation: There are 4 ways to form target.
""bab"" -> index 0 (""baab""), index 1 (""baab""), index 2 (""abba"")
""bab"" -> index 0 (""baab""), index 1 (""baab""), index 3 (""baab"")
""bab"" -> index 0 (""baab""), index 2 (""baab""), index 3 (""baab"")
""bab"" -> index 1 (""abba""), index 2 (""baab""), index 3 (""baab"")

### Constraints:
* 1 <= words.length <= 1000
* 1 <= words[i].length <= 1000
* All strings in words have the same length.
* 1 <= target.length <= 1000
* words[i] and target contain only lowercase English letters.

=end

# @param {String[]} words
# @param {String} target
# @return {Integer}
def num_ways1(words, target)
  alph, mod, m, k = 26, 1000000007, target.size, words[0].size
  cnt = Array.new(alph).map { Array.new(k, 0) }
  (0...k).each do |j|
    words.each do |word|
      cnt[word[j].ord - ?a.ord][j] += 1
    end
  end
  dp = Array.new(m + 1).map { Array.new(k + 1, 0) }
  dp[0][0] = 1
  (0..m).each do |i|
    (0...k).each do |j|
      if i < m
        a = cnt[target[i].ord - ?a.ord][j]
        dp[i + 1][j + 1] += a * dp[i][j]
        dp[i + 1][j + 1] %= mod
      end
      dp[i][j + 1] += dp[i][j]
      dp[i][j + 1] %= mod
    end
  end
  dp[m][k]
end

def num_ways(words, target)
  words.map(&:chars).transpose.map(&:tally).then(&ways = -> a, i = 0, j = 0, m = [] {
    target[a.size - j + i] ? 0 : !target[i] ? 1 : m[i * a.size + j] ||=
    (ways[a, i, j + 1, m] + a[j][target[i]].to_i * ways[a, i + 1, j + 1, m]) % 1000000007 })
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""

class Test_num_ways < Test::Unit::TestCase
  def test_
    assert_equal 6, num_ways([""acca"", ""bbbb"", ""caca""], ""aba"")
    assert_equal 4, num_ways([""abba"", ""baab""], ""bab"")
  end
end
"
1647,minimum-deletions-to-make-character-frequencies-unique,"# frozen_string_literal: true

# 1647. Minimum Deletions to Make Character Frequencies Unique
# Medium
# https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique

=begin
A string s is called good if there are no two different characters in s that have the same frequency.
Given a string s, return the minimum number of characters you need to delete to make s good.
The frequency of a character in a string is the number of times it appears in the string. For example, in the string ""aab"", the frequency of 'a' is 2, while the frequency of 'b' is 1.

Example 1:
Input: s = ""aab""
Output: 0
Explanation: s is already good.

Example 2:
Input: s = ""aaabbbcc""
Output: 2
Explanation: You can delete two 'b's resulting in the good string ""aaabcc"".
Another way it to delete one 'b' and one 'c' resulting in the good string ""aaabbc"".

Example 3:
Input: s = ""ceabaacb""
Output: 2
Explanation: You can delete both 'c's resulting in the good string ""eabaab"".
Note that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).


Constraints:
* 1 <= s.length <= 105
* s contains only lowercase English letters.
=end

# @param {String} s
# @return {Integer}
def min_deletions(s)
  cnt = s.chars.tally.values.sort
  cnt[0...-1].reverse_each.inject([0, cnt.last]) { |(d, prev), cc|
    dif = (cc < prev) ? 0 : (cc - prev + (prev.zero? ? 0 : 1))
    [d + dif, cc - dif]
  }.first
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_min_deletions < Test::Unit::TestCase
  def test_
    assert_equal 0, min_deletions(""aab"")
    assert_equal 2, min_deletions(""aaabbbcc"")
    assert_equal 2, min_deletions(""ceabaacb"")
  end
end
"
1657,determine-if-two-strings-are-close,"# frozen_string_literal: true

# 1657. Determine if Two Strings Are Close
# https://leetcode.com/problems/determine-if-two-strings-are-close
# Medium

=begin
Two strings are considered close if you can attain one from the other using the following operations:

Operation 1: Swap any two existing characters.
For example, abcde -> aecdb
Operation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character.
For example, aacabb -> bbcbaa (all a's turn into b's, and all b's turn into a's)
You can use the operations on either string as many times as necessary.

Given two strings, word1 and word2, return true if word1 and word2 are close, and false otherwise.

Example 1:
Input: word1 = ""abc"", word2 = ""bca""
Output: true
Explanation: You can attain word2 from word1 in 2 operations.
Apply Operation 1: ""abc"" -> ""acb""
Apply Operation 1: ""acb"" -> ""bca""

Example 2:
Input: word1 = ""a"", word2 = ""aa""
Output: false
Explanation: It is impossible to attain word2 from word1, or vice versa, in any number of operations.

Example 3:
Input: word1 = ""cabbba"", word2 = ""abbccc""
Output: true
Explanation: You can attain word2 from word1 in 3 operations.
Apply Operation 1: ""cabbba"" -> ""caabbb""
Apply Operation 2: ""caabbb"" -> ""baaccc""
Apply Operation 2: ""baaccc"" -> ""abbccc""

Constraints:
1 <= word1.length, word2.length <= 105
word1 and word2 contain only lowercase English letters.
=end

# @param {String} word1
# @param {String} word2
# @return {Boolean}
def close_strings(word1, word2)
  word1, word2 = word1.chars, word2.chars

  return false unless word1.uniq.sort.eql? word2.uniq.sort

  word1.tally.values.sort.eql? word2.tally.values.sort
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""

class Test_close_strings < Test::Unit::TestCase
  def test_
    assert_equal true, close_strings(""abc"", ""bca"")
    assert_equal false, close_strings(""a"", ""aa"")
    assert_equal true, close_strings(""cabbba"", ""abbccc"")
  end
end
"
1658,minimum-operations-to-reduce-x-to-zero,"# frozen_string_literal: true

# 1658. Minimum Operations to Reduce X to Zero
# Medium
# https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero

=begin
You are given an integer array nums and an integer x. In one operation, you can either remove the leftmost or the rightmost element from the array nums and subtract its value from x. Note that this modifies the array for future operations.
Return the minimum number of operations to reduce x to exactly 0 if it is possible, otherwise, return -1.

Example 1:
Input: nums = [1,1,4,2,3], x = 5
Output: 2
Explanation: The optimal solution is to remove the last two elements to reduce x to zero.

Example 2:
Input: nums = [5,6,7,8,9], x = 4
Output: -1

Example 3:
Input: nums = [3,2,20,1,1,3], x = 10
Output: 5
Explanation: The optimal solution is to remove the last three elements and the first two elements (5 operations in total) to reduce x to zero.

Constraints:
* 1 <= nums.length <= 105
* 1 <= nums[i] <= 104
* 1 <= x <= 109
=end

# @param {Integer[]} nums
# @param {Integer} x
# @return {Integer}
def min_operations(nums, x)
  target = nums.sum - x

  if target == 0
    return nums.length
  end

  left = 0
  right = 0
  curr = 0
  cnt = 0

  while right < nums.length
    curr += nums[right]

    while left < right && curr > target
      curr -= nums[left]
      left += 1
    end

    if curr == target
      cnt = [cnt, right - left + 1].max
    end

    right += 1

  end

  cnt == 0 ? -1 : nums.length - cnt
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_min_operations < Test::Unit::TestCase
  def test_
    assert_equal 2, min_operations([1, 1, 4, 2, 3], 5)
    assert_equal(-1, min_operations([5, 6, 7, 8, 9], 4))
    assert_equal 5, min_operations([3, 2, 20, 1, 1, 3], 10)
  end
end
"
1662,check-if-two-string-arrays-are-equivalent,"# frozen_string_literal: true

# 1662. Check If Two String Arrays are Equivalent
# Easy
# https://leetcode.com/problems/check-if-two-string-arrays-are-equivalent

=begin
Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.
A string is represented by an array if the array elements concatenated in order forms the string.

Example 1:
Input: word1 = [""ab"", ""c""], word2 = [""a"", ""bc""]
Output: true
Explanation:
word1 represents string ""ab"" + ""c"" -> ""abc""
word2 represents string ""a"" + ""bc"" -> ""abc""
The strings are the same, so return true.

Example 2:
Input: word1 = [""a"", ""cb""], word2 = [""ab"", ""c""]
Output: false

Example 3:
Input: word1  = [""abc"", ""d"", ""defg""], word2 = [""abcddefg""]
Output: true

Constraints:
1 <= word1.length, word2.length <= 103
1 <= word1[i].length, word2[i].length <= 103
1 <= sum(word1[i].length), sum(word2[i].length) <= 103
word1[i] and word2[i] consist of lowercase letters.
=end

# @param {String[]} word1
# @param {String[]} word2
# @return {Boolean}
def array_strings_are_equal(word1, word2)
  word1.join == word2.join
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_array_strings_are_equal < Test::Unit::TestCase
  def test_
    assert_equal true, array_strings_are_equal([""ab"", ""c""], [""a"", ""bc""])
    assert_equal false, array_strings_are_equal([""a"", ""cb""], [""ab"", ""c""])
    assert_equal true, array_strings_are_equal([""abc"", ""d"", ""defg""], [""abcddefg""])
  end
end
"
1675,minimize-deviation-in-array,"# frozen_string_literal: true

# 1675. Minimize Deviation in Array
# https://leetcode.com/problems/minimize-deviation-in-array

# @param {Integer[]} nums
# @return {Integer}
def minimum_deviation(nums)
  nums.uniq!
  nums.map! { |x| x.odd? ? x * 2 : x }.sort!
  diff = nums.last - nums.first
  stack = []

  loop do
    if stack.empty? || nums.last.to_i > stack.first
      max = nums.pop
    else
      max = stack.shift
    end

    break if max.odd?

    stack.push max / 2
    max = [stack.first, nums.last].compact.max
    min = [stack.last, nums.first].compact.min
    diff = [diff, max - min].min
  end

  diff
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_minimum_deviation < Test::Unit::TestCase
  def test_
    assert_equal 1, minimum_deviation([1, 2, 3, 4])
    assert_equal 3, minimum_deviation([4, 1, 5, 20, 3])
    assert_equal 3, minimum_deviation([2, 10, 8])
  end
end
"
1679,max-number-of-k-sum-pairs,"# frozen_string_literal: true

# 1679. Max Number of K-Sum Pairs
# https://leetcode.com/problems/max-number-of-k-sum-pairs
# Medium

=begin
You are given an integer array nums and an integer k.

In one operation, you can pick two numbers from the array whose sum equals k and remove them from the array.

Return the maximum number of operations you can perform on the array.

Example 1:
Input: nums = [1,2,3,4], k = 5
Output: 2
Explanation: Starting with nums = [1,2,3,4]:
- Remove numbers 1 and 4, then nums = [2,3]
- Remove numbers 2 and 3, then nums = []
There are no more pairs that sum up to 5, hence a total of 2 operations.

Example 2:
Input: nums = [3,1,3,4,3], k = 6
Output: 1
Explanation: Starting with nums = [3,1,3,4,3]:
- Remove the first two 3's, then nums = [1,4,3]
There are no more pairs that sum up to 6, hence a total of 1 operation.

Constraints:
* 1 <= nums.length <= 105
* 1 <= nums[i] <= 109
* 1 <= k <= 109
=end

# @param {Integer[]} nums
# @param {Integer} k
# @return {Integer}
def max_operations(nums, k)
  h = Hash.new(0)
  out = 0

  nums.each do |num|
    next if num >= k

    if h[k - num] > 0
      h[k - num] -= 1
      out += 1
    else
      h[num] += 1
    end
  end

  out
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_max_operations < Test::Unit::TestCase
  def test_
    assert_equal 2, max_operations([1, 2, 3, 4], 5)
    assert_equal 1, max_operations([3, 1, 3, 4, 3], 6)
  end
end
"
1680,concatenation-of-consecutive-binary-numbers,"# frozen_string_literal: true

# 1680. Concatenation of Consecutive Binary Numbers
# https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers

# @param {Integer} n
# @return {Integer}
MOD = 10**9 + 7
def concatenated_binary(n)
  t = r = 1
  (1..n).reduce(0) do |s, k|
    s = ((s << r) + k) % MOD
    t -= 1
    if t.zero?
      t = 1 << r
      r += 1
    end
    s
  end
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_concatenated_binary < Test::Unit::TestCase
  def test_
    assert_equal 1, concatenated_binary(1)
    assert_equal 27, concatenated_binary(3)
    assert_equal 505_379_714, concatenated_binary(12)
  end
end
"
1685,sum-of-absolute-differences-in-a-sorted-array,"# frozen_string_literal: true

# 1685. Sum of Absolute Differences in a Sorted Array
# Medium
# https://leetcode.com/problems/sum-of-absolute-differences-in-a-sorted-array

=begin
You are given an integer array nums sorted in non-decreasing order.
Build and return an integer array result with the same length as nums such that result[i] is equal to the summation of absolute differences between nums[i] and all the other elements in the array.
In other words, result[i] is equal to sum(|nums[i]-nums[j]|) where 0 <= j < nums.length and j != i (0-indexed).

Example 1:
Input: nums = [2,3,5]
Output: [4,3,5]
Explanation: Assuming the arrays are 0-indexed, then
result[0] = |2-2| + |2-3| + |2-5| = 0 + 1 + 3 = 4,
result[1] = |3-2| + |3-3| + |3-5| = 1 + 0 + 2 = 3,
result[2] = |5-2| + |5-3| + |5-5| = 3 + 2 + 0 = 5.

Example 2:
Input: nums = [1,4,6,8,10]
Output: [24,15,13,15,21]

Constraints:
2 <= nums.length <= 105
1 <= nums[i] <= nums[i + 1] <= 104
=end

# @param {Integer[]} nums
# @return {Integer[]}
def get_sum_absolute_differences(nums)
  n = nums.size
  sum = nums.sum
  prev = nums[0]
  total = sum - prev * n
  result = [total]

  1.upto(n - 1) do |i|
    num = nums[i]
    total += (2 * i - n) * (num - prev)
    result << total
    prev = num
  end

  result
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_get_sum_absolute_differences < Test::Unit::TestCase
  def test_
    assert_equal [4, 3, 5], get_sum_absolute_differences([2, 3, 5])
    assert_equal [24, 15, 13, 15, 21], get_sum_absolute_differences([1, 4, 6, 8, 10])
  end
end
"
1688,count-of-matches-in-tournament,"# frozen_string_literal: true

# 1688. Count of Matches in Tournament
# Easy
# https://leetcode.com/problems/count-of-matches-in-tournament

=begin
You are given an integer n, the number of teams in a tournament that has strange rules:
* If the current number of teams is even, each team gets paired with another team. A total of n / 2 matches are played, and n / 2 teams advance to the next round.
* If the current number of teams is odd, one team randomly advances in the tournament, and the rest gets paired. A total of (n - 1) / 2 matches are played, and (n - 1) / 2 + 1 teams advance to the next round.
Return the number of matches played in the tournament until a winner is decided.

Example 1:
Input: n = 7
Output: 6
Explanation: Details of the tournament:
- 1st Round: Teams = 7, Matches = 3, and 4 teams advance.
- 2nd Round: Teams = 4, Matches = 2, and 2 teams advance.
- 3rd Round: Teams = 2, Matches = 1, and 1 team is declared the winner.
Total number of matches = 3 + 2 + 1 = 6.

Example 2:
Input: n = 14
Output: 13
Explanation: Details of the tournament:
- 1st Round: Teams = 14, Matches = 7, and 7 teams advance.
- 2nd Round: Teams = 7, Matches = 3, and 4 teams advance.
- 3rd Round: Teams = 4, Matches = 2, and 2 teams advance.
- 4th Round: Teams = 2, Matches = 1, and 1 team is declared the winner.
Total number of matches = 7 + 3 + 2 + 1 = 13.

Constraints:
1 <= n <= 200
=end

# @param {Integer} n
# @return {Integer}
def number_of_matches(n)
  matches = 0
  teams_advancing = n

  while teams_advancing > 1 do
    matches += teams_advancing / 2
    teams_advancing = (teams_advancing / 2.0).ceil
  end

  matches
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_number_of_matches < Test::Unit::TestCase
  def test_
    assert_equal 6, number_of_matches(7)
    assert_equal 13, number_of_matches(14)
  end
end
"
1697,checking-existence-of-edge-length-limited-paths,"# frozen_string_literal: true

# 1697. Checking Existence of Edge Length Limited Paths
# https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths
# Hard

=begin
An undirected graph of n nodes is defined by edgeList, where edgeList[i] = [ui, vi, disi] denotes an edge between nodes ui and vi with distance disi. Note that there may be multiple edges between two nodes.

Given an array queries, where queries[j] = [pj, qj, limitj], your task is to determine for each queries[j] whether there is a path between pj and qj such that each edge on the path has a distance strictly less than limitj .

Return a boolean array answer, where answer.length == queries.length and the jth value of answer is true if there is a path for queries[j] is true, and false otherwise.

Example 1:
Input: n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]]
Output: [false,true]
Explanation: The above figure shows the given graph. Note that there are two overlapping edges between 0 and 1 with distances 2 and 16.
For the first query, between 0 and 1 there is no path where each distance is less than 2, thus we return false for this query.
For the second query, there is a path (0 -> 1 -> 2) of two edges with distances less than 5, thus we return true for this query.

Example 2:
Input: n = 5, edgeList = [[0,1,10],[1,2,5],[2,3,9],[3,4,13]], queries = [[0,4,14],[1,4,13]]
Output: [true,false]
Exaplanation: The above figure shows the given graph.

Constraints:
* 2 <= n <= 105
* 1 <= edgeList.length, queries.length <= 105
* edgeList[i].length == 3
* queries[j].length == 3
* 0 <= ui, vi, pj, qj <= n - 1
* ui != vi
* pj != qj
* 1 <= disi, limitj <= 109
* There may be multiple edges between two nodes.
=end

# @param {Integer} n
# @param {Integer[][]} edge_list
# @param {Integer[][]} queries
# @return {Boolean[]}
def distance_limited_paths_exist(n, edge_list, queries)
  par = *0...n
  find = ->(x) { par[x] == x ? x : (par[x] = find[par[x]]) }
  merge = ->(x, y, _w) { par[find[x]] = find[y] }

  ret = Array.new(queries.size, false)

  edges = edge_list.sort_by(&:last)
  qs = queries.map.with_index { |(u, v, w), i| [w, u, v, i] }.sort

  for w, u, v, i in qs
    merge[*edges.shift] while edges.any? && edges.first.last < w
    ret[i] = find[u] == find[v]
  end
  ret
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_distance_limited_paths_exist < Test::Unit::TestCase
  def test_
    assert_equal [false, true], distance_limited_paths_exist(3, [[0, 1, 2], [1, 2, 4], [2, 0, 8], [1, 0, 16]], [[0, 1, 2], [0, 2, 5]])
    assert_equal [true, false], distance_limited_paths_exist(5, [[0, 1, 10], [1, 2, 5], [2, 3, 9], [3, 4, 13]], [[0, 4, 14], [1, 4, 13]])
  end
end
"
1706,where-will-the-ball-fall,"# frozen_string_literal: true

# 1706. Where Will the Ball Fall
# https://leetcode.com/problems/where-will-the-ball-fall

=begin

You have a 2-D grid of size m x n representing a box, and you have n balls. The box is open on the top and bottom sides.

Each cell in the box has a diagonal board spanning two corners of the cell that can redirect a ball to the right or to the left.

A board that redirects the ball to the right spans the top-left corner to the bottom-right corner and is represented in the grid as 1.
A board that redirects the ball to the left spans the top-right corner to the bottom-left corner and is represented in the grid as -1.
We drop one ball at the top of each column of the box. Each ball can get stuck in the box or fall out of the bottom. A ball gets stuck if it hits a ""V"" shaped pattern between two boards or if a board redirects the ball into either wall of the box.

Return an array answer of size n where answer[i] is the column that the ball falls out of at the bottom after dropping the ball from the ith column at the top, or -1 if the ball gets stuck in the box.

### Example 1:
Input: grid = [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]]
Output: [1,-1,-1,-1,-1]
Explanation: This example is shown in the photo.
Ball b0 is dropped at column 0 and falls out of the box at column 1.
Ball b1 is dropped at column 1 and will get stuck in the box between column 2 and 3 and row 1.
Ball b2 is dropped at column 2 and will get stuck on the box between column 2 and 3 and row 0.
Ball b3 is dropped at column 3 and will get stuck on the box between column 2 and 3 and row 0.
Ball b4 is dropped at column 4 and will get stuck on the box between column 2 and 3 and row 1.

### Example 2:
Input: grid = [[-1]]
Output: [-1]
Explanation: The ball gets stuck against the left wall.

### Example 3:
Input: grid = [[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1],[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1]]
Output: [0,1,2,3,4,-1]

### Constraints:
* m == grid.length
* n == grid[i].length
* 1 <= m, n <= 100
* grid[i][j] is 1 or -1.

=end

# @param {Integer[][]} grid
# @return {Integer[]}
def find_ball(grid)
  total_col = grid.first.size

  0.upto(total_col - 1).map do |index_col|
    grid.each do |row|
      if row[index_col] == 1 && row[index_col + 1] == 1
        index_col += 1
      elsif row[index_col] == -1 && row[index_col - 1] == -1 && index_col > 0
        index_col -= 1
      else
        index_col = -1
        break
      end
    end

    index_col
  end
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_find_ball < Test::Unit::TestCase
  def test_
    assert_equal [1, -1, -1, -1, -1], find_ball([[1, 1, 1, -1, -1], [1, 1, 1, -1, -1], [-1, -1, -1, 1, 1], [1, 1, 1, 1, -1], [-1, -1, -1, -1, -1]])
    assert_equal [-1], find_ball([[-1]])
    assert_equal [0, 1, 2, 3, 4, -1], find_ball([[1, 1, 1, 1, 1, 1], [-1, -1, -1, -1, -1, -1], [1, 1, 1, 1, 1, 1], [-1, -1, -1, -1, -1, -1]])
  end
end
"
1716,calculate-money-in-leetcode-bank,"# frozen_string_literal: true

# 1716. Calculate Money in Leetcode Bank
# Easy
# https://leetcode.com/problems/calculate-money-in-leetcode-bank

=begin
Hercy wants to save money for his first car. He puts money in the Leetcode bank every day.
He starts by putting in $1 on Monday, the first day. Every day from Tuesday to Sunday, he will put in $1 more than the day before. On every subsequent Monday, he will put in $1 more than the previous Monday.
Given n, return the total amount of money he will have in the Leetcode bank at the end of the nth day.

Example 1:
Input: n = 4
Output: 10
Explanation: After the 4th day, the total is 1 + 2 + 3 + 4 = 10.

Example 2:
Input: n = 10
Output: 37
Explanation: After the 10th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4) = 37. Notice that on the 2nd Monday, Hercy only puts in $2.

Example 3:
Input: n = 20
Output: 96
Explanation: After the 20th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4 + 5 + 6 + 7 + 8) + (3 + 4 + 5 + 6 + 7 + 8) = 96.

Constraints:
1 <= n <= 1000
=end

# @param {Integer} n
# @return {Integer}
def total_money(n)
  k, x = n / 7, n % 7
  (7 * k * (k + 7) / 2) + (x * (2 * k + x + 1) / 2)
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_total_money < Test::Unit::TestCase
  def test_
    assert_equal 10, total_money(4)
    assert_equal 37, total_money(10)
    assert_equal 96, total_money(20)
  end
end
"
1721,swapping-nodes-in-a-linked-list,"# frozen_string_literal: true

# 1721. Swapping Nodes in a Linked List
# https://leetcode.com/problems/swapping-nodes-in-a-linked-list
# Medium

=begin
You are given the head of a linked list, and an integer k.

Return the head of the linked list after swapping the values of the kth node from the beginning and the kth node from the end (the list is 1-indexed).

Example 1:
Input: head = [1,2,3,4,5], k = 2
Output: [1,4,3,2,5]

Example 2:
Input: head = [7,9,6,6,7,8,3,0,9,5], k = 5
Output: [7,9,6,6,8,7,3,0,9,5]

Constraints:
The number of nodes in the list is n.
1 <= k <= n <= 105
0 <= Node.val <= 100
=end

# Definition for singly-linked list.
# class ListNode
#     attr_accessor :val, :next
#     def initialize(val = 0, _next = nil)
#         @val = val
#         @next = _next
#     end
# end
# @param {ListNode} head
# @param {Integer} k
# @return {ListNode}
def swap_nodes(head, k)
  n1 = nil
  n2 = nil
  curr = head

  while curr
    k -= 1
    if n2 != nil
      n2 = n2.next
    end

    if k == 0
      n1 = curr
      n2 = head
    end

    curr = curr.next
  end

  n1.val, n2.val = n2.val, n1.val
  head
end
"
1727,largest-submatrix-with-rearrangements,"# frozen_string_literal: true

# 1727. Largest Submatrix With Rearrangements
# Medium
# https://leetcode.com/problems/largest-submatrix-with-rearrangements

=begin
You are given a binary matrix matrix of size m x n, and you are allowed to rearrange the columns of the matrix in any order.
Return the area of the largest submatrix within matrix where every element of the submatrix is 1 after reordering the columns optimally.

Example 1:
Input: matrix = [[0,0,1],[1,1,1],[1,0,1]]
Output: 4
Explanation: You can rearrange the columns as shown above.
The largest submatrix of 1s, in bold, has an area of 4.

Example 2:
Input: matrix = [[1,0,1,0,1]]
Output: 3
Explanation: You can rearrange the columns as shown above.
The largest submatrix of 1s, in bold, has an area of 3.

Example 3:
Input: matrix = [[1,1,0],[1,0,1]]
Output: 2
Explanation: Notice that you must rearrange entire columns, and there is no way to make a submatrix of 1s larger than an area of 2.

Constraints:
m == matrix.length
n == matrix[i].length
1 <= m * n <= 105
matrix[i][j] is either 0 or 1.
=end

# @param {Integer[][]} matrix
# @return {Integer}
def largest_submatrix(matrix)
  m = matrix.size
  n = matrix[0].size
  columns = Array.new(m) { [] }

  0.upto(n - 1) do |j|
    seq = 0

    (m - 1).downto(0) do |i|
      if matrix[i][j] == 1
        seq += 1
        columns[i][j] = seq
      else
        seq = 0
      end
    end
  end

  max = 0

  0.upto(m - 1) do |i|
    cols = columns[i].compact.sort
    n = cols.size
    (n - 1).downto(0) do |j|
      max = [max, (n - j) * cols[j]].max
    end
  end

  max
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_largest_submatrix < Test::Unit::TestCase
  def test_
    assert_equal 4, largest_submatrix([[0, 0, 1], [1, 1, 1], [1, 0, 1]])
    assert_equal 3, largest_submatrix([[1, 0, 1, 0, 1]])
    assert_equal 2, largest_submatrix([[1, 1, 0], [1, 0, 1]])
  end
end
"
1732,find-the-highest-altitude,"# frozen_string_literal: true

# 1732. Find the Highest Altitude
# https://leetcode.com/problems/find-the-highest-altitude
# Easy

=begin
There is a biker going on a road trip. The road trip consists of n + 1 points at different altitudes. The biker starts his trip on point 0 with altitude equal 0.

You are given an integer array gain of length n where gain[i] is the net gain in altitude between points i and i + 1 for all (0 <= i < n). Return the highest altitude of a point.

Example 1:
Input: gain = [-5,1,5,0,-7]
Output: 1
Explanation: The altitudes are [0,-5,-4,1,1,-6]. The highest is 1.

Example 2:
Input: gain = [-4,-3,-2,-1,4,3,2]
Output: 0
Explanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest is 0.

Constraints:
n == gain.length
1 <= n <= 100
-100 <= gain[i] <= 100
=end

# @param {Integer[]} gain
# @return {Integer}
def largest_altitude(gain)
  prefix = gain.inject([]) { |acc, value| acc << acc.last.to_i + value.to_i }
  max_gain = prefix.max
  max_gain < 0 ? 0 : max_gain
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_largest_altitude < Test::Unit::TestCase
  def test_
    assert_equal 1, largest_altitude([-5, 1, 5, 0, -7])
    assert_equal 0, largest_altitude([-4, -3, -2, -1, 4, 3, 2])
  end
end
"
1743,restore-the-array-from-adjacent-pairs,"# frozen_string_literal: true

# 1743. Restore the Array From Adjacent Pairs
# Medium
# https://leetcode.com/problems/restore-the-array-from-adjacent-pairs

=begin
There is an integer array nums that consists of n unique elements, but you have forgotten it. However, you do remember every pair of adjacent elements in nums.
You are given a 2D integer array adjacentPairs of size n - 1 where each adjacentPairs[i] = [ui, vi] indicates that the elements ui and vi are adjacent in nums.
It is guaranteed that every adjacent pair of elements nums[i] and nums[i+1] will exist in adjacentPairs, either as [nums[i], nums[i+1]] or [nums[i+1], nums[i]]. The pairs can appear in any order.
Return the original array nums. If there are multiple solutions, return any of them.

Example 1:
Input: adjacentPairs = [[2,1],[3,4],[3,2]]
Output: [1,2,3,4]
Explanation: This array has all its adjacent pairs in adjacentPairs.
Notice that adjacentPairs[i] may not be in left-to-right order.

Example 2:
Input: adjacentPairs = [[4,-2],[1,4],[-3,1]]
Output: [-2,4,1,-3]
Explanation: There can be negative numbers.
Another solution is [-3,1,4,-2], which would also be accepted.

Example 3:
Input: adjacentPairs = [[100000,-100000]]
Output: [100000,-100000]

Constraints:
* nums.length == n
* adjacentPairs.length == n - 1
* adjacentPairs[i].length == 2
* 2 <= n <= 105
* -105 <= nums[i], ui, vi <= 105
* There exists some nums that has adjacentPairs as its pairs.
=end

# @param {Integer[][]} adjacent_pairs
# @return {Integer[]}
def restore_array(adjacent_pairs)
  hash = Hash.new { |h, k| h[k] = [] }
  adjacent_pairs.each do |a, b|
    hash[a] << b
    hash[b] << a
  end

  start = hash.keys.find { |k| hash[k].size == 1 }
  nums = [start]
  while nums.size < adjacent_pairs.size + 1
    crr = nums[-1]
    hash[crr].each do |t|
      if t != nums[-2]
        nums << t
        break
      end
    end
  end

  nums
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_restore_array < Test::Unit::TestCase
  def test_
    assert_equal [1, 2, 3, 4], restore_array([[2, 1], [3, 4], [3, 2]])
    assert_equal [-2, 4, 1, -3], restore_array([[4, -2], [1, 4], [-3, 1]])
    assert_equal [100000, -100000], restore_array([[100000, -100000]])
  end
end
"
1751,maximum-number-of-events-that-can-be-attended-ii,"# frozen_string_literal: true

# 1751. Maximum Number of Events That Can Be Attended II
# Hard
# https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii

=begin
You are given an array of events where events[i] = [startDayi, endDayi, valuei]. The ith event starts at startDayi and ends at endDayi, and if you attend this event, you will receive a value of valuei. You are also given an integer k which represents the maximum number of events you can attend.
You can only attend one event at a time. If you choose to attend an event, you must attend the entire event. Note that the end day is inclusive: that is, you cannot attend two events where one of them starts and the other ends on the same day.
Return the maximum sum of values that you can receive by attending events.

Input: events = [[1,2,4],[3,4,3],[2,3,1]], k = 2
Output: 7
Explanation: Choose the green events, 0 and 1 (0-indexed) for a total value of 4 + 3 = 7.

Input: events = [[1,2,4],[3,4,3],[2,3,10]], k = 2
Output: 10
Explanation: Choose event 2 for a total value of 10.
Notice that you cannot attend any other event as they overlap, and that you do not have to attend k events.

Input: events = [[1,1,1],[2,2,2],[3,3,3],[4,4,4]], k = 3
Output: 9
Explanation: Although the events do not overlap, you can only attend 3 events. Pick the highest valued three.

Constraints:
* 1 <= k <= events.length
* 1 <= k * events.length <= 106
* 1 <= startDayi <= endDayi <= 109
* 1 <= valuei <= 106
=end

# @param {Integer[][]} events
# @param {Integer} k
# @return {Integer}
def max_value(events, k)
  events.sort_by! { |event| event[1] }
  dp = Array.new(events.size + 1) { Array.new(k + 1, 0) }
  events.unshift([0, 0, 0])

  for i in 1..events.size - 1
    for j in 1..k
      l = 0
      r = i - 1
      while l < r
        mid = l + (r - l + 1) / 2
        if events[mid][1] < events[i][0]
          l = mid
        else
          r = mid - 1
        end
      end

      dp[i][j] = [dp[i - 1][j], dp[l][j - 1] + events[i][2]].max
    end
  end

  dp[events.size - 1][k]
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_max_value < Test::Unit::TestCase
  def test_
    assert_equal 7, max_value([[1, 2, 4], [3, 4, 3], [2, 3, 1]], 2)
    assert_equal 10, max_value([[1, 2, 4], [3, 4, 3], [2, 3, 10]], 2)
    assert_equal 9, max_value([[1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4]], 3)
  end
end
"
1759,count-number-of-homogenous-substrings,"# frozen_string_literal: true

# 1759. Count Number of Homogenous Substrings
# Medium
# https://leetcode.com/problems/count-number-of-homogenous-substrings

=begin
Given a string s, return the number of homogenous substrings of s. Since the answer may be too large, return it modulo 109 + 7.
A string is homogenous if all the characters of the string are the same.
A substring is a contiguous sequence of characters within a string.

Example 1:
Input: s = ""abbcccaa""
Output: 13
Explanation: The homogenous substrings are listed as below:
""a""   appears 3 times.
""aa""  appears 1 time.
""b""   appears 2 times.
""bb""  appears 1 time.
""c""   appears 3 times.
""cc""  appears 2 times.
""ccc"" appears 1 time.
3 + 1 + 2 + 1 + 3 + 2 + 1 = 13.

Example 2:
Input: s = ""xy""
Output: 2
Explanation: The homogenous substrings are ""x"" and ""y"".

Example 3:
Input: s = ""zzzzz""
Output: 15

Constraints:
1 <= s.length <= 105
s consists of lowercase letters.
=end

# @param {String} s
# @return {Integer}
def count_homogenous(s)
  s.each_char.chunk { |c| c }.map { |e| l = e[1].length(); l * (l + 1) / 2 }.sum() % (10**9 + 7)
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_count_homogenous < Test::Unit::TestCase
  def test_
    assert_equal 13, count_homogenous(""abbcccaa"")
    assert_equal 2, count_homogenous(""xy"")
    assert_equal 15, count_homogenous(""zzzzz"")
  end
end
"
1768,merge-strings-alternately,"# frozen_string_literal: true

# 1768. Merge Strings Alternately
# https://leetcode.com/problems/merge-strings-alternately/
# Easy

=begin

You are given two strings word1 and word2. Merge the strings by adding letters in alternating order, starting with word1. If a string is longer than the other, append the additional letters onto the end of the merged string.

Return the merged string.

### Example 1:
Input: word1 = ""abc"", word2 = ""pqr""
Output: ""apbqcr""
Explanation: The merged string will be merged as so:
word1:  a   b   c
word2:    p   q   r
merged: a p b q c r

### Example 2:
Input: word1 = ""ab"", word2 = ""pqrs""
Output: ""apbqrs""
Explanation: Notice that as word2 is longer, ""rs"" is appended to the end.
word1:  a   b
word2:    p   q   r   s
merged: a p b q   r   s

### Example 3:
Input: word1 = ""abcd"", word2 = ""pq""
Output: ""apbqcd""
Explanation: Notice that as word1 is longer, ""cd"" is appended to the end.
word1:  a   b   c   d
word2:    p   q
merged: a p b q c   d

### Constraints:
* 1 <= word1.length, word2.length <= 100
* word1 and word2 consist of lowercase English letters.

=end

# @param {String} word1
# @param {String} word2
# @return {String}
def merge_alternately(word1, word2)
  res = """"
  for i in 0...[word1.length, word2.length].max
    res += word1[i] if i < word1.length
    res += word2[i] if i < word2.length
  end
  res
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_merge_alternately < Test::Unit::TestCase
  def test_
    assert_equal ""apbqcr"", merge_alternately(""abc"", ""pqr"")
    assert_equal ""apbqrs"", merge_alternately(""ab"", ""pqrs"")
    assert_equal ""apbqcd"", merge_alternately(""abcd"", ""pq"")
  end
end
"
1793,maximum-score-of-a-good-subarray,"# frozen_string_literal: true

# 1793. Maximum Score of a Good Subarray
# Hard
# https://leetcode.com/problems/maximum-score-of-a-good-subarray

=begin
You are given an array of integers nums (0-indexed) and an integer k.
The score of a subarray (i, j) is defined as min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1). A good subarray is a subarray where i <= k <= j.
Return the maximum possible score of a good subarray.

Example 1:
Input: nums = [1,4,3,7,4,5], k = 3
Output: 15
Explanation: The optimal subarray is (1, 5) with a score of min(4,3,7,4,5) * (5-1+1) = 3 * 5 = 15.

Example 2:
Input: nums = [5,5,4,5,4,1,1,1], k = 0
Output: 20
Explanation: The optimal subarray is (0, 4) with a score of min(5,5,4,5,4) * (4-0+1) = 4 * 5 = 20.

Constraints:
1 <= nums.length <= 105
1 <= nums[i] <= 2 * 104
0 <= k < nums.length
=end

# @param {Integer[]} nums
# @param {Integer} k
# @return {Integer}
def maximum_score(nums, k)
  res = mini = nums[k]
  i = j = k
  n = nums.length

  while i > 0 || j < n - 1
    if i == 0
      j += 1
    elsif j == n - 1
      i -= 1
    elsif nums[i - 1] < nums[j + 1]
      j += 1
    else
      i -= 1
    end

    mini = [mini, [nums[i], nums[j]].min].min
    res = [res, mini * (j - i + 1)].max
  end

  res
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_maximum_score < Test::Unit::TestCase
  def test_
    assert_equal 15, maximum_score([1, 4, 3, 7, 4, 5], 3)
    assert_equal 20, maximum_score([5, 5, 4, 5, 4, 1, 1, 1], 0)
  end
end
"
1799,maximize-score-after-n-operations,"# frozen_string_literal: true

# TODO: Improve

# 1799. Maximize Score After N Operations
# https://leetcode.com/problems/maximize-score-after-n-operations
# Hard

=begin
You are given nums, an array of positive integers of size 2 * n. You must perform n operations on this array.

In the ith operation (1-indexed), you will:

Choose two elements, x and y.
Receive a score of i * gcd(x, y).
Remove x and y from nums.
Return the maximum score you can receive after performing n operations.

The function gcd(x, y) is the greatest common divisor of x and y.

Example 1:
Input: nums = [1,2]
Output: 1
Explanation: The optimal choice of operations is:
(1 * gcd(1, 2)) = 1

Example 2:
Input: nums = [3,4,6,8]
Output: 11
Explanation: The optimal choice of operations is:
(1 * gcd(3, 6)) + (2 * gcd(4, 8)) = 3 + 8 = 11

Example 3:
Input: nums = [1,2,3,4,5,6]
Output: 14
Explanation: The optimal choice of operations is:
(1 * gcd(1, 5)) + (2 * gcd(2, 4)) + (3 * gcd(3, 6)) = 1 + 4 + 9 = 14

Constraints:
1 <= n <= 7
nums.length == 2 * n
1 <= nums[i] <= 106
=end

class Numeric
  def max(v)
    self < v ? v : self
  end
end

class Solver
  attr_reader :nums, :ns2, :gcd

  def initialize(nums)
    @nums, @ns2, @gcd = nums, nums.size / 2, Array.new(nums.size) { |_| Array.new(nums.size) }
    nums.each_with_index { |v, idx|
      (idx + 1...nums.size).each { |j| @gcd[idx][j] = v.gcd(nums[j]) }
    }
  end

  def rec(op = 1, mask = 0)
    return 0 if op > ns2
    @dp[mask] ||= nums.size.times.inject(-1) { |res, i|
      next res unless mask[i].zero?
      (i + 1...nums.size).inject(res) { |res1, j|
        next res1 unless mask[j].zero?
        [res1, op * gcd[i][j] + rec(op + 1, mask | (1 << i) | (1 << j))].max
      }
    }
  end

  def solve
    @dp = Array.new(1 << nums.size)
    rec
  end
end

# @param {Integer[]} nums
# @return {Integer}
def max_score(nums)
  Solver.new(nums).solve
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_max_score < Test::Unit::TestCase
  def test_
    assert_equal 1, max_score([1, 2])
    assert_equal 11, max_score([3, 4, 6, 8])
    assert_equal 14, max_score([1, 2, 3, 4, 5, 6])
  end
end
"
1802,maximum-value-at-a-given-index-in-a-bounded-array,"# frozen_string_literal: true

# https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array
# 1802. Maximum Value at a Given Index in a Bounded Array
# Medium

=begin
You are given three positive integers: n, index, and maxSum. You want to construct an array nums (0-indexed) that satisfies the following conditions:
* nums.length == n
* nums[i] is a positive integer where 0 <= i < n.
* abs(nums[i] - nums[i+1]) <= 1 where 0 <= i < n-1.
* The sum of all the elements of nums does not exceed maxSum.
* nums[index] is maximized.
Return nums[index] of the constructed array.
Note that abs(x) equals x if x >= 0, and -x otherwise.

Example 1:
Input: n = 4, index = 2,  maxSum = 6
Output: 2
Explanation: nums = [1,2,2,1] is one array that satisfies all the conditions.
There are no arrays that satisfy all the conditions and have nums[2] == 3, so 2 is the maximum nums[2].

Example 2:
Input: n = 6, index = 1,  maxSum = 10
Output: 3

Constraints:
* 1 <= n <= maxSum <= 109
* 0 <= index < n
=end

# @param {Integer} n
# @param {Integer} index
# @param {Integer} max_sum
# @return {Integer}
def max_value(n, index, max_sum)
  l = index + 1
  r = n - index
  res = (0..max_sum + 1).bsearch do |x|
    sum = 0
    sum += if x >= l
      (x + x - l + 1) * l / 2
    else
      (x + 1) * x / 2 + l - x
    end
    sum += if x >= r
      (x + x - r + 1) * r / 2
    else
      (x + 1) * x / 2 + r - x
    end
    sum -= x
    max_sum < sum
  end

  res - 1
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_max_value < Test::Unit::TestCase
  def test_
    assert_equal 2, max_value(4, 2, 6)
    assert_equal 3, max_value(6, 1, 10)
  end
end
"
1814,count-nice-pairs-in-an-array,"# frozen_string_literal: true

# 1814. Count Nice Pairs in an Array
# Medium
# https://leetcode.com/problems/count-nice-pairs-in-an-array

=begin
You are given an array nums that consists of non-negative integers. Let us define rev(x) as the reverse of the non-negative integer x. For example, rev(123) = 321, and rev(120) = 21. A pair of indices (i, j) is nice if it satisfies all of the following conditions:
* 0 <= i < j < nums.length
* nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])
Return the number of nice pairs of indices. Since that number can be too large, return it modulo 109 + 7.

Example 1:
Input: nums = [42,11,1,97]
Output: 2
Explanation: The two pairs are:
- (0,3) : 42 + rev(97) = 42 + 79 = 121, 97 + rev(42) = 97 + 24 = 121.
- (1,2) : 11 + rev(1) = 11 + 1 = 12, 1 + rev(11) = 1 + 11 = 12.

Example 2:
Input: nums = [13,10,35,24,76]
Output: 4

Constraints:
1 <= nums.length <= 105
0 <= nums[i] <= 109
=end

# @param {Integer[]} nums
# @return {Integer}
def count_nice_pairs(nums)
  y = Hash.new { |h, x| h[x] = x - x.to_s.reverse.to_i }
  res = 0
  c = Hash.new(0)
  for x in nums
    res += c[y[x]]
    c[y[x]] += 1
  end
  res % 1000000007
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_count_nice_pairs < Test::Unit::TestCase
  def test_
    assert_equal 2, count_nice_pairs([42, 11, 1, 97])
    assert_equal 4, count_nice_pairs([13, 10, 35, 24, 76])
  end
end
"
1822,sign-of-the-product-of-an-array,"# frozen_string_literal: true

# 1822. Sign of the Product of an Array
# https://leetcode.com/problems/sign-of-the-product-of-an-array
# Easy

=begin
There is a function signFunc(x) that returns:

* 1 if x is positive.
* -1 if x is negative.
* 0 if x is equal to 0.
You are given an integer array nums. Let product be the product of all values in the array nums.

Return signFunc(product).

Example 1:
Input: nums = [-1,-2,-3,-4,3,2,1]
Output: 1
Explanation: The product of all values in the array is 144, and signFunc(144) = 1

Example 2:
Input: nums = [1,5,0,2,-3]
Output: 0
Explanation: The product of all values in the array is 0, and signFunc(0) = 0

Example 3:
Input: nums = [-1,1,-1,1,-1]
Output: -1
Explanation: The product of all values in the array is -1, and signFunc(-1) = -1

Constraints:
* 1 <= nums.length <= 1000
* -100 <= nums[i] <= 100
=end

# @param {Integer[]} nums
# @return {Integer}
def array_sign(nums)
  nums.reduce(1) { _1 * (_2 <=> 0) }
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_array_sign < Test::Unit::TestCase
  def test_
    assert_equal 1, array_sign([-1, -2, -3, -4, 3, 2, 1])
    assert_equal 0, array_sign([1, 5, 0, 2, -3])
    assert_equal(-1, array_sign([-1, 1, -1, 1, -1]))
  end
end
"
1838,frequency-of-the-most-frequent-element,"# frozen_string_literal: true

# 1838. Frequency of the Most Frequent Element
# Medium
# https://leetcode.com/problems/frequency-of-the-most-frequent-element

=begin
The frequency of an element is the number of times it occurs in an array.
You are given an integer array nums and an integer k. In one operation, you can choose an index of nums and increment the element at that index by 1.
Return the maximum possible frequency of an element after performing at most k operations.

Example 1:
Input: nums = [1,2,4], k = 5
Output: 3
Explanation: Increment the first element three times and the second element two times to make nums = [4,4,4].
4 has a frequency of 3.

Example 2:
Input: nums = [1,4,8,13], k = 5
Output: 2
Explanation: There are multiple optimal solutions:
- Increment the first element three times to make nums = [4,4,8,13]. 4 has a frequency of 2.
- Increment the second element four times to make nums = [1,8,8,13]. 8 has a frequency of 2.
- Increment the third element five times to make nums = [1,4,13,13]. 13 has a frequency of 2.

Example 3:
Input: nums = [3,9,6], k = 2
Output: 1

Constraints:
1 <= nums.length <= 105
1 <= nums[i] <= 105
1 <= k <= 105
=end

# @param {Integer[]} nums
# @param {Integer} k
# @return {Integer}
def max_frequency(nums, k)
  nums.sort!
  left, ans, curr = 0, 0, 0
  nums.size.times do |right|
    target = nums[right]
    curr += target
    while  (right - left + 1) * target - curr > k
      curr -= nums[left]
      left += 1
    end
    tmp = right - left + 1
    ans = tmp if tmp > ans
  end
  ans
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_max_frequency < Test::Unit::TestCase
  def test_
    assert_equal 3, max_frequency([1, 2, 4], 5)
    assert_equal 2, max_frequency([1, 4, 8, 13], 5)
    assert_equal 1, max_frequency([3, 9, 6], 2)
  end
end
"
1845,seat-reservation-manager,"# frozen_string_literal: true

# 1845. Seat Reservation Manager
# Medium
# https://leetcode.com/problems/seat-reservation-manager

=begin
Design a system that manages the reservation state of n seats that are numbered from 1 to n.

Implement the SeatManager class:
* SeatManager(int n) Initializes a SeatManager object that will manage n seats numbered from 1 to n. All seats are initially available.
int reserve() Fetches the smallest-numbered unreserved seat, reserves it, and returns its number.
void unreserve(int seatNumber) Unreserves the seat with the given seatNumber.

Example 1:
Input
[""SeatManager"", ""reserve"", ""reserve"", ""unreserve"", ""reserve"", ""reserve"", ""reserve"", ""reserve"", ""unreserve""]
[[5], [], [], [2], [], [], [], [], [5]]
Output
[null, 1, 2, null, 2, 3, 4, 5, null]

Explanation
SeatManager seatManager = new SeatManager(5); // Initializes a SeatManager with 5 seats.
seatManager.reserve();    // All seats are available, so return the lowest numbered seat, which is 1.
seatManager.reserve();    // The available seats are [2,3,4,5], so return the lowest of them, which is 2.
seatManager.unreserve(2); // Unreserve seat 2, so now the available seats are [2,3,4,5].
seatManager.reserve();    // The available seats are [2,3,4,5], so return the lowest of them, which is 2.
seatManager.reserve();    // The available seats are [3,4,5], so return the lowest of them, which is 3.
seatManager.reserve();    // The available seats are [4,5], so return the lowest of them, which is 4.
seatManager.reserve();    // The only available seat is seat 5, so return 5.
seatManager.unreserve(5); // Unreserve seat 5, so now the available seats are [5].

Constraints:
1 <= n <= 105
1 <= seatNumber <= n
For each call to reserve, it is guaranteed that there will be at least one unreserved seat.
For each call to unreserve, it is guaranteed that seatNumber will be reserved.
At most 105 calls in total will be made to reserve and unreserve.
=end

class Array
  def add_sorted(v)
    insert(bsearch_index { |w| w >= v } || -1, v)
  end
end

class SeatManager
  attr_reader :n, :unreserved, :first_free

  def initialize(n)
    @n, @unreserved, @first_free = n, [], 0
  end

  def reserve
    return @unreserved.shift unless unreserved.empty?
    @first_free += 1
  end

  def unreserve(seat_number)
    @unreserved.add_sorted(seat_number)
  end
end

# Your SeatManager object will be instantiated and called as such:
# obj = SeatManager.new(n)
# param_1 = obj.reserve()
# obj.unreserve(seat_number)
"
1846,maximum-element-after-decreasing-and-rearranging,"# frozen_string_literal: true

# 1846. Maximum Element After Decreasing and Rearranging
# Medium
# https://leetcode.com/problems/maximum-element-after-decreasing-and-rearranging

=begin
You are given an array of positive integers arr. Perform some operations (possibly none) on arr so that it satisfies these conditions:
* The value of the first element in arr must be 1.
* The absolute difference between any 2 adjacent elements must be less than or equal to 1. In other words, abs(arr[i] - arr[i - 1]) <= 1 for each i where 1 <= i < arr.length (0-indexed). abs(x) is the absolute value of x.
There are 2 types of operations that you can perform any number of times:
* Decrease the value of any element of arr to a smaller positive integer.
* Rearrange the elements of arr to be in any order.
Return the maximum possible value of an element in arr after performing the operations to satisfy the conditions.

Example 1:
Input: arr = [2,2,1,2,1]
Output: 2
Explanation:
We can satisfy the conditions by rearranging arr so it becomes [1,2,2,2,1].
The largest element in arr is 2.

Example 2:
Input: arr = [100,1,1000]
Output: 3
Explanation:
One possible way to satisfy the conditions is by doing the following:
1. Rearrange arr so it becomes [1,100,1000].
2. Decrease the value of the second element to 2.
3. Decrease the value of the third element to 3.
Now arr = [1,2,3], which satisfies the conditions.
The largest element in arr is 3.

Example 3:
Input: arr = [1,2,3,4,5]
Output: 5
Explanation: The array already satisfies the conditions, and the largest element is 5.

Constraints:
1 <= arr.length <= 105
1 <= arr[i] <= 109
=end

# @param {Integer[]} arr
# @return {Integer}
def maximum_element_after_decrementing_and_rearranging(arr)
  arr.sort!
  ans = 1
  (1...arr.size).each do |i|
    ans += 1 if arr[i] >= ans + 1
  end

  ans
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_maximum_element_after_decrementing_and_rearranging < Test::Unit::TestCase
  def test_
    assert_equal 2, maximum_element_after_decrementing_and_rearranging([2, 2, 1, 2, 1])
    assert_equal 3, maximum_element_after_decrementing_and_rearranging([100, 1, 1000])
    assert_equal 5, maximum_element_after_decrementing_and_rearranging([1, 2, 3, 4, 5])
  end
end
"
1857,largest-color-value-in-a-directed-graph,"# frozen_string_literal: true

# 1857. Largest Color Value in a Directed Graph
# https://leetcode.com/problems/largest-color-value-in-a-directed-graph
# Hard

=begin

There is a directed graph of n colored nodes and m edges. The nodes are numbered from 0 to n - 1.

You are given a string colors where colors[i] is a lowercase English letter representing the color of the ith node in this graph (0-indexed). You are also given a 2D array edges where edges[j] = [aj, bj] indicates that there is a directed edge from node aj to node bj.

A valid path in the graph is a sequence of nodes x1 -> x2 -> x3 -> ... -> xk such that there is a directed edge from xi to xi+1 for every 1 <= i < k. The color value of the path is the number of nodes that are colored the most frequently occurring color along that path.

Return the largest color value of any valid path in the given graph, or -1 if the graph contains a cycle.

### Example 1:
Input: colors = ""abaca"", edges = [[0,1],[0,2],[2,3],[3,4]]
Output: 3
Explanation: The path 0 -> 2 -> 3 -> 4 contains 3 nodes that are colored ""a"" (red in the above image).

### Example 2:
Input: colors = ""a"", edges = [[0,0]]
Output: -1
Explanation: There is a cycle from 0 to 0.

### Constraints:
* n == colors.length
* m == edges.length
* 1 <= n <= 105
* 0 <= m <= 105
* colors consists of lowercase English letters.
* 0 <= aj, bj < n

=end

# @param {String} colors
# @param {Integer[][]} edges
# @return {Integer}
def largest_path_value(color, edges)
  color = color.split("""").map { |c| c.ord - ""a"".ord }
  n = color.size
  graph = 0.upto(n - 1).map { [] }
  in_degree = [0] * n

  edges.each do |u, v|
    graph[u] << v
    in_degree[v] += 1
  end

  qu = []
  cnt = 0.upto(n - 1).map { [0] * 26 }
  0.upto(n - 1) do |u|
    next if in_degree[u] != 0

    qu.push(u)
    cnt[u][color[u]] = 1
  end

  ret, seen = 0, 0
  until qu.empty?
    u = qu.shift
    ret = [ret, cnt[u][color[u]]].max
    seen += 1

    graph[u].each do |v|
      0.upto 25 do |i|
        add = i == color[v] ? 1 : 0
        cnt[v][i] = [cnt[v][i], cnt[u][i] + add].max
      end
      qu << v if (in_degree[v] -= 1).zero?
    end
  end

  seen < n ? -1 : ret
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_minimum_time < Test::Unit::TestCase
  def test_
    assert_equal 3, largest_path_value(""abaca"", [[0, 1], [0, 2], [2, 3], [3, 4]])
    assert_equal(-1, largest_path_value(""a"", [[0, 0]]))
  end
end
"
1870,minimum-speed-to-arrive-on-time,"# frozen_string_literal: true

# 1870. Minimum Speed to Arrive on Time
# Medium
# https://leetcode.com/problems/minimum-speed-to-arrive-on-time

=begin
You are given a floating-point number hour, representing the amount of time you have to reach the office. To commute to the office, you must take n trains in sequential order. You are also given an integer array dist of length n, where dist[i] describes the distance (in kilometers) of the ith train ride.
Each train can only depart at an integer hour, so you may need to wait in between each train ride.
For example, if the 1st train ride takes 1.5 hours, you must wait for an additional 0.5 hours before you can depart on the 2nd train ride at the 2 hour mark.
Return the minimum positive integer speed (in kilometers per hour) that all the trains must travel at for you to reach the office on time, or -1 if it is impossible to be on time.
Tests are generated such that the answer will not exceed 107 and hour will have at most two digits after the decimal point.

Example 1:
Input: dist = [1,3,2], hour = 6
Output: 1
Explanation: At speed 1:
- The first train ride takes 1/1 = 1 hour.
- Since we are already at an integer hour, we depart immediately at the 1 hour mark. The second train takes 3/1 = 3 hours.
- Since we are already at an integer hour, we depart immediately at the 4 hour mark. The third train takes 2/1 = 2 hours.
- You will arrive at exactly the 6 hour mark.

Example 2:
Input: dist = [1,3,2], hour = 2.7
Output: 3
Explanation: At speed 3:
- The first train ride takes 1/3 = 0.33333 hours.
- Since we are not at an integer hour, we wait until the 1 hour mark to depart. The second train ride takes 3/3 = 1 hour.
- Since we are already at an integer hour, we depart immediately at the 2 hour mark. The third train takes 2/3 = 0.66667 hours.
- You will arrive at the 2.66667 hour mark.

Example 3:
Input: dist = [1,3,2], hour = 1.9
Output: -1
Explanation: It is impossible because the earliest the third train can depart is at the 2 hour mark.

Constraints:
* n == dist.length
* 1 <= n <= 105
* 1 <= dist[i] <= 105
* 1 <= hour <= 109
* There will be at most two digits after the decimal point in hour.
=end

# @param {Integer[]} dist
# @param {Float} hour
# @return {Integer}
def min_speed_on_time(dist, hour)
  return -1 if hour.ceil <= dist.size - 1

  i, j = 1, 10**7 + 1

  while i < j
    mid = (i + j) / 2
    time = dist[0..-2].sum { |d| (d + mid - 1) / mid } + dist[-1] / mid.to_f
    if time > hour
      i = mid + 1
    else
      j = mid
    end
  end

  i == 10**7 + 1 ? -1 : i
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_min_speed_on_time < Test::Unit::TestCase
  def test_
    assert_equal 1, min_speed_on_time([1, 3, 2], 6)
    assert_equal 3, min_speed_on_time([1, 3, 2], 2.7)
    assert_equal(-1, min_speed_on_time([1, 3, 2], 1.9))
    assert_equal(-1, min_speed_on_time([1, 1], 1.0))
  end
end
"
1877,minimize-maximum-pair-sum-in-array,"# frozen_string_literal: true

# 1877. Minimize Maximum Pair Sum in Array
# Medium
# https://leetcode.com/problems/minimize-maximum-pair-sum-in-array

=begin
The pair sum of a pair (a,b) is equal to a + b. The maximum pair sum is the largest pair sum in a list of pairs.
* For example, if we have pairs (1,5), (2,3), and (4,4), the maximum pair sum would be max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8.
Given an array nums of even length n, pair up the elements of nums into n / 2 pairs such that:
* Each element of nums is in exactly one pair, and
* The maximum pair sum is minimized.
Return the minimized maximum pair sum after optimally pairing up the elements.

Example 1:
Input: nums = [3,5,2,3]
Output: 7
Explanation: The elements can be paired up into pairs (3,3) and (5,2).
The maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.

Example 2:
Input: nums = [3,5,4,2,4,6]
Output: 8
Explanation: The elements can be paired up into pairs (3,5), (4,4), and (6,2).
The maximum pair sum is max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8.

Constraints:
n == nums.length
2 <= n <= 105
n is even.
1 <= nums[i] <= 105
=end

# @param {Integer[]} nums
# @return {Integer}
def min_pair_sum(nums)
  nums.sort!.reverse.zip(nums).map(&:sum).max
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_min_pair_sum < Test::Unit::TestCase
  def test_
    assert_equal 7, min_pair_sum([3, 5, 2, 3])
    assert_equal 8, min_pair_sum([3, 5, 4, 2, 4, 6])
  end
end
"
1887,reduction-operations-to-make-the-array-elements-equal,"# frozen_string_literal: true

# 1887. Reduction Operations to Make the Array Elements Equal
# Medium
# https://leetcode.com/problems/reduction-operations-to-make-the-array-elements-equal

=begin
Given an integer array nums, your goal is to make all elements in nums equal. To complete one operation, follow these steps:
1. Find the largest value in nums. Let its index be i (0-indexed) and its value be largest. If there are multiple elements with the largest value, pick the smallest i.
2. Find the next largest value in nums strictly smaller than largest. Let its value be nextLargest.
3. Reduce nums[i] to nextLargest.
Return the number of operations to make all elements in nums equal.

Example 1:
Input: nums = [5,1,3]
Output: 3
Explanation: It takes 3 operations to make all elements in nums equal:
1. largest = 5 at index 0. nextLargest = 3. Reduce nums[0] to 3. nums = [3,1,3].
2. largest = 3 at index 0. nextLargest = 1. Reduce nums[0] to 1. nums = [1,1,3].
3. largest = 3 at index 2. nextLargest = 1. Reduce nums[2] to 1. nums = [1,1,1].

Example 2:
Input: nums = [1,1,1]
Output: 0
Explanation: All elements in nums are already equal.

Example 3:
Input: nums = [1,1,2,2,3]
Output: 4
Explanation: It takes 4 operations to make all elements in nums equal:
1. largest = 3 at index 4. nextLargest = 2. Reduce nums[4] to 2. nums = [1,1,2,2,2].
2. largest = 2 at index 2. nextLargest = 1. Reduce nums[2] to 1. nums = [1,1,1,2,2].
3. largest = 2 at index 3. nextLargest = 1. Reduce nums[3] to 1. nums = [1,1,1,1,2].
4. largest = 2 at index 4. nextLargest = 1. Reduce nums[4] to 1. nums = [1,1,1,1,1].

Constraints:
1 <= nums.length <= 5 * 104
1 <= nums[i] <= 5 * 104
=end

# @param {Integer[]} nums
# @return {Integer}
def reduction_operations(nums)
  nums.sort!

  n = nums.size
  prev = nums[0]
  current_op = 0
  total = 0

  1.upto(n - 1) do |i|
    current = nums[i]
    if current > prev
      current_op += 1
      prev = current
    end

    total += current_op
  end

  total
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_reduction_operations < Test::Unit::TestCase
  def test_
    assert_equal 3, reduction_operations([5, 1, 3])
    assert_equal 0, reduction_operations([1, 1, 1])
    assert_equal 4, reduction_operations([1, 1, 2, 2, 3])
  end
end
"
1903,largest-odd-number-in-string,"# frozen_string_literal: true

# 1903. Largest Odd Number in String
# Easy
# https://leetcode.com/problems/largest-odd-number-in-string

=begin
You are given a string num, representing a large integer. Return the largest-valued odd integer (as a string) that is a non-empty substring of num, or an empty string """" if no odd integer exists.
A substring is a contiguous sequence of characters within a string.

Example 1:
Input: num = ""52""
Output: ""5""
Explanation: The only non-empty substrings are ""5"", ""2"", and ""52"". ""5"" is the only odd number.

Example 2:
Input: num = ""4206""
Output: """"
Explanation: There are no odd numbers in ""4206"".

Example 3:
Input: num = ""35427""
Output: ""35427""
Explanation: ""35427"" is already an odd number.

Constraints:
1 <= num.length <= 105
num only consists of digits and does not contain any leading zeros.
=end

# @param {String} num
# @return {String}
def largest_odd_number(num)
  i = num.length - 1
  while i >= 0
    case num[i]
    when ""1"", ""3"", ""5"", ""7"", ""9"" then return num[0..i]
    end
    i -= 1
  end

  """"
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_largest_odd_number < Test::Unit::TestCase
  def test_
    assert_equal ""5"", largest_odd_number(""52"")
    assert_equal """", largest_odd_number(""4206"")
    assert_equal ""35427"", largest_odd_number(""35427"")
  end
end
"
1921,eliminate-maximum-number-of-monsters,"# frozen_string_literal: true

# 1921. Eliminate Maximum Number of Monsters
# Medium
# https://leetcode.com/problems/eliminate-maximum-number-of-monsters

=begin
You are playing a video game where you are defending your city from a group of n monsters. You are given a 0-indexed integer array dist of size n, where dist[i] is the initial distance in kilometers of the ith monster from the city.
The monsters walk toward the city at a constant speed. The speed of each monster is given to you in an integer array speed of size n, where speed[i] is the speed of the ith monster in kilometers per minute.
You have a weapon that, once fully charged, can eliminate a single monster. However, the weapon takes one minute to charge. The weapon is fully charged at the very start.
You lose when any monster reaches your city. If a monster reaches the city at the exact moment the weapon is fully charged, it counts as a loss, and the game ends before you can use your weapon.
Return the maximum number of monsters that you can eliminate before you lose, or n if you can eliminate all the monsters before they reach the city.

Example 1:
Input: dist = [1,3,4], speed = [1,1,1]
Output: 3
Explanation:
In the beginning, the distances of the monsters are [1,3,4]. You eliminate the first monster.
After a minute, the distances of the monsters are [X,2,3]. You eliminate the second monster.
After a minute, the distances of the monsters are [X,X,2]. You eliminate the thrid monster.
All 3 monsters can be eliminated.

Example 2:
Input: dist = [1,1,2,3], speed = [1,1,1,1]
Output: 1
Explanation:
In the beginning, the distances of the monsters are [1,1,2,3]. You eliminate the first monster.
After a minute, the distances of the monsters are [X,0,1,2], so you lose.
You can only eliminate 1 monster.

Example 3:
Input: dist = [3,2,4], speed = [5,3,2]
Output: 1
Explanation:
In the beginning, the distances of the monsters are [3,2,4]. You eliminate the first monster.
After a minute, the distances of the monsters are [X,0,2], so you lose.
You can only eliminate 1 monster.


Constraints:
n == dist.length == speed.length
1 <= n <= 105
1 <= dist[i], speed[i] <= 105
=end

# @param {Integer[]} dist
# @param {Integer[]} speed
# @return {Integer}
def eliminate_maximum(dist, speed)
  return 0 if dist.empty? || speed.empty?

  time = dist.map.with_index { |d, i| d.to_f / speed[i] }

  time.sort!

  count = 0
  time.each_with_index do |t, i|
    break if t <= i

    count += 1
  end

  count
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_eliminate_maximum < Test::Unit::TestCase
  def test_
    assert_equal 3, eliminate_maximum([1, 3, 4], [1, 1, 1])
    assert_equal 1, eliminate_maximum([1, 1, 2, 3], [1, 1, 1, 1])
    assert_equal 1, eliminate_maximum([3, 2, 4], [5, 3, 2])
  end
end
"
1926,nearest-exit-from-entrance-in-maze,"# frozen_string_literal: true

# 1926. Nearest Exit from Entrance in Maze
# https://leetcode.com/problems/nearest-exit-from-entrance-in-maze
# Medium

=begin
You are given an m x n matrix maze (0-indexed) with empty cells (represented as '.') and walls (represented as '+'). You are also given the entrance of the maze, where entrance = [entrancerow, entrancecol] denotes the row and column of the cell you are initially standing at.

In one step, you can move one cell up, down, left, or right. You cannot step into a cell with a wall, and you cannot step outside the maze. Your goal is to find the nearest exit from the entrance. An exit is defined as an empty cell that is at the border of the maze. The entrance does not count as an exit.

Return the number of steps in the shortest path from the entrance to the nearest exit, or -1 if no such path exists.

Example 1:
Input: maze = [[""+"",""+"",""."",""+""],[""."",""."",""."",""+""],[""+"",""+"",""+"","".""]], entrance = [1,2]
Output: 1
Explanation: There are 3 exits in this maze at [1,0], [0,2], and [2,3].
Initially, you are at the entrance cell [1,2].
- You can reach [1,0] by moving 2 steps left.
- You can reach [0,2] by moving 1 step up.
It is impossible to reach [2,3] from the entrance.
Thus, the nearest exit is [0,2], which is 1 step away.

Example 2:
Input: maze = [[""+"",""+"",""+""],[""."",""."","".""],[""+"",""+"",""+""]], entrance = [1,0]
Output: 2
Explanation: There is 1 exit in this maze at [1,2].
[1,0] does not count as an exit since it is the entrance cell.
Initially, you are at the entrance cell [1,0].
- You can reach [1,2] by moving 2 steps right.
Thus, the nearest exit is [1,2], which is 2 steps away.

Example 3:
Input: maze = [[""."",""+""]], entrance = [0,0]
Output: -1
Explanation: There are no exits in this maze.

Constraints:
maze.length == m
maze[i].length == n
1 <= m, n <= 100
maze[i][j] is either '.' or '+'.
entrance.length == 2
0 <= entrancerow < m
0 <= entrancecol < n
entrance will always be an empty cell.
=end

# @param {Character[][]} maze
# @param {Integer[]} entrance
# @return {Integer}
def nearest_exit(maze, entrance)
  q = []
  q << entrance
  m, n = maze.size, maze[0].size
  div_m = []
  div_m << [1, 0] << [-1, 0] << [0, 1] << [0, -1]

  steps = 0

  while q.count > 0
    q.each { |v|
      q = q[1..q.count]
      return steps if (v[0] == m - 1 || v[1] == n - 1 || v[0] == 0 || v[1] == 0) && !(v[0] == entrance[0] && v[1] == entrance[1])
      div_m.each { |div|
        x, y = v[0] + div[0], v[1] + div[1]

        if x >= 0 && y >= 0 && x < m && y < n && maze[x][y] != ""+""
          q << [x, y]
          maze[x][y] = ""+""
        end
      }
    }
    steps += 1
  end
  -1
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_nearest_exit < Test::Unit::TestCase
  def test_
    assert_equal 1, nearest_exit([[""+"", ""+"", ""."", ""+""], [""."", ""."", ""."", ""+""], [""+"", ""+"", ""+"", "".""]], [1, 2])
    assert_equal 2, nearest_exit([[""+"", ""+"", ""+""], [""."", ""."", "".""], [""+"", ""+"", ""+""]], [1, 0])
    assert_equal(-1, nearest_exit([[""."", ""+""]], [0, 0]))
  end
end
"
1930,unique-length-3-palindromic-subsequences,"# frozen_string_literal: true

# 1930. Unique Length-3 Palindromic Subsequences
# Medium
# https://leetcode.com/problems/unique-length-3-palindromic-subsequences

=begin
Given a string s, return the number of unique palindromes of length three that are a subsequence of s.
Note that even if there are multiple ways to obtain the same subsequence, it is still only counted once.
A palindrome is a string that reads the same forwards and backwards.
A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.
* For example, ""ace"" is a subsequence of ""abcde"".

Example 1:
Input: s = ""aabca""
Output: 3
Explanation: The 3 palindromic subsequences of length 3 are:
- ""aba"" (subsequence of ""aabca"")
- ""aaa"" (subsequence of ""aabca"")
- ""aca"" (subsequence of ""aabca"")

Example 2:
Input: s = ""adc""
Output: 0
Explanation: There are no palindromic subsequences of length 3 in ""adc"".

Example 3:
Input: s = ""bbcbaba""
Output: 4
Explanation: The 4 palindromic subsequences of length 3 are:
- ""bbb"" (subsequence of ""bbcbaba"")
- ""bcb"" (subsequence of ""bbcbaba"")
- ""bab"" (subsequence of ""bbcbaba"")
- ""aba"" (subsequence of ""bbcbaba"")

Constraints:
* 3 <= s.length <= 105
* s consists of only lowercase English letters.
=end

# @param {String} s
# @return {Integer}
def count_palindromic_subsequence(s)
  count = 0
  for i in 0...26
    current_char = (i + 97).chr
    l = s.index(current_char)
    r = s.rindex(current_char)
    if l && r && l < r
      count += s[l + 1...r].chars.uniq.size
    end
  end
  count
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_count_palindromic_subsequence < Test::Unit::TestCase
  def test_
    assert_equal 3, count_palindromic_subsequence(""aabca"")
    assert_equal 0, count_palindromic_subsequence(""adc"")
    assert_equal 4, count_palindromic_subsequence(""bbcbaba"")
  end
end
"
1964,find-the-longest-valid-obstacle-course-at-each-position,"# frozen_string_literal: true

# 1964. Find the Longest Valid Obstacle Course at Each Position
# https://leetcode.com/problems/find-the-longest-valid-obstacle-course-at-each-position
# Hard

=begin
You want to build some obstacle courses. You are given a 0-indexed integer array obstacles of length n, where obstacles[i] describes the height of the ith obstacle.

For every index i between 0 and n - 1 (inclusive), find the length of the longest obstacle course in obstacles such that:

You choose any number of obstacles between 0 and i inclusive.
You must include the ith obstacle in the course.
You must put the chosen obstacles in the same order as they appear in obstacles.
Every obstacle (except the first) is taller than or the same height as the obstacle immediately before it.
Return an array ans of length n, where ans[i] is the length of the longest obstacle course for index i as described above.

Example 1:
Input: obstacles = [1,2,3,2]
Output: [1,2,3,3]
Explanation: The longest valid obstacle course at each position is:
- i = 0: [1], [1] has length 1.
- i = 1: [1,2], [1,2] has length 2.
- i = 2: [1,2,3], [1,2,3] has length 3.
- i = 3: [1,2,3,2], [1,2,2] has length 3.

Example 2:
Input: obstacles = [2,2,1]
Output: [1,2,1]
Explanation: The longest valid obstacle course at each position is:
- i = 0: [2], [2] has length 1.
- i = 1: [2,2], [2,2] has length 2.
- i = 2: [2,2,1], [1] has length 1.

Example 3:
Input: obstacles = [3,1,5,6,4,2]
Output: [1,1,2,3,2,2]
Explanation: The longest valid obstacle course at each position is:
- i = 0: [3], [3] has length 1.
- i = 1: [3,1], [1] has length 1.
- i = 2: [3,1,5], [3,5] has length 2. [1,5] is also valid.
- i = 3: [3,1,5,6], [3,5,6] has length 3. [1,5,6] is also valid.
- i = 4: [3,1,5,6,4], [3,4] has length 2. [1,4] is also valid.
- i = 5: [3,1,5,6,4,2], [1,2] has length 2.

Constraints:
n == obstacles.length
1 <= n <= 105
1 <= obstacles[i] <= 107
=end

# @param {Integer[]} obstacles
# @return {Integer[]}
def longest_obstacle_course_at_each_position(obstacles)
  obstacle_path = []
  ans = []
  for i in 0..obstacles.length - 1
    if obstacle_path.empty? || (obstacles[i] >= obstacle_path.last)
      obstacle_path << obstacles[i]
      ans[i] = obstacle_path.count
    else
      idx = obstacle_path.bsearch_index { |obstacle| obstacle > obstacles[i] }
      obstacle_path[idx] = obstacles[i]
      ans[i] = idx + 1
    end
  end

  ans
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_longest_obstacle_course_at_each_position < Test::Unit::TestCase
  def test_
    assert_equal [1, 2, 3, 3], longest_obstacle_course_at_each_position([1, 2, 3, 2])
    assert_equal [1, 2, 1], longest_obstacle_course_at_each_position([2, 2, 1])
    assert_equal [1, 1, 2, 3, 2, 2], longest_obstacle_course_at_each_position([3, 1, 5, 6, 4, 2])
  end
end
"
1970,last-day-where-you-can-still-cross,"# frozen_string_literal: true

# 1970. Last Day Where You Can Still Cross
# Hard
# https://leetcode.com/problems/last-day-where-you-can-still-cross

=begin
There is a 1-based binary matrix where 0 represents land and 1 represents water. You are given integers row and col representing the number of rows and columns in the matrix, respectively.
Initially on day 0, the entire matrix is land. However, each day a new cell becomes flooded with water. You are given a 1-based 2D array cells, where cells[i] = [ri, ci] represents that on the ith day, the cell on the rith row and cith column (1-based coordinates) will be covered with water (i.e., changed to 1).
You want to find the last day that it is possible to walk from the top to the bottom by only walking on land cells. You can start from any cell in the top row and end at any cell in the bottom row. You can only travel in the four cardinal directions (left, right, up, and down).
Return the last day where it is possible to walk from the top to the bottom by only walking on land cells.

Example 1:
Input: row = 2, col = 2, cells = [[1,1],[2,1],[1,2],[2,2]]
Output: 2
Explanation: The above image depicts how the matrix changes each day starting from day 0.
The last day where it is possible to cross from top to bottom is on day 2.

Example 2:
Input: row = 2, col = 2, cells = [[1,1],[1,2],[2,1],[2,2]]
Output: 1
Explanation: The above image depicts how the matrix changes each day starting from day 0.
The last day where it is possible to cross from top to bottom is on day 1.

Example 3:
Input: row = 3, col = 3, cells = [[1,2],[2,1],[3,3],[2,2],[1,1],[1,3],[2,3],[3,2],[3,1]]
Output: 3
Explanation: The above image depicts how the matrix changes each day starting from day 0.
The last day where it is possible to cross from top to bottom is on day 3.

Constraints:
* 2 <= row, col <= 2 * 104
* 4 <= row * col <= 2 * 104
* cells.length == row * col
* 1 <= ri <= row
* 1 <= ci <= col
* All the values of cells are unique.
=end

# @param {Integer} row
# @param {Integer} col
# @param {Integer[][]} cells
# @return {Integer}
def latest_day_to_cross(row, col, cells)
  g, z = Array.new(row) { [0] * col }, row * col
  p, c = [*0...z], [1] * z
  f = -> x { p[x] == x ? x : (p[x] = f.(p[x])) }
  tr, br = Set[], Set[]
  d = [[1, 0], [-1, 0], [0, 1], [0, -1]]
  loop do
    i, j = *cells.pop
    g[i -= 1][j -= 1], a = 1, i * col + j
    tr << a if i == 0
    br << a if i == row - 1
    d.each do | y, x |
      y += i; x += j
      next if y < 0 || y == row ||
              x < 0 || x == col || g[y][x] == 0 ||
              (ra = f.(a)) == (rb = f.(y * col + x))
      return cells.size if tr === ra && br === rb ||
                       tr === rb && br === ra
      ra, rb = rb, ra if c[ra] < c[rb]
      p[rb] = ra; c[ra] += c[rb]
      (tr.delete rb; tr << ra) if tr === rb
      (br.delete rb; br << ra) if br === rb
    end
  end
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_latest_day_to_cross < Test::Unit::TestCase
  def test_
    assert_equal 2, latest_day_to_cross(2, 2, [[1, 1], [2, 1], [1, 2], [2, 2]])
    assert_equal 1, latest_day_to_cross(2, 2, [[1, 1], [1, 2], [2, 1], [2, 2]])
    assert_equal 3, latest_day_to_cross(3, 3, [[1, 2], [2, 1], [3, 3], [2, 2], [1, 1], [1, 3], [2, 3], [3, 2], [3, 1]])
  end
end
"
1980,find-unique-binary-string,"# frozen_string_literal: true

# 1980. Find Unique Binary String
# Medium
# https://leetcode.com/problems/find-unique-binary-string

=begin
Given an array of strings nums containing n unique binary strings each of length n, return a binary string of length n that does not appear in nums. If there are multiple answers, you may return any of them.

Example 1:
Input: nums = [""01"",""10""]
Output: ""11""
Explanation: ""11"" does not appear in nums. ""00"" would also be correct.

Example 2:
Input: nums = [""00"",""01""]
Output: ""11""
Explanation: ""11"" does not appear in nums. ""10"" would also be correct.

Example 3:
Input: nums = [""111"",""011"",""001""]
Output: ""101""
Explanation: ""101"" does not appear in nums. ""000"", ""010"", ""100"", and ""110"" would also be correct.

Constraints:
n == nums.length
1 <= n <= 16
nums[i].length == n
nums[i] is either '0' or '1'.
All the strings of nums are unique.
=end

# @param {String[]} nums
# @return {String}
def find_different_binary_string(nums)
  length = nums.length
  number = """"
  (0...length).each do |i|
    number += (nums[i][i] == ""1"" ? ""0"" : ""1"")
  end
  number
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_find_different_binary_string < Test::Unit::TestCase
  def test_
    assert_equal ""11"", find_different_binary_string([""01"", ""10""])
    assert_equal ""11"", find_different_binary_string([""00"", ""01""])
    assert_equal ""101"", find_different_binary_string([""111"", ""011"", ""001""])
  end
end
"
2009,minimum-number-of-operations-to-make-array-continuous,"# frozen_string_literal: true

# 2009. Minimum Number of Operations to Make Array Continuous
# Hard
# https://leetcode.com/problems/minimum-number-of-operations-to-make-array-continuous

=begin
You are given an integer array nums. In one operation, you can replace any element in nums with any integer.
nums is considered continuous if both of the following conditions are fulfilled:
* All elements in nums are unique.
* The difference between the maximum element and the minimum element in nums equals nums.length - 1.
For example, nums = [4, 2, 5, 3] is continuous, but nums = [1, 2, 3, 5, 6] is not continuous.
Return the minimum number of operations to make nums continuous.

Example 1:
Input: nums = [4,2,5,3]
Output: 0
Explanation: nums is already continuous.

Example 2:
Input: nums = [1,2,3,5,6]
Output: 1
Explanation: One possible solution is to change the last element to 4.
The resulting array is [1,2,3,5,4], which is continuous.

Example 3:
Input: nums = [1,10,100,1000]
Output: 3
Explanation: One possible solution is to:
- Change the second element to 2.
- Change the third element to 3.
- Change the fourth element to 4.
The resulting array is [1,2,3,4], which is continuous.

Constraints:
1 <= nums.length <= 105
1 <= nums[i] <= 109
=end

# @param {Integer[]} nums
# @return {Integer}
def min_operations(nums)
  nums.sort!

  repeat = [0]
  seen = Set[]
  nums.each do |num|
    repeat << (seen.include?(num) ? repeat[-1] + 1 : repeat[-1])
    seen.add(num)
  end

  len = nums.length
  min = len

  nums.each_with_index do |num, i|
    idx = nums.bsearch_index { |val| val > num + len - 1 } || len
    num_to_change = len - idx + i + repeat[idx] - repeat[i]
    min = num_to_change if num_to_change < min
  end

  min
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_min_operations < Test::Unit::TestCase
  def test_
    assert_equal 0, min_operations([4, 2, 5, 3])
    assert_equal 1, min_operations([1, 2, 3, 5, 6])
    assert_equal 3, min_operations([1, 10, 100, 1000])
  end
end
"
2024,maximize-the-confusion-of-an-exam,"# frozen_string_literal: true

# 2024. Maximize the Confusion of an Exam
# Medium
# https://leetcode.com/problems/maximize-the-confusion-of-an-exam

=begin
A teacher is writing a test with n true/false questions, with 'T' denoting true and 'F' denoting false. He wants to confuse the students by maximizing the number of consecutive questions with the same answer (multiple trues or multiple falses in a row).
You are given a string answerKey, where answerKey[i] is the original answer to the ith question. In addition, you are given an integer k, the maximum number of times you may perform the following operation:
* Change the answer key for any question to 'T' or 'F' (i.e., set answerKey[i] to 'T' or 'F').
Return the maximum number of consecutive 'T's or 'F's in the answer key after performing the operation at most k times.

Example 1:
Input: answerKey = ""TTFF"", k = 2
Output: 4
Explanation: We can replace both the 'F's with 'T's to make answerKey = ""TTTT"".
There are four consecutive 'T's.

Example 2:
Input: answerKey = ""TFFT"", k = 1
Output: 3
Explanation: We can replace the first 'T' with an 'F' to make answerKey = ""FFFT"".
Alternatively, we can replace the second 'T' with an 'F' to make answerKey = ""TFFF"".
In both cases, there are three consecutive 'F's.

Example 3:
Input: answerKey = ""TTFTTFTT"", k = 1
Output: 5
Explanation: We can replace the first 'F' to make answerKey = ""TTTTTFTT""
Alternatively, we can replace the second 'F' to make answerKey = ""TTFTTTTT"".
In both cases, there are five consecutive 'T's.

Constraints:
* n == answerKey.length
* 1 <= n <= 5 * 104
* answerKey[i] is either 'T' or 'F'
* 1 <= k <= n
=end

# @param {String} answer_key
# @param {Integer} k
# @return {Integer}
def max_consecutive_answers(answer_key, k)
  max_length = 0
  left = 0
  count = { ""T"" => 0, ""F"" => 0 }

  answer_key.chars.each_with_index do |char, right|
    count[char] += 1

    if [count[""T""], count[""F""]].min > k
      count[answer_key[left]] -= 1
      left += 1
    else
      max_length = [max_length, right - left + 1].max
    end
  end

  max_length
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_max_consecutive_answers < Test::Unit::TestCase
  def test_
    assert_equal 4, max_consecutive_answers(""TTFF"", 2)
    assert_equal 3, max_consecutive_answers(""TFFT"", 1)
    assert_equal 5, max_consecutive_answers(""TTFTTFTT"", 1)
  end
end
"
2050,parallel-courses-iii,"# frozen_string_literal: true

# 2050. Parallel Courses III
# Hard
# https://leetcode.com/problems/parallel-courses-iii

=begin
You are given an integer n, which indicates that there are n courses labeled from 1 to n. You are also given a 2D integer array relations where relations[j] = [prevCoursej, nextCoursej] denotes that course prevCoursej has to be completed before course nextCoursej (prerequisite relationship). Furthermore, you are given a 0-indexed integer array time where time[i] denotes how many months it takes to complete the (i+1)th course.
You must find the minimum number of months needed to complete all the courses following these rules:
* You may start taking a course at any time if the prerequisites are met.
* Any number of courses can be taken at the same time.
Return the minimum number of months needed to complete all the courses.
Note: The test cases are generated such that it is possible to complete every course (i.e., the graph is a directed acyclic graph).

Example 1:
Input: n = 3, relations = [[1,3],[2,3]], time = [3,2,5]
Output: 8
Explanation: The figure above represents the given graph and the time required to complete each course.
We start course 1 and course 2 simultaneously at month 0.
Course 1 takes 3 months and course 2 takes 2 months to complete respectively.
Thus, the earliest time we can start course 3 is at month 3, and the total time required is 3 + 5 = 8 months.

Example 2:
Input: n = 5, relations = [[1,5],[2,5],[3,5],[3,4],[4,5]], time = [1,2,3,4,5]
Output: 12
Explanation: The figure above represents the given graph and the time required to complete each course.
You can start courses 1, 2, and 3 at month 0.
You can complete them after 1, 2, and 3 months respectively.
Course 4 can be taken only after course 3 is completed, i.e., after 3 months. It is completed after 3 + 4 = 7 months.
Course 5 can be taken only after courses 1, 2, 3, and 4 have been completed, i.e., after max(1,2,3,7) = 7 months.
Thus, the minimum time needed to complete all the courses is 7 + 5 = 12 months.

Constraints:
* 1 <= n <= 5 * 104
* 0 <= relations.length <= min(n * (n - 1) / 2, 5 * 104)
* relations[j].length == 2
* 1 <= prevCoursej, nextCoursej <= n
* prevCoursej != nextCoursej
* All the pairs [prevCoursej, nextCoursej] are unique.
* time.length == n
* 1 <= time[i] <= 104
* The given graph is a directed acyclic graph.
=end

# @param {Integer} n
# @param {Integer[][]} relations
# @param {Integer[]} time
# @return {Integer}
def minimum_time(n, relations, times)
  prevs = Array.new(n + 1) { [] }
  nexts = Array.new(n + 1) { [] }

  times.unshift(0)

  relations.each do |a, b|
    prevs[b] << a
    nexts[a] << b
  end

  taken = Set[]
  time = 0

  min_heap = []
  starts = (1..n).to_a.select { |val| prevs[val].length == 0 }
  starts.each { |start| min_heap << [times[start], start] }
  min_heap.sort!

  until min_heap.empty?
    val, num = min_heap.shift
    time = val
    taken.add(num)

    nexts[num].each do |adj|
      if prevs[adj].all? { |node| taken.include?(node) }
        idx = min_heap.bsearch_index do |subarr|
            subarr[0] >= time + times[adj]
          end || min_heap.length

        min_heap.insert(idx, [times[adj] + time, adj])
      end
    end
  end

  time
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_minimum_time < Test::Unit::TestCase
  def test_
    assert_equal 8, minimum_time(3, [[1, 3], [2, 3]], [3, 2, 5])
    assert_equal 12, minimum_time(5, [[1, 5], [2, 5], [3, 5], [3, 4], [4, 5]], [1, 2, 3, 4, 5])
  end
end
"
2090,k-radius-subarray-averages,"# frozen_string_literal: true

# 2090. K Radius Subarray Averages
# Medium
# https://leetcode.com/problems/k-radius-subarray-averages

=begin
You are given a 0-indexed array nums of n integers, and an integer k.

The k-radius average for a subarray of nums centered at some index i with the radius k is the average of all elements in nums between the indices i - k and i + k (inclusive). If there are less than k elements before or after the index i, then the k-radius average is -1.

Build and return an array avgs of length n where avgs[i] is the k-radius average for the subarray centered at index i.

The average of x elements is the sum of the x elements divided by x, using integer division. The integer division truncates toward zero, which means losing its fractional part.

* For example, the average of four elements 2, 3, 1, and 5 is (2 + 3 + 1 + 5) / 4 = 11 / 4 = 2.75, which truncates to 2.

Example 1:
Input: nums = [7,4,3,9,1,8,5,2,6], k = 3
Output: [-1,-1,-1,5,4,4,-1,-1,-1]
Explanation:
- avg[0], avg[1], and avg[2] are -1 because there are less than k elements before each index.
- The sum of the subarray centered at index 3 with radius 3 is: 7 + 4 + 3 + 9 + 1 + 8 + 5 = 37.
  Using integer division, avg[3] = 37 / 7 = 5.
- For the subarray centered at index 4, avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4.
- For the subarray centered at index 5, avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4.
- avg[6], avg[7], and avg[8] are -1 because there are less than k elements after each index.

Example 2:
Input: nums = [100000], k = 0
Output: [100000]
Explanation:
- The sum of the subarray centered at index 0 with radius 0 is: 100000.
  avg[0] = 100000 / 1 = 100000.

Example 3:
Input: nums = [8], k = 100000
Output: [-1]
Explanation:
- avg[0] is -1 because there are less than k elements before and after index 0.

Constraints:
* n == nums.length
* 1 <= n <= 105
* 0 <= nums[i], k <= 105
=end

# @param {Integer[]} nums
# @param {Integer} k
# @return {Integer[]}
def get_averages(nums, k)
  left = 0
  curr_sum = 0
  window_size = 2 * k + 1
  result = Array.new(nums.length, -1)

  nums.each_with_index do |num, right|
    curr_sum += num

    if right - left + 1 == window_size
      avg = curr_sum / window_size
      result[right - k] = avg
      curr_sum -= nums[left]
      left += 1
    end
  end
  result
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_get_averages < Test::Unit::TestCase
  def test_
    assert_equal [-1, -1, -1, 5, 4, 4, -1, -1, -1], get_averages([7, 4, 3, 9, 1, 8, 5, 2, 6], 3)
    assert_equal [100000], get_averages([100000], 0)
    assert_equal [-1], get_averages([8], 100000)
  end
end
"
2095,delete-the-middle-node-of-a-linked-list,"# frozen_string_literal: true

# 2095. Delete the Middle Node of a Linked List
# https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list
# Medium

=begin
You are given the head of a linked list. Delete the middle node, and return the head of the modified linked list.

The middle node of a linked list of size n is the n / 2th node from the start using 0-based indexing, where x denotes the largest integer less than or equal to x.

For n = 1, 2, 3, 4, and 5, the middle nodes are 0, 1, 1, 2, and 2, respectively.

Example 1:
Input: head = [1,3,4,7,1,2,6]
Output: [1,3,4,1,2,6]
Explanation:
The above figure represents the given linked list. The indices of the nodes are written below.
Since n = 7, node 3 with value 7 is the middle node, which is marked in red.
We return the new list after removing this node.

Example 2:
Input: head = [1,2,3,4]
Output: [1,2,4]
Explanation:
The above figure represents the given linked list.
For n = 4, node 2 with value 3 is the middle node, which is marked in red.

Example 3:
Input: head = [2,1]
Output: [2]
Explanation:
The above figure represents the given linked list.
For n = 2, node 1 with value 1 is the middle node, which is marked in red.
Node 0 with value 2 is the only node remaining after removing node 1.

Constraints:
The number of nodes in the list is in the range [1, 105].
1 <= Node.val <= 105
=end

# Definition for singly-linked list.
# class ListNode
#     attr_accessor :val, :next
#     def initialize(val = 0, _next = nil)
#         @val = val
#         @next = _next
#     end
# end
# @param {ListNode} head
# @return {ListNode}
def delete_middle(head)
  return nil unless head.next

  slow = head
  fast = head.next.next
  while fast && fast.next do
    slow = slow.next
    fast = fast.next.next
  end

  slow.next = slow.next.next
  head
end
"
2101,detonate-the-maximum-bombs,"# frozen_string_literal: true

# https://leetcode.com/problems/detonate-the-maximum-bombs
# 2101. Detonate the Maximum Bombs
# Medium

=begin
You are given a list of bombs. The range of a bomb is defined as the area where its effect can be felt. This area is in the shape of a circle with the center as the location of the bomb.

The bombs are represented by a 0-indexed 2D integer array bombs where bombs[i] = [xi, yi, ri]. xi and yi denote the X-coordinate and Y-coordinate of the location of the ith bomb, whereas ri denotes the radius of its range.

You may choose to detonate a single bomb. When a bomb is detonated, it will detonate all bombs that lie in its range. These bombs will further detonate the bombs that lie in their ranges.

Given the list of bombs, return the maximum number of bombs that can be detonated if you are allowed to detonate only one bomb.

Example 1:
Input: bombs = [[2,1,3],[6,1,4]]
Output: 2
Explanation:
The above figure shows the positions and ranges of the 2 bombs.
If we detonate the left bomb, the right bomb will not be affected.
But if we detonate the right bomb, both bombs will be detonated.
So the maximum bombs that can be detonated is max(1, 2) = 2.

Example 2:
Input: bombs = [[1,1,5],[10,10,5]]
Output: 1
Explanation:
Detonating either bomb will not detonate the other bomb, so the maximum number of bombs that can be detonated is 1.

Example 3:
Input: bombs = [[1,2,3],[2,3,1],[3,4,2],[4,5,3],[5,6,4]]
Output: 5
Explanation:
The best bomb to detonate is bomb 0 because:
- Bomb 0 detonates bombs 1 and 2. The red circle denotes the range of bomb 0.
- Bomb 2 detonates bomb 3. The blue circle denotes the range of bomb 2.
- Bomb 3 detonates bomb 4. The green circle denotes the range of bomb 3.
Thus all 5 bombs are detonated.

Constraints:
* 1 <= bombs.length <= 100
* bombs[i].length == 3
* 1 <= xi, yi, ri <= 105
=end

# @param {Integer[][]} bombs
# @return {Integer}
def maximum_detonation(bombs)
  chain = Hash.new { |h, k| h[k] = [] }

  bombs.each_with_index do |bomb, i|
    bombs.each_with_index do |bomb2, j|
      if i > j
        a, b, c = bomb
        d, e, f = bomb2

        chain[i] << j if (a - d)**2 + (b - e)**2 <= c**2
        chain[j] << i if (a - d)**2 + (b - e)**2 <= f**2
      end
    end
  end

  max = 0

  (0...bombs.length).each do |i|
    checked = Set[i]
    queue = checked.to_a

    until queue.empty?
      bomb = queue.shift
      connections = chain[bomb]
      connections.each do |connection|
        queue << connection unless checked.include?(connection)
        checked.add(connection)
      end
    end

    max = checked.size if checked.size > max
  end

  max
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_maximum_detonation < Test::Unit::TestCase
  def test_
    assert_equal 2, maximum_detonation([[2, 1, 3], [6, 1, 4]])
    assert_equal 1, maximum_detonation([[1, 1, 5], [10, 10, 5]])
    assert_equal 5, maximum_detonation([[1, 2, 3], [2, 3, 1], [3, 4, 2], [4, 5, 3], [5, 6, 4]])
  end
end
"
2130,maximum-twin-sum-of-a-linked-list,"# frozen_string_literal: true

# 2130. Maximum Twin Sum of a Linked List
# https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list
# Medium

=begin
In a linked list of size n, where n is even, the ith node (0-indexed) of the linked list is known as the twin of the (n-1-i)th node, if 0 <= i <= (n / 2) - 1.

For example, if n = 4, then node 0 is the twin of node 3, and node 1 is the twin of node 2. These are the only nodes with twins for n = 4.
The twin sum is defined as the sum of a node and its twin.

Given the head of a linked list with even length, return the maximum twin sum of the linked list.

Example 1:
Input: head = [5,4,2,1]
Output: 6
Explanation:
Nodes 0 and 1 are the twins of nodes 3 and 2, respectively. All have twin sum = 6.
There are no other nodes with twins in the linked list.
Thus, the maximum twin sum of the linked list is 6.

Example 2:
Input: head = [4,2,2,3]
Output: 7
Explanation:
The nodes with twins present in this linked list are:
- Node 0 is the twin of node 3 having a twin sum of 4 + 3 = 7.
- Node 1 is the twin of node 2 having a twin sum of 2 + 2 = 4.
Thus, the maximum twin sum of the linked list is max(7, 4) = 7.

Example 3:
Input: head = [1,100000]
Output: 100001
Explanation:
There is only one node with a twin in the linked list having twin sum of 1 + 100000 = 100001.

Constraints:
The number of nodes in the list is an even integer in the range [2, 105].
1 <= Node.val <= 105
=end

# Definition for singly-linked list.
# class ListNode
#     attr_accessor :val, :next
#     def initialize(val = 0, _next = nil)
#         @val = val
#         @next = _next
#     end
# end
# @param {ListNode} head
# @return {Integer}
def pair_sum(head)
  slow = fast = head
  stack = []

  while fast&.next
    stack << slow.val
    slow = slow.next
    fast = fast.next.next
  end

  max = 0
  while (val = stack.pop)
    max = [val + slow.val, max].max
    slow = slow.next
  end

  max
end
"
2131,longest-palindrome-by-concatenating-two-letter-words,"# frozen_string_literal: true

# 2131. Longest Palindrome by Concatenating Two Letter Words
# https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words
# Medium

=begin
You are given an array of strings words. Each element of words consists of two lowercase English letters.

Create the longest possible palindrome by selecting some elements from words and concatenating them in any order. Each element can be selected at most once.

Return the length of the longest palindrome that you can create. If it is impossible to create any palindrome, return 0.

A palindrome is a string that reads the same forward and backward.

Example 1:
Input: words = [""lc"",""cl"",""gg""]
Output: 6
Explanation: One longest palindrome is ""lc"" + ""gg"" + ""cl"" = ""lcggcl"", of length 6.
Note that ""clgglc"" is another longest palindrome that can be created.

Example 2:
Input: words = [""ab"",""ty"",""yt"",""lc"",""cl"",""ab""]
Output: 8
Explanation: One longest palindrome is ""ty"" + ""lc"" + ""cl"" + ""yt"" = ""tylcclyt"", of length 8.
Note that ""lcyttycl"" is another longest palindrome that can be created.

Example 3:
Input: words = [""cc"",""ll"",""xx""]
Output: 2
Explanation: One longest palindrome is ""cc"", of length 2.
Note that ""ll"" is another longest palindrome that can be created, and so is ""xx"".

Constraints:
1 <= words.length <= 105
words[i].length == 2
words[i] consists of lowercase English letters.
=end

# @param {String[]} words
# @return {Integer}
def longest_palindrome(a)
  r, m, h = 0, 0, a.tally
  h.each do
    if _1 == (k = _1.reverse)
      r += 4 * (_2 / 2)
      m |= _2 & 1
    else
      next unless (v = h[k])&.> 0
      r += 4 * [_2, v].min
      h[_1] = h[k] = 0
    end
  end
  r + m * 2
end
"
2140,solving-questions-with-brainpower,"# frozen_string_literal: true

# 2140. Solving Questions With Brainpower
# https://leetcode.com/problems/solving-questions-with-brainpower
# Medium

=begin
You are given a 0-indexed 2D integer array questions where questions[i] = [pointsi, brainpoweri].

The array describes the questions of an exam, where you have to process the questions in order (i.e., starting from question 0) and make a decision whether to solve or skip each question. Solving question i will earn you pointsi points but you will be unable to solve each of the next brainpoweri questions. If you skip question i, you get to make the decision on the next question.

For example, given questions = [[3, 2], [4, 3], [4, 4], [2, 5]]:
If question 0 is solved, you will earn 3 points but you will be unable to solve questions 1 and 2.
If instead, question 0 is skipped and question 1 is solved, you will earn 4 points but you will be unable to solve questions 2 and 3.
Return the maximum points you can earn for the exam.

Example 1:
Input: questions = [[3,2],[4,3],[4,4],[2,5]]
Output: 5
Explanation: The maximum points can be earned by solving questions 0 and 3.
- Solve question 0: Earn 3 points, will be unable to solve the next 2 questions
- Unable to solve questions 1 and 2
- Solve question 3: Earn 2 points
Total points earned: 3 + 2 = 5. There is no other way to earn 5 or more points.

Example 2:
Input: questions = [[1,1],[2,2],[3,3],[4,4],[5,5]]
Output: 7
Explanation: The maximum points can be earned by solving questions 1 and 4.
- Skip question 0
- Solve question 1: Earn 2 points, will be unable to solve the next 2 questions
- Unable to solve questions 2 and 3
- Solve question 4: Earn 5 points
Total points earned: 2 + 5 = 7. There is no other way to earn 7 or more points.

Constraints:
1 <= questions.length <= 105
questions[i].length == 2
1 <= pointsi, brainpoweri <= 105
=end

# @param {Integer[][]} questions
# @return {Integer}
def most_points(questions)
  dp = Array.new(questions.size + 1, 0)
  (questions.size - 1).downto(0) { |i|
    points, brainpower = questions[i]
    dp[i] = [points + (i + brainpower > questions.size - 2 ? 0 : dp[i + brainpower + 1]), dp[i + 1]].max
  }
  dp[0]
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_most_points < Test::Unit::TestCase
  def test_
    assert_equal 5, most_points([[3, 2], [4, 3], [4, 4], [2, 5]])
    assert_equal 7, most_points([[1, 1], [2, 2], [3, 3], [4, 4], [5, 5]])
  end
end
"
2141,maximum-running-time-of-n-computers,"# frozen_string_literal: true

# 2141. Maximum Running Time of N Computers
# Hard
# https://leetcode.com/problems/maximum-running-time-of-n-computers

=begin
You have n computers. You are given the integer n and a 0-indexed integer array batteries where the ith battery can run a computer for batteries[i] minutes. You are interested in running all n computers simultaneously using the given batteries.
Initially, you can insert at most one battery into each computer. After that and at any integer time moment, you can remove a battery from a computer and insert another battery any number of times. The inserted battery can be a totally new battery or a battery from another computer. You may assume that the removing and inserting processes take no time.
Note that the batteries cannot be recharged.
Return the maximum number of minutes you can run all the n computers simultaneously.

Example 1:
Input: n = 2, batteries = [3,3,3]
Output: 4
Explanation:
Initially, insert battery 0 into the first computer and battery 1 into the second computer.
After two minutes, remove battery 1 from the second computer and insert battery 2 instead. Note that battery 1 can still run for one minute.
At the end of the third minute, battery 0 is drained, and you need to remove it from the first computer and insert battery 1 instead.
By the end of the fourth minute, battery 1 is also drained, and the first computer is no longer running.
We can run the two computers simultaneously for at most 4 minutes, so we return 4.

Example 2:
Input: n = 2, batteries = [1,1,1,1]
Output: 2
Explanation:
Initially, insert battery 0 into the first computer and battery 2 into the second computer.
After one minute, battery 0 and battery 2 are drained so you need to remove them and insert battery 1 into the first computer and battery 3 into the second computer.
After another minute, battery 1 and battery 3 are also drained so the first and second computers are no longer running.
We can run the two computers simultaneously for at most 2 minutes, so we return 2.

Constraints:
* 1 <= n <= batteries.length <= 105
* 1 <= batteries[i] <= 109
=end

# @param {Integer} n
# @param {Integer[]} batteries
# @return {Integer}
def max_run_time(n, batteries)
  batteries.sort!

  extra = batteries[0...-n].sum

  live = batteries[-n..]

  for i in (0...n - 1)
    if extra / (i + 1) < live[i + 1] - live[i]
      return live[i] + extra / (i + 1)
    end

    extra -= (i + 1) * (live[i + 1] - live[i])
  end

  live[-1] + extra / n
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_max_run_time < Test::Unit::TestCase
  def test_
    assert_equal 4, max_run_time(2, [3, 3, 3])
    assert_equal 2, max_run_time(2, [1, 1, 1, 1])
  end
end
"
2147,number-of-ways-to-divide-a-long-corridor,"# frozen_string_literal: true

# 2147. Number of Ways to Divide a Long Corridor
# Hard
# leetcode.com/problems/number-of-ways-to-divide-a-long-corridor

=begin
Along a long library corridor, there is a line of seats and decorative plants. You are given a 0-indexed string corridor of length n consisting of letters 'S' and 'P' where each 'S' represents a seat and each 'P' represents a plant.
One room divider has already been installed to the left of index 0, and another to the right of index n - 1. Additional room dividers can be installed. For each position between indices i - 1 and i (1 <= i <= n - 1), at most one divider can be installed.
Divide the corridor into non-overlapping sections, where each section has exactly two seats with any number of plants. There may be multiple ways to perform the division. Two ways are different if there is a position with a room divider installed in the first way but not in the second way.
Return the number of ways to divide the corridor. Since the answer may be very large, return it modulo 109 + 7. If there is no way, return 0.

Example 1:
Input: corridor = ""SSPPSPS""
Output: 3
Explanation: There are 3 different ways to divide the corridor.
The black bars in the above image indicate the two room dividers already installed.
Note that in each of the ways, each section has exactly two seats.

Example 2:
Input: corridor = ""PPSPSP""
Output: 1
Explanation: There is only 1 way to divide the corridor, by not installing any additional dividers.
Installing any would create some section that does not have exactly two seats.

Example 3:
Input: corridor = ""S""
Output: 0
Explanation: There is no way to divide the corridor because there will always be a section that does not have exactly two seats.

Constraints:
n == corridor.length
1 <= n <= 105
corridor[i] is either 'S' or 'P'.
=end

# @param {String} corridor
# @return {Integer}
def number_of_ways(corridor)
  chairs_up_to_i = [0]
  corridor.each_char do |char|
    chairs_up_to_i << chairs_up_to_i[-1]
    chairs_up_to_i[-1] += 1 if char == ""S""
  end
  chairs_up_to_i.shift

  return 0 unless chairs_up_to_i[-1] % 2 == 0 && chairs_up_to_i[-1] > 0
  while chairs_up_to_i[-1] == chairs_up_to_i[-2]
    chairs_up_to_i.pop
  end

  count = chairs_up_to_i.tally
  i = 2
  prod = 1

  while count[i]
    prod *= count[i]
    i += 2
  end

  prod % 1000000007
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_number_of_ways < Test::Unit::TestCase
  def test_
    assert_equal 3, number_of_ways(""SSPPSPS"")
    assert_equal 1, number_of_ways(""PPSPSP"")
    assert_equal 0, number_of_ways(""S"")
  end
end
"
2187,minimum-time-to-complete-trips,"# frozen_string_literal: true

# 2187. Minimum Time to Complete Trips
# https://leetcode.com/problems/minimum-time-to-complete-trips

# @param {Integer[]} time
# @param {Integer} total_trips
# @return {Integer}
def minimum_time(time, total_trips)
  (1..time.min * total_trips).bsearch do |x|
    time.sum { x / _1 } >= total_trips
  end
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_minimum_time < Test::Unit::TestCase
  def test_
    assert_equal 3, minimum_time([1, 2, 3], 5)
    assert_equal 2, minimum_time([2], 1)
    assert_equal 4, minimum_time([1, 2, 3, 1], 10)
  end
end
"
2215,find-the-difference-of-two-arrays,"# frozen_string_literal: true

# 2215. Find the Difference of Two Arrays
# https://leetcode.com/problems/find-the-difference-of-two-arrays
# Easy

=begin
Given two 0-indexed integer arrays nums1 and nums2, return a list answer of size 2 where:
* answer[0] is a list of all distinct integers in nums1 which are not present in nums2.
* answer[1] is a list of all distinct integers in nums2 which are not present in nums1.
Note that the integers in the lists may be returned in any order.

Example 1:
Input: nums1 = [1,2,3], nums2 = [2,4,6]
Output: [[1,3],[4,6]]
Explanation:
For nums1, nums1[1] = 2 is present at index 0 of nums2, whereas nums1[0] = 1 and nums1[2] = 3 are not present in nums2. Therefore, answer[0] = [1,3].
For nums2, nums2[0] = 2 is present at index 1 of nums1, whereas nums2[1] = 4 and nums2[2] = 6 are not present in nums2. Therefore, answer[1] = [4,6].

Example 2:
Input: nums1 = [1,2,3,3], nums2 = [1,1,2,2]
Output: [[3],[]]
Explanation:
For nums1, nums1[2] and nums1[3] are not present in nums2. Since nums1[2] == nums1[3], their value is only included once and answer[0] = [3].
Every integer in nums2 is present in nums1. Therefore, answer[1] = [].

Constraints:
* 1 <= nums1.length, nums2.length <= 1000
* -1000 <= nums1[i], nums2[i] <= 1000
=end

# @param {Integer[]} nums1
# @param {Integer[]} nums2
# @return {Integer[][]}
def find_difference(*arrays)
  arrays.permutation.map { _1.reduce(:-).uniq }
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_find_difference < Test::Unit::TestCase
  def test_
    assert_equal [[1, 3], [4, 6]], find_difference([1, 2, 3], [2, 4, 6])
    assert_equal [[3], []], find_difference([1, 2, 3, 3], [1, 1, 2, 2])
  end
end
"
2218,maximum-value-of-k-coins-from-piles,"# frozen_string_literal: true

# 2218. Maximum Value of K Coins From Piles
# https://leetcode.com/problems/maximum-value-of-k-coins-from-piles/
# Hard

=begin

There are n piles of coins on a table. Each pile consists of a positive number of coins of assorted denominations.

In one move, you can choose any coin on top of any pile, remove it, and add it to your wallet.

Given a list piles, where piles[i] is a list of integers denoting the composition of the ith pile from top to bottom, and a positive integer k, return the maximum total value of coins you can have in your wallet if you choose exactly k coins optimally.

### Example 1:
Input: piles = [[1,100,3],[7,8,9]], k = 2
Output: 101
Explanation:
The above diagram shows the different ways we can choose k coins.
The maximum total we can obtain is 101.

### Example 2:
Input: piles = [[100],[100],[100],[100],[100],[100],[1,1,1,1,1,1,700]], k = 7
Output: 706
Explanation:
The maximum total can be obtained if we choose all coins from the last pile.

### Constraints:
* n == piles.length
* 1 <= n <= 1000
* 1 <= piles[i][j] <= 105
* 1 <= k <= sum(piles[i].length) <= 2000
=end

# @param {Integer[][]} piles
# @param {Integer} k
# @return {Integer}
def max_value_of_coins(piles, k)
  dp = Array.new(piles.size + 1) { Array.new(k + 1, -1) }
  solve(0, k, piles, dp)
end

def solve(i, kk, piles, dp)
  return 0 if i >= piles.size || !kk.positive?

  return dp[i][kk] if dp[i][kk] != -1

  cur = 0
  max_val = solve(i + 1, kk, piles, dp)
  [piles[i].size, kk].min.times do |j|
    cur += piles[i][j]
    max_val = [max_val, cur + solve(i + 1, kk - j - 1, piles, dp)].max
  end

  dp[i][kk] = max_val
  max_val
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_max_value_of_coins < Test::Unit::TestCase
  def test_
    assert_equal 101, max_value_of_coins([[1, 100, 3], [7, 8, 9]], 2)
    assert_equal 706, max_value_of_coins([[100], [100], [100], [100], [100], [100], [1, 1, 1, 1, 1, 1, 700]], 7)
  end
end
"
2251,number-of-flowers-in-full-bloom,"# frozen_string_literal: true

# 2251. Number of Flowers in Full Bloom
# Hard
# https://leetcode.com/problems/number-of-flowers-in-full-bloom

=begin
You are given a 0-indexed 2D integer array flowers, where flowers[i] = [starti, endi] means the ith flower will be in full bloom from starti to endi (inclusive). You are also given a 0-indexed integer array people of size n, where people[i] is the time that the ith person will arrive to see the flowers.
Return an integer array answer of size n, where answer[i] is the number of flowers that are in full bloom when the ith person arrives.

Example 1:
Input: flowers = [[1,6],[3,7],[9,12],[4,13]], poeple = [2,3,7,11]
Output: [1,2,2,2]
Explanation: The figure above shows the times when the flowers are in full bloom and when the people arrive.
For each person, we return the number of flowers in full bloom during their arrival.

Example 2:
Input: flowers = [[1,10],[3,3]], poeple = [3,3,2]
Output: [2,2,1]
Explanation: The figure above shows the times when the flowers are in full bloom and when the people arrive.
For each person, we return the number of flowers in full bloom during their arrival.

Constraints:
1 <= flowers.length <= 5 * 104
flowers[i].length == 2
1 <= starti <= endi <= 109
1 <= people.length <= 5 * 104
1 <= people[i] <= 109
=end

# @param {Integer[][]} flowers
# @param {Integer[]} people
# @return {Integer[]}
def full_bloom_flowers(flowers, people)
  flowers_size = flowers.size

  start_indices = flowers.map(&:first).sort
  end_indices = flowers.map(&:last).sort

  people.map do |num|
    start_index = start_indices.bsearch_index { |start_index| start_index > num }
    start_index ||= flowers_size

    end_index = end_indices.bsearch_index { |end_index| end_index >= num }
    end_index ||= flowers_size

    bloom_status = start_index - end_index

    bloom_status
  end
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_full_bloom_flowers < Test::Unit::TestCase
  def test_
    assert_equal [1, 2, 2, 2], full_bloom_flowers([[1, 6], [3, 7], [9, 12], [4, 13]], [2, 3, 7, 11])
    assert_equal [2, 2, 1], full_bloom_flowers([[1, 10], [3, 3]], [3, 3, 2])
  end
end
"
2264,largest-3-same-digit-number-in-string,"# frozen_string_literal: true

# 2264. Largest 3-Same-Digit Number in String
# Easy
# https://leetcode.com/problems/largest-3-same-digit-number-in-string

=begin
You are given a string num representing a large integer. An integer is good if it meets the following conditions:
* It is a substring of num with length 3.
* It consists of only one unique digit.
Return the maximum good integer as a string or an empty string """" if no such integer exists.

Note:
* A substring is a contiguous sequence of characters within a string.
* There may be leading zeroes in num or a good integer.

Example 1:
Input: num = ""6777133339""
Output: ""777""
Explanation: There are two distinct good integers: ""777"" and ""333"".
""777"" is the largest, so we return ""777"".

Example 2:
Input: num = ""2300019""
Output: ""000""
Explanation: ""000"" is the only good integer.

Example 3:
Input: num = ""42352338""
Output: """"
Explanation: No substring of length 3 consists of only one unique digit. Therefore, there are no good integers.

Constraints:
3 <= num.length <= 1000
num only consists of digits.
=end

# @param {String} num
# @return {String}
def largest_good_integer(num)
  res = []
  ans = """"

  for i in(0).upto(num.size - 1)
    if res.empty?
      res << num[i]
    elsif res[-1] != num[i]
      res = [num[i]]
    else
      res << num[i]
    end

    if res.size >= 3 && (ans[-1].to_i <= res[-1].to_i)
      ans = res[0..2].join
    end
  end

  ans
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_largest_good_integer < Test::Unit::TestCase
  def test_
    assert_equal ""777"", largest_good_integer(""6777133339"")
    assert_equal ""000"", largest_good_integer(""2300019"")
    assert_equal """", largest_good_integer(""42352338"")
  end
end
"
2265,count-nodes-equal-to-average-of-subtree,"# frozen_string_literal: true

# 2265. Count Nodes Equal to Average of Subtree
# Medium
# https://leetcode.com/problems/count-nodes-equal-to-average-of-subtree

=begin
Given the root of a binary tree, return the number of nodes where the value of the node is equal to the average of the values in its subtree.

Note:
* The average of n elements is the sum of the n elements divided by n and rounded down to the nearest integer.
* A subtree of root is a tree consisting of root and all of its descendants.

Example 1:
Input: root = [4,8,5,0,1,null,6]
Output: 5
Explanation:
For the node with value 4: The average of its subtree is (4 + 8 + 5 + 0 + 1 + 6) / 6 = 24 / 6 = 4.
For the node with value 5: The average of its subtree is (5 + 6) / 2 = 11 / 2 = 5.
For the node with value 0: The average of its subtree is 0 / 1 = 0.
For the node with value 1: The average of its subtree is 1 / 1 = 1.
For the node with value 6: The average of its subtree is 6 / 1 = 6.

Example 2:
Input: root = [1]
Output: 1
Explanation: For the node with value 1: The average of its subtree is 1 / 1 = 1.

Constraints:
* The number of nodes in the tree is in the range [1, 1000].
* 0 <= Node.val <= 1000
=end

# Definition for a binary tree node.
# class TreeNode
#     attr_accessor :val, :left, :right
#     def initialize(val = 0, left = nil, right = nil)
#         @val = val
#         @left = left
#         @right = right
#     end
# end
# @param {TreeNode} root
# @return {Integer}
def average_of_subtree(root)
  @count = 0
  dfs root
  @count
end

def dfs(root)
  return [0, 0] unless root

  left_count, left_sum = dfs root.left
  right_count, right_sum = dfs root.right

  subtree_sum = left_sum + right_sum + root.val
  subtree_count = left_count + right_count + 1

  @count += 1 if root.val == subtree_sum / subtree_count
  [subtree_count, subtree_sum]
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""

class TreeNode
  attr_accessor :val, :left, :right
  def initialize(val = 0, left = nil, right = nil)
    @val = val
    @left = left
    @right = right
  end
end

class TestAverageOfSubtree < Test::Unit::TestCase
  def test_average_of_subtree
    assert_equal 5, average_of_subtree(array_to_tree([4, 8, 5, 0, 1, nil, 6]))
    assert_equal 1, average_of_subtree(array_to_tree([1]))
  end

  private
    def array_to_tree(array)
      return nil if array.empty?

      nodes = array.map { |val| val.nil? ? nil : TreeNode.new(val) }
      kids = nodes.dup
      root = kids.shift

      nodes.each do |node|
        next if node.nil?
        node.left = kids.shift
        node.right = kids.shift
      end

      root
    end
end
"
2272,substring-with-largest-variance,"# frozen_string_literal: true

# 2272. Substring With Largest Variance
# Hard
# https://leetcode.com/problems/substring-with-largest-variance

=begin
The variance of a string is defined as the largest difference between the number of occurrences of any 2 characters present in the string. Note the two characters may or may not be the same.
Given a string s consisting of lowercase English letters only, return the largest variance possible among all substrings of s.
A substring is a contiguous sequence of characters within a string.

Example 1:
Input: s = ""aababbb""
Output: 3
Explanation:
All possible variances along with their respective substrings are listed below:
- Variance 0 for substrings ""a"", ""aa"", ""ab"", ""abab"", ""aababb"", ""ba"", ""b"", ""bb"", and ""bbb"".
- Variance 1 for substrings ""aab"", ""aba"", ""abb"", ""aabab"", ""ababb"", ""aababbb"", and ""bab"".
- Variance 2 for substrings ""aaba"", ""ababbb"", ""abbb"", and ""babb"".
- Variance 3 for substring ""babbb"".
Since the largest possible variance is 3, we return it.

Example 2:
Input: s = ""abcde""
Output: 0
Explanation:
No letter occurs more than once in s, so the variance of every substring is 0.

Constraints:
1 <= s.length <= 104
s consists of lowercase English letters.
=end

# @param {String} s
# @return {Integer}
def largest_variance(s)
  nchars = ""z"".ord - ""a"".ord + 1
  o, d, db = 0, Array.new(nchars) { Array.new(nchars, 0) }, Array.new(nchars) { Array.new(nchars, -s.size) }
  s.chars.each do |c|
    ch = c.ord - ""a"".ord
    nchars.times do |k|
      next if k == ch
      d[ch][k] += 1
      db[ch][k] += 1
      db[k][ch] = (d[k][ch] -= 1)
      d[k][ch] = [0, d[k][ch]].max
      o = [o, db[ch][k], db[k][ch]].max
    end
  end
  o
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_largest_variance < Test::Unit::TestCase
  def test_largest_variance
    assert_equal(3, largest_variance(""aababbb""))
    assert_equal(0, largest_variance(""abcde""))
    assert_equal(36, largest_variance(""sgajbhneaqajgzxfmflwhsilbruvdnsyiuudombiacrdavcmgpuyygijqzqlbzezkznjlzhekmceuxmahnwvodtghypaffmstmrajlatsusowvmpesnjpcgdkbljvuczeykvfxfbprxyhizdhovqhtbufeffardikqjcaabboknsfyfcwkzvmqurdzmxatdspsauvlvxsmsmdhjbsmeiszxpkwqyhrsectnbfeukedmcoivcuplgliruyqkzkoakougkgpngsrxawouixypzxzwixuzhhquuvxzixlqpufrypblhyyvyqzjkkiphljxxhezkxskhxlzmweiiwunhyshncpwfeddekwhuhvuxwnruyypeldrifwfsucdzfqzqmzwopqhugojkmaoinjursteivifmbjqjhbgwvbvrhneprsntsslepjxrzewqrlktlfotacuhzsyuapiwadnuviajwtgvjlxmfifgnoizmkbhlaudtagvzsapuufhrmkyjdshgavjxlkkuzipsmqykhzpflzyksuqihmffyvfnnzhggbcggngfckmjgpzoaxuhheqactdadbgoiogxyvawsqhhwestfxamfgaymluuafxvqhawwbotlgnlpdtgtzxkewwoziehskmxvlytenhnsngjisliyyssuhctyfzcdwvdyflzmwqbpttgsdhzyfnjylahaklhlqwjhpbzzrxsabkhiggpsafvzjlllwrfidnsarrezwxuhaqzczwxmknqgsinzrvsyzpkwarywgwkqaajsekaqydmkjqhcqkmamyisamfxatdumdbzudjtcbqasmshhvkivsavtrxlehewhsgrybfsfrrnrmsagsdwzpadwotqlnzroeamcdotgseohiihefptxjhmwbmpimeudowsizhjdlrqdhssvkesasypjojxpvcvbwjcyqvtzcwzcxyrmeqvdnkibjaikfplimodiczoaaryhbvyhrhoosunhrhhekupritwwoqkfmnpvzzabdrlnlscqsedjzcjjhfxrqzeuvwhrlrhpoqfsqctbudwixpbnehdcuwfmbuwtochwkefubfxeruurjbhpnnonqqmnrsfakvjpjjixxbnfrzegyabogvrfyaqpqltxykhxeekmisshdezkcrovpyzestqfktbtrwxtklymmhrcyxirgzzocpdnl""))
  end
end
"
2300,successful-pairs-of-spells-and-potions,"# frozen_string_literal: true

# 2300. Successful Pairs of Spells and Potions
# https://leetcode.com/problems/successful-pairs-of-spells-and-potions
# Medium

=begin

You are given two positive integer arrays spells and potions, of length n and m respectively, where spells[i] represents the strength of the ith spell and potions[j] represents the strength of the jth potion.

You are also given an integer success. A spell and potion pair is considered successful if the product of their strengths is at least success.

Return an integer array pairs of length n where pairs[i] is the number of potions that will form a successful pair with the ith spell.

### Example 1:
Input: spells = [5,1,3], potions = [1,2,3,4,5], success = 7
Output: [4,0,3]
Explanation:
- 0th spell: 5 * [1,2,3,4,5] = [5,10,15,20,25]. 4 pairs are successful.
- 1st spell: 1 * [1,2,3,4,5] = [1,2,3,4,5]. 0 pairs are successful.
- 2nd spell: 3 * [1,2,3,4,5] = [3,6,9,12,15]. 3 pairs are successful.
Thus, [4,0,3] is returned.

### Example 2:
Input: spells = [3,1,2], potions = [8,5,8], success = 16
Output: [2,0,2]
Explanation:
- 0th spell: 3 * [8,5,8] = [24,15,24]. 2 pairs are successful.
- 1st spell: 1 * [8,5,8] = [8,5,8]. 0 pairs are successful.
- 2nd spell: 2 * [8,5,8] = [16,10,16]. 2 pairs are successful.
Thus, [2,0,2] is returned.

### Constraints:
* n == spells.length
* m == potions.length
* 1 <= n, m <= 105
* 1 <= spells[i], potions[i] <= 105
* 1 <= success <= 1010
=end

# @param {Integer[]} spells
# @param {Integer[]} potions
# @param {Integer} success
# @return {Integer[]}
def successful_pairs(spells, potions, success)
  potions.sort!
  spells.map do |spell_str|
    min_pot_str = success.fdiv(spell_str)
    idx = potions.bsearch_index { |potion| potion >= min_pot_str }
    idx.nil? ? 0 : potions.size - idx
  end
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_successful_pairs < Test::Unit::TestCase
  def test_
    assert_equal [4, 0, 3], successful_pairs([5, 1, 3], [1, 2, 3, 4, 5], 7)
    assert_equal [2, 0, 2], successful_pairs([3, 1, 2], [8, 5, 8], 16)
  end
end
"
2305,fair-distribution-of-cookies,"# frozen_string_literal: true

# 2305. Fair Distribution of Cookies
# Medium
# https://leetcode.com/problems/fair-distribution-of-cookies

=begin
You are given an integer array cookies, where cookies[i] denotes the number of cookies in the ith bag. You are also given an integer k that denotes the number of children to distribute all the bags of cookies to. All the cookies in the same bag must go to the same child and cannot be split up.
The unfairness of a distribution is defined as the maximum total cookies obtained by a single child in the distribution.
Return the minimum unfairness of all distributions.

Example 1:
Input: cookies = [8,15,10,20,8], k = 2
Output: 31
Explanation: One optimal distribution is [8,15,8] and [10,20]
- The 1st child receives [8,15,8] which has a total of 8 + 15 + 8 = 31 cookies.
- The 2nd child receives [10,20] which has a total of 10 + 20 = 30 cookies.
The unfairness of the distribution is max(31,30) = 31.
It can be shown that there is no distribution with an unfairness less than 31.

Example 2:
Input: cookies = [6,1,3,2,2,4,1,2], k = 3
Output: 7
Explanation: One optimal distribution is [6,1], [3,2,2], and [4,1,2]
- The 1st child receives [6,1] which has a total of 6 + 1 = 7 cookies.
- The 2nd child receives [3,2,2] which has a total of 3 + 2 + 2 = 7 cookies.
- The 3rd child receives [4,1,2] which has a total of 4 + 1 + 2 = 7 cookies.
The unfairness of the distribution is max(7,7,7) = 7.
It can be shown that there is no distribution with an unfairness less than 7.

Constraints:
* 2 <= cookies.length <= 8
* 1 <= cookies[i] <= 105
* 2 <= k <= cookies.length
=end

# @param {Integer[]} cookies
# @param {Integer} k
# @return {Integer}
def distribute_cookies(cookies, k)
  return cookies.max if k == cookies.length
  cookies.sort!

  if cookies.length < 2 * k
    diff = 2 * k - cookies.length
    test = simple_cookies(cookies[0...cookies.length - diff], k - diff)
    return [test, cookies.max].max
  end

  simple_cookies(cookies.dup, k)
end

def simple_cookies(c, k)
  return c.max if c.length == k
  return c.sum if k == 1

  arrs = [Array.new(k, 0)]
  arrs[0][0] = c.shift

  until c.empty?
    ele = c.shift
    new_arrs = []
    arrs.each do |arr|
      (0...k).each do |i|
        new_arr = arr.dup
        new_arr[i] += ele
        new_arrs << new_arr
      end
      arrs = new_arrs
    end
  end

  arrs.map! { |arr| arr.max }
  arrs.min
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_distribute_cookies < Test::Unit::TestCase
  def test_
    assert_equal 31, distribute_cookies([8, 15, 10, 20, 8], 2)
    assert_equal 7, distribute_cookies([6, 1, 3, 2, 2, 4, 1, 2], 3)
  end
end
"
2316,count-unreachable-pairs-of-nodes-in-an-undirected-graph,"# frozen_string_literal: true

# 2316. Count Unreachable Pairs of Nodes in an Undirected Graph
# https://leetcode.com/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph

=begin

You are given an integer n. There is an undirected graph with n nodes, numbered from 0 to n - 1. You are given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting nodes ai and bi.

Return the number of pairs of different nodes that are unreachable from each other.

### Example 1:
Input: n = 3, edges = [[0,1],[0,2],[1,2]]
Output: 0
Explanation: There are no pairs of nodes that are unreachable from each other. Therefore, we return 0.

### Example 2:
Input: n = 7, edges = [[0,2],[0,5],[2,4],[1,6],[5,4]]
Output: 14
Explanation: There are 14 pairs of nodes that are unreachable from each other:
[[0,1],[0,3],[0,6],[1,2],[1,3],[1,4],[1,5],[2,3],[2,6],[3,4],[3,5],[3,6],[4,6],[5,6]].
Therefore, we return 14.

### Constraints:
* 1 <= n <= 105
* 0 <= edges.length <= 2 * 105
* edges[i].length == 2
* 0 <= ai, bi < n
* ai != bi
* There are no repeated edges.

=end

# Runtime: 403 ms
# Memory Usage: 247.1 MB
# @param {Integer} n
# @param {Integer[][]} edges
# @return {Integer}
def count_pairs(n, edges)
  @adj = Array.new(n + 1).map { [] }
  @v = Array.new(n + 1, false)
  @total = 0
  @ans = 0
  edges.each do |a, b|
    @adj[a].push(b)
    @adj[b].push(a)
  end
  (0...n).each do |i|
    next if @v[i]
    bfs(i)
  end
  @ans
end

def bfs(i)
  return if @v[i]
  count = 0
  q = [i]
  @v[i] = true
  while !q.empty?
    x = q.shift
    count += 1
    @ans += @total
    @adj[x].each do |j|
      next if @v[j]
      @v[j] = true
      q.push(j)
    end
  end
  @total += count
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_count_pairs < Test::Unit::TestCase
  def test_
    assert_equal 0, count_pairs(3, [[0, 1], [0, 2], [1, 2]])
    assert_equal 14, count_pairs(7, [[0, 2], [0, 5], [2, 4], [1, 6], [5, 4]])
  end
end
"
2328,number-of-increasing-paths-in-a-grid,"# frozen_string_literal: true

# https://leetcode.com/problems/number-of-increasing-paths-in-a-grid
# 2328. Number of Increasing Paths in a Grid
# Hard

=begin
You are given an m x n integer matrix grid, where you can move from a cell to any adjacent cell in all 4 directions.

Return the number of strictly increasing paths in the grid such that you can start from any cell and end at any cell. Since the answer may be very large, return it modulo 109 + 7.

Two paths are considered different if they do not have exactly the same sequence of visited cells.

Example 1:
Input: grid = [[1,1],[3,4]]
Output: 8
Explanation: The strictly increasing paths are:
- Paths with length 1: [1], [1], [3], [4].
- Paths with length 2: [1 -> 3], [1 -> 4], [3 -> 4].
- Paths with length 3: [1 -> 3 -> 4].
The total number of paths is 4 + 3 + 1 = 8.

Example 2:
Input: grid = [[1],[2]]
Output: 3
Explanation: The strictly increasing paths are:
- Paths with length 1: [1], [2].
- Paths with length 2: [1 -> 2].
The total number of paths is 2 + 1 = 3.

Constraints:
* m == grid.length
* n == grid[i].length
* 1 <= m, n <= 1000
* 1 <= m * n <= 105
* 1 <= grid[i][j] <= 105
=end

# @param {Integer[][]} grid
# @return {Integer}
def count_paths(grid)
  max_row_index = grid.size - 1
  max_col_index = grid.first.size - 1
  result_grid = Array.new(grid.size) { Array.new(grid.first.size, nil) }
  total_result = 0
  mod = 10**9 + 7

  dfs = lambda do |row_index, col_index, previous|
    return 0 unless row_index.between?(0, max_row_index) && col_index.between?(0, max_col_index)
    cell = grid[row_index][col_index]
    return 0 unless cell > previous
    return result_grid[row_index][col_index] if result_grid[row_index][col_index]

    steps = [[-1, 0], [1, 0], [0, -1], [0, 1]]
    result = steps.sum do |step_row, step_col|
      dfs.call(row_index + step_row, col_index + step_col, cell)
    end + 1

    result_grid[row_index][col_index] = result % mod
  end

  0.upto(max_row_index) do |row_index|
    0.upto(max_col_index) do |col_index|
      total_result += dfs.call(row_index, col_index, -Float::INFINITY)
    end
  end

  total_result % mod
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_count_paths < Test::Unit::TestCase
  def test_
    assert_equal 8, count_paths([[1, 1], [3, 4]])
    assert_equal 3, count_paths([[1], [2]])
  end
end
"
2336,smallest-number-in-infinite-set,"# frozen_string_literal: true

# 2336. Smallest Number in Infinite Set
# https://leetcode.com/problems/smallest-number-in-infinite-set
# Medium

=begin
You have a set which contains all positive integers [1, 2, 3, 4, 5, ...].

Implement the SmallestInfiniteSet class:

* SmallestInfiniteSet() Initializes the SmallestInfiniteSet object to contain all positive integers.
* int popSmallest() Removes and returns the smallest integer contained in the infinite set.
* void addBack(int num) Adds a positive integer num back into the infinite set, if it is not already in the infinite set.

Example 1:
Input
[""SmallestInfiniteSet"", ""addBack"", ""popSmallest"", ""popSmallest"", ""popSmallest"", ""addBack"", ""popSmallest"", ""popSmallest"", ""popSmallest""]
[[], [2], [], [], [], [1], [], [], []]
Output
[null, null, 1, 2, 3, null, 1, 4, 5]

Explanation
SmallestInfiniteSet smallestInfiniteSet = new SmallestInfiniteSet();
smallestInfiniteSet.addBack(2);    // 2 is already in the set, so no change is made.
smallestInfiniteSet.popSmallest(); // return 1, since 1 is the smallest number, and remove it from the set.
smallestInfiniteSet.popSmallest(); // return 2, and remove it from the set.
smallestInfiniteSet.popSmallest(); // return 3, and remove it from the set.
smallestInfiniteSet.addBack(1);    // 1 is added back to the set.
smallestInfiniteSet.popSmallest(); // return 1, since 1 was added back to the set and
                                   // is the smallest number, and remove it from the set.
smallestInfiniteSet.popSmallest(); // return 4, and remove it from the set.
smallestInfiniteSet.popSmallest(); // return 5, and remove it from the set.


Constraints:
1 <= num <= 1000
At most 1000 calls will be made in total to popSmallest and addBack.
=end

class SmallestInfiniteSet
  def initialize
    @t = CRBTreeMap.new
    @c = 0
  end


=begin
    :rtype: Integer
=end
  def pop_smallest
    @t.empty? ? @c += 1 : @t.delete_min
  end


=begin
    :type num: Integer
    :rtype: Void
=end
  def add_back(num)
    @t[num] = num if num <= @c
  end
end

# Your SmallestInfiniteSet object will be instantiated and called as such:
# obj = SmallestInfiniteSet.new()
# param_1 = obj.pop_smallest()
# obj.add_back(num)
"
2348,number-of-zero-filled-subarrays,"# frozen_string_literal: true

# 2348. Number of Zero-Filled Subarrays
# https://leetcode.com/problems/number-of-zero-filled-subarrays

=begin

Given an integer array nums, return the number of subarrays filled with 0.

A subarray is a contiguous non-empty sequence of elements within an array.

### Constraints:

* 1 <= nums.length <= 105
* -109 <= nums[i] <= 109

=end

# Runtime 202 ms, Beats 100%
# Memory 223 MB, Beats 100%
# @param {Integer[]} nums
# @return {Integer}
def zero_filled_subarray(nums)
  res = i = j = 0

  while i < nums.size
    j = i + 1 if nums[i] != 0
    res += i - j + 1
    i += 1
  end

  res
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_zero_filled_subarray < Test::Unit::TestCase
  def test_
    assert_equal 6, zero_filled_subarray([1, 3, 0, 0, 2, 0, 0, 4])
    assert_equal 9, zero_filled_subarray([0, 0, 0, 2, 0, 0])
    assert_equal 0, zero_filled_subarray([2, 10, 2019])
  end
end
"
2352,equal-row-and-column-pairs,"# frozen_string_literal: true

# 2352. Equal Row and Column Pairs
# https://leetcode.com/problems/equal-row-and-column-pairs
# Medium

=begin
Given a 0-indexed n x n integer matrix grid, return the number of pairs (ri, cj) such that row ri and column cj are equal.

A row and column pair is considered equal if they contain the same elements in the same order (i.e., an equal array).

Example 1:
Input: grid = [[3,2,1],[1,7,6],[2,7,7]]
Output: 1
Explanation: There is 1 equal row and column pair:
- (Row 2, Column 1): [2,7,7]

Example 2:
Input: grid = [[3,1,2,2],[1,4,4,5],[2,4,2,2],[2,4,2,2]]
Output: 3
Explanation: There are 3 equal row and column pairs:
- (Row 0, Column 0): [3,1,2,2]
- (Row 2, Column 2): [2,4,2,2]
- (Row 3, Column 2): [2,4,2,2]

Constraints:
n == grid.length == grid[i].length
1 <= n <= 200
1 <= grid[i][j] <= 105
=end

# @param {Integer[][]} grid
# @return {Integer}
def equal_pairs(grid)
  row_counts = Hash.new(0)
  col_counts = Hash.new(0)
  result = 0
  grid.each { |el| row_counts[el] += 1 }
  grid.size.times { |i| col_counts[grid.map { |el| el[i - 1] }] += 1 }

  row_counts.each do |key, value|
    if !col_counts[key].nil?
      result += value * col_counts[key]
    end
  end
  result
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_equal_pairs < Test::Unit::TestCase
  def test_
    assert_equal 1, equal_pairs([[3, 2, 1], [1, 7, 6], [2, 7, 7]])
    assert_equal 3, equal_pairs([[3, 1, 2, 2], [1, 4, 4, 5], [2, 4, 2, 2], [2, 4, 2, 2]])
  end
end
"
2353,design-a-food-rating-system,"# frozen_string_literal: true

# 2353. Design a Food Rating System
# Medium
# https://leetcode.com/problems/design-a-food-rating-system

=begin
Design a food rating system that can do the following:
* Modify the rating of a food item listed in the system.
* Return the highest-rated food item for a type of cuisine in the system.
Implement the FoodRatings class:

* FoodRatings(String[] foods, String[] cuisines, int[] ratings) Initializes the system. The food items are described by foods, cuisines and ratings, all of which have a length of n.
  * foods[i] is the name of the ith food,
  * cuisines[i] is the type of cuisine of the ith food, and
* ratings[i] is the initial rating of the ith food.
* void changeRating(String food, int newRating) Changes the rating of the food item with the name food.
* String highestRated(String cuisine) Returns the name of the food item that has the highest rating for the given type of cuisine. If there is a tie, return the item with the lexicographically smaller name.
Note that a string x is lexicographically smaller than string y if x comes before y in dictionary order, that is, either x is a prefix of y, or if i is the first position such that x[i] != y[i], then x[i] comes before y[i] in alphabetic order.

Example 1:
Input
[""FoodRatings"", ""highestRated"", ""highestRated"", ""changeRating"", ""highestRated"", ""changeRating"", ""highestRated""]
[[[""kimchi"", ""miso"", ""sushi"", ""moussaka"", ""ramen"", ""bulgogi""], [""korean"", ""japanese"", ""japanese"", ""greek"", ""japanese"", ""korean""], [9, 12, 8, 15, 14, 7]], [""korean""], [""japanese""], [""sushi"", 16], [""japanese""], [""ramen"", 16], [""japanese""]]
Output
[null, ""kimchi"", ""ramen"", null, ""sushi"", null, ""ramen""]

Explanation
FoodRatings foodRatings = new FoodRatings([""kimchi"", ""miso"", ""sushi"", ""moussaka"", ""ramen"", ""bulgogi""], [""korean"", ""japanese"", ""japanese"", ""greek"", ""japanese"", ""korean""], [9, 12, 8, 15, 14, 7]);
foodRatings.highestRated(""korean""); // return ""kimchi""
                                    // ""kimchi"" is the highest rated korean food with a rating of 9.
foodRatings.highestRated(""japanese""); // return ""ramen""
                                      // ""ramen"" is the highest rated japanese food with a rating of 14.
foodRatings.changeRating(""sushi"", 16); // ""sushi"" now has a rating of 16.
foodRatings.highestRated(""japanese""); // return ""sushi""
                                      // ""sushi"" is the highest rated japanese food with a rating of 16.
foodRatings.changeRating(""ramen"", 16); // ""ramen"" now has a rating of 16.
foodRatings.highestRated(""japanese""); // return ""ramen""
                                      // Both ""sushi"" and ""ramen"" have a rating of 16.
                                      // However, ""ramen"" is lexicographically smaller than ""sushi"".

Constraints:
1 <= n <= 2 * 104
n == foods.length == cuisines.length == ratings.length
1 <= foods[i].length, cuisines[i].length <= 10
foods[i], cuisines[i] consist of lowercase English letters.
1 <= ratings[i] <= 108
All the strings in foods are distinct.
food will be the name of a food item in the system across all calls to changeRating.
cuisine will be a type of cuisine of at least one food item in the system across all calls to highestRated.
At most 2 * 104 calls in total will be made to changeRating and highestRated.
=end

class FoodRatings
  def initialize(f, c, r)
    @c, @f = {}, {}
    f.each_with_index do | f, i |
      @f[f] = [c[i], -r[i]]
      @c[c[i]] ||= CRBTreeMap.new
      @c[c[i]].push [-r[i], f], true
    end
  end

  def change_rating(f, n)
    c, p = @f[f]
    n = -n
    if p != n
      @f[f] = [c, n]
      @c[c].delete [p, f]
      @c[c].push [n, f], true
    end
  end

  def highest_rated(c)
    @c[c].min_key.last
  end
end

# Your FoodRatings object will be instantiated and called as such:
# obj = FoodRatings.new(foods, cuisines, ratings)
# obj.change_rating(food, new_rating)
# param_2 = obj.highest_rated(cuisine)
"
2360,longest-cycle-in-a-graph,"# frozen_string_literal: true

# 2360. Longest Cycle in a Graph
# https://leetcode.com/problems/longest-cycle-in-a-graph

=begin

You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.

The graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from node i, then edges[i] == -1.

Return the length of the longest cycle in the graph. If no cycle exists, return -1.

A cycle is a path that starts and ends at the same node.

### Example 1:
Input: edges = [3,3,4,2,3]
Output: 3
Explanation: The longest cycle in the graph is the cycle: 2 -> 4 -> 3 -> 2.
The length of this cycle is 3, so 3 is returned.

### Example 2:
Input: edges = [2,-1,3,1]
Output: -1
Explanation: There are no cycles in this graph.

### Constraints:
* n == edges.length
* 2 <= n <= 105
* -1 <= edges[i] < n
* edges[i] != i

=end

# Runtime 379 ms
# Memory 228.1 MB
# @param {Integer[]} edges
# @return {Integer}
def longest_cycle(edges)
  max = -1

  edges.size.times do |cur|
    next if edges[cur] < 0
    dists = {}
    dist = 0
    until cur < 0
      if dists[cur]
        cycle = dist - dists[cur]
        max = cycle if cycle > max
        break
      else
        dists[cur] = dist
        cur, edges[cur] = edges[cur], -1
        dist += 1
      end
    end
  end

  max
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_longest_cycle < Test::Unit::TestCase
  def test_
    assert_equal 3, longest_cycle([3, 3, 4, 2, 3])
    assert_equal(-1, longest_cycle([2, -1, 3, 1]))
  end
end
"
2366,minimum-replacements-to-sort-the-array,"# frozen_string_literal: true

# 2366. Minimum Replacements to Sort the Array
# Hard
# https://leetcode.com/problems/minimum-replacements-to-sort-the-array

=begin
You are given a 0-indexed integer array nums. In one operation you can replace any element of the array with any two elements that sum to it.
For example, consider nums = [5,6,7]. In one operation, we can replace nums[1] with 2 and 4 and convert nums to [5,2,4,7].
Return the minimum number of operations to make an array that is sorted in non-decreasing order.

Example 1:
Input: nums = [3,9,3]
Output: 2
Explanation: Here are the steps to sort the array in non-decreasing order:
- From [3,9,3], replace the 9 with 3 and 6 so the array becomes [3,3,6,3]
- From [3,3,6,3], replace the 6 with 3 and 3 so the array becomes [3,3,3,3,3]
There are 2 steps to sort the array in non-decreasing order. Therefore, we return 2.

Example 2:
Input: nums = [1,2,3,4,5]
Output: 0
Explanation: The array is already in non-decreasing order. Therefore, we return 0.

Constraints:
* 1 <= nums.length <= 10^5
* 1 <= nums[i] <= 109
=end

# @param {Integer[]} nums
# @return {Integer}
def minimum_replacement(nums)
  result = 0
  n = nums.size

  (n - 2).downto(0) do |i|
    curr = nums[i]
    _next = nums[i + 1]

    if curr > _next
      higher_bound = (curr / _next.to_f).ceil
      result += higher_bound - 1
      nums[i] = (curr / higher_bound).floor
    end
  end

  result
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_minimum_replacement < Test::Unit::TestCase
  def test_
    assert_equal 2, minimum_replacement([3, 9, 3])
    assert_equal 0, minimum_replacement([1, 2, 3, 4, 5])
  end
end
"
2369,check-if-there-is-a-valid-partition-for-the-array,"# frozen_string_literal: true

# 2369. Check if There is a Valid Partition For The Array
# Medium
# https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array

=begin
You are given a 0-indexed integer array nums. You have to partition the array into one or more contiguous subarrays.
We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions:
1. The subarray consists of exactly 2 equal elements. For example, the subarray [2,2] is good.
2. The subarray consists of exactly 3 equal elements. For example, the subarray [4,4,4] is good.
3. The subarray consists of exactly 3 consecutive increasing elements, that is, the difference between adjacent elements is 1. For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not.
Return true if the array has at least one valid partition. Otherwise, return false.

Example 1:
Input: nums = [4,4,4,5,6]
Output: true
Explanation: The array can be partitioned into the subarrays [4,4] and [4,5,6].
This partition is valid, so we return true.

Example 2:
Input: nums = [1,1,1,2]
Output: false
Explanation: There is no valid partition for this array.

Constraints:
* 2 <= nums.length <= 105
* 1 <= nums[i] <= 106
=end

# @param {Integer[]} nums
# @return {Boolean}
def valid_partition(nums, memo = {})
  return true if nums.empty?

  memo[nums.size] ||= [
    nums.size >= 2 && eq?(nums[-2..])   && valid_partition(nums[0...-2], memo),
    nums.size >= 3 && eq?(nums[-3..])   && valid_partition(nums[0...-3], memo),
    nums.size >= 3 && cons?(nums[-3..]) && valid_partition(nums[0...-3], memo),
  ].any?
end

# checks if all elements of an array are the same
def eq?(arr)
  arr.uniq.one?
end

# checks if all elements of an array are increasing by one
def cons?(arr)
  arr.reverse.map.with_index { |e, i| e + i }.uniq.one?
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_valid_partition < Test::Unit::TestCase
  def test_
    assert_equal true, valid_partition([4, 4, 4, 5, 6])
    assert_equal false, valid_partition([1, 1, 1, 2])
    assert_equal false, valid_partition([923198, 923198, 701131, 701132])
  end
end
"
2390,removing-stars-from-a-string,"# frozen_string_literal: true

# 2390. Removing Stars From a String
# https://leetcode.com/problems/removing-stars-from-a-string/
# Medium

=begin

You are given a string s, which contains stars *.

In one operation, you can:

* Choose a star in s.
* Remove the closest non-star character to its left, as well as remove the star itself.

Return the string after all stars have been removed.

Note:

* The input will be generated such that the operation is always possible.
* It can be shown that the resulting string will always be unique.

### Example 1:
Input: s = ""leet**cod*e""
Output: ""lecoe""
Explanation: Performing the removals from left to right:
- The closest character to the 1st star is 't' in ""leet**cod*e"". s becomes ""lee*cod*e"".
- The closest character to the 2nd star is 'e' in ""lee*cod*e"". s becomes ""lecod*e"".
- The closest character to the 3rd star is 'd' in ""lecod*e"". s becomes ""lecoe"".
There are no more stars, so we return ""lecoe"".

### Example 2:
Input: s = ""erase*****""
Output: """"
Explanation: The entire string is removed, so we return an empty string.

### Constraints:
* 1 <= s.length <= 105
* s consists of lowercase English letters and stars *.
* The operation above can be performed on s.

=end

# @param {String} s
# @return {String}
def remove_stars(s)
  r = []
  s.each_byte do
    _1 == 42 ? r.pop : r << _1
  end
  r.pack ""c*""
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_remove_stars < Test::Unit::TestCase
  def test_
    assert_equal ""lecoe"", remove_stars(""leet**cod*e"")
    assert_equal """", remove_stars(""erase*****"")
  end
end
"
2391,minimum-amount-of-time-to-collect-garbage,"# frozen_string_literal: true

# 2391. Minimum Amount of Time to Collect Garbage
# Medium
# https://leetcode.com/problems/minimum-amount-of-time-to-collect-garbage

=begin
You are given a 0-indexed array of strings garbage where garbage[i] represents the assortment of garbage at the ith house. garbage[i] consists only of the characters 'M', 'P' and 'G' representing one unit of metal, paper and glass garbage respectively. Picking up one unit of any type of garbage takes 1 minute.
You are also given a 0-indexed integer array travel where travel[i] is the number of minutes needed to go from house i to house i + 1.
There are three garbage trucks in the city, each responsible for picking up one type of garbage. Each garbage truck starts at house 0 and must visit each house in order; however, they do not need to visit every house.
Only one garbage truck may be used at any given moment. While one truck is driving or picking up garbage, the other two trucks cannot do anything.
Return the minimum number of minutes needed to pick up all the garbage.

Example 1:
Input: garbage = [""G"",""P"",""GP"",""GG""], travel = [2,4,3]
Output: 21
Explanation:
The paper garbage truck:
1. Travels from house 0 to house 1
2. Collects the paper garbage at house 1
3. Travels from house 1 to house 2
4. Collects the paper garbage at house 2
Altogether, it takes 8 minutes to pick up all the paper garbage.
The glass garbage truck:
1. Collects the glass garbage at house 0
2. Travels from house 0 to house 1
3. Travels from house 1 to house 2
4. Collects the glass garbage at house 2
5. Travels from house 2 to house 3
6. Collects the glass garbage at house 3
Altogether, it takes 13 minutes to pick up all the glass garbage.
Since there is no metal garbage, we do not need to consider the metal garbage truck.
Therefore, it takes a total of 8 + 13 = 21 minutes to collect all the garbage.

Example 2:
Input: garbage = [""MMM"",""PGM"",""GP""], travel = [3,10]
Output: 37
Explanation:
The metal garbage truck takes 7 minutes to pick up all the metal garbage.
The paper garbage truck takes 15 minutes to pick up all the paper garbage.
The glass garbage truck takes 15 minutes to pick up all the glass garbage.
It takes a total of 7 + 15 + 15 = 37 minutes to collect all the garbage.

Constraints:
2 <= garbage.length <= 105
garbage[i] consists of only the letters 'M', 'P', and 'G'.
1 <= garbage[i].length <= 10
travel.length == garbage.length - 1
1 <= travel[i] <= 100
=end

# @param {String[]} garbage
# @param {Integer[]} travel
# @return {Integer}
def garbage_collection(garbage, travel)
  sum = 0
  mul = 0
  p = 0
  g = 0
  m = 0

  (garbage.length - 1).downto(1) do |i|
    sum += garbage[i].length

    if mul < 3
      garbage[i].each_char do |ch|
        case ch
        when ""P""
          mul = p == 0 ? mul + 1 : mul
          p += 1
        when ""G""
          mul = g == 0 ? mul + 1 : mul
          g += 1
        when ""M""
          mul = m == 0 ? mul + 1 : mul
          m += 1
        end
      end
    end

    sum += mul * travel[i - 1]
  end

  sum += garbage[0].length
  sum
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_garbage_collection < Test::Unit::TestCase
  def test_
    assert_equal 21, garbage_collection([""G"", ""P"", ""GP"", ""GG""], [2, 4, 3])
    assert_equal 37, garbage_collection([""MMM"", ""PGM"", ""GP""], [3, 10])
  end
end
"
2405,optimal-partition-of-string,"# frozen_string_literal: true

# 2405. Optimal Partition of String
# https://leetcode.com/problems/optimal-partition-of-string

=begin

Given a string s, partition the string into one or more substrings such that the characters in each substring are unique. That is, no letter appears in a single substring more than once.

Return the minimum number of substrings in such a partition.

Note that each character should belong to exactly one substring in a partition.

### Example 1:
Input: s = ""abacaba""
Output: 4
Explanation:
Two possible partitions are (""a"",""ba"",""cab"",""a"") and (""ab"",""a"",""ca"",""ba"").
It can be shown that 4 is the minimum number of substrings needed.

### Example 2:
Input: s = ""ssssss""
Output: 6
Explanation:
The only valid partition is (""s"",""s"",""s"",""s"",""s"",""s"").

### Constraints:
* 1 <= s.length <= 105
* s consists of only English lowercase letters.

=end

# @param {String} s
# @return {Integer}
def partition_string(s)
  temp = """"
  count = 1
  s.each_char do |c|
    if temp.include?(c)
      count += 1
      temp = c
    else
      temp += c
    end
  end
  count
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_partition_string < Test::Unit::TestCase
  def test_
    assert_equal 4, partition_string(""abacaba"")
    assert_equal 6, partition_string(""ssssss"")
  end
end
"
2409,count-days-spent-together,"# frozen_string_literal: true

# 2409. Count Days Spent Together
# https://leetcode.com/problems/count-days-spent-together

# @param {String} arrive_alice
# @param {String} leave_alice
# @param {String} arrive_bob
# @param {String} leave_bob
# @return {Integer}
def count_days_together(arrive_alice, leave_alice, arrive_bob, leave_bob)
  return 0 if arrive_alice > leave_bob || arrive_bob > leave_alice

  start_date = [arrive_alice, arrive_bob].max
  end_date = [leave_alice, leave_bob].min
  days(end_date) - days(start_date) + 1
end

def days(date)
  days_per_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
  month, day = date.split(""-"").map(&:to_i)
  (0..(month - 2)).reduce(day) do |total, i|
    total + days_per_month[i]
  end
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_count_days_together < Test::Unit::TestCase
  def test_
    assert_equal 3, count_days_together(""08-15"", ""08-18"", ""08-16"", ""08-19"")
    assert_equal 0, count_days_together(""10-01"", ""10-31"", ""11-01"", ""12-31"")
  end
end
"
2413,smallest-even-multiple,"# frozen_string_literal: true

# 2413. Smallest Even Multiple
# https://leetcode.com/problems/smallest-even-multiple

# @param {Integer} n
# @return {Integer}
def smallest_even_multiple(n)
  n.even? ? n : 2 * n
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_smallest_even_multiple < Test::Unit::TestCase
  def test_
    assert_equal 10, smallest_even_multiple(5)
    assert_equal 6, smallest_even_multiple(6)
  end
end
"
2433,find-the-original-array-of-prefix-xor,"# frozen_string_literal: true

# 2433. Find The Original Array of Prefix Xor
# Medium
# https://leetcode.com/problems/find-the-original-array-of-prefix-xor

=begin
You are given an integer array pref of size n. Find and return the array arr of size n that satisfies:
* pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i].
Note that ^ denotes the bitwise-xor operation.

It can be proven that the answer is unique.


Example 1:
Input: pref = [5,2,0,3,1]
Output: [5,7,2,3,2]
Explanation: From the array [5,7,2,3,2] we have the following:
- pref[0] = 5.
- pref[1] = 5 ^ 7 = 2.
- pref[2] = 5 ^ 7 ^ 2 = 0.
- pref[3] = 5 ^ 7 ^ 2 ^ 3 = 3.
- pref[4] = 5 ^ 7 ^ 2 ^ 3 ^ 2 = 1.

Example 2:
Input: pref = [13]
Output: [13]
Explanation: We have pref[0] = arr[0] = 13.

Constraints:
* 1 <= pref.length <= 105
* 0 <= pref[i] <= 106
=end

# @param {Integer[]} pref
# @return {Integer[]}
def find_array(pref)
  [0, *pref].each_cons(2).map { _1 ^ _2 }
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_find_array < Test::Unit::TestCase
  def test_
    assert_equal [5, 7, 2, 3, 2], find_array([5, 2, 0, 3, 1])
    assert_equal [13], find_array([13])
  end
end
"
2439,minimize-maximum-of-array,"# frozen_string_literal: true

# 2439. Minimize Maximum of Array
# https://leetcode.com/problems/minimize-maximum-of-array

=begin

You are given a 0-indexed array nums comprising of n non-negative integers.

In one operation, you must:
* Choose an integer i such that 1 <= i < n and nums[i] > 0.
* Decrease nums[i] by 1.
* Increase nums[i - 1] by 1.
Return the minimum possible value of the maximum integer of nums after performing any number of operations.

### Example 1:
Input: nums = [3,7,1,6]
Output: 5
Explanation:
One set of optimal operations is as follows:
1. Choose i = 1, and nums becomes [4,6,1,6].
2. Choose i = 3, and nums becomes [4,6,2,5].
3. Choose i = 1, and nums becomes [5,5,2,5].
The maximum integer of nums is 5. It can be shown that the maximum number cannot be less than 5.
Therefore, we return 5.

### Example 2:
Input: nums = [10,1]
Output: 10
Explanation:
It is optimal to leave nums as is, and since 10 is the maximum value, we return 10.

### Constraints:
* n == nums.length
* 2 <= n <= 105
* 0 <= nums[i] <= 109

=end

# @param {Integer[]} nums
# @return {Integer}
def minimize_array_value(nums)
  minmax = 0
  sum = 0
  (0...nums.size).each do |i|
    sum += nums[i]
    minmax = [(sum + i) / (i + 1), minmax].max
  end
  minmax
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_minimize_array_value < Test::Unit::TestCase
  def test_
    assert_equal 5, minimize_array_value([3, 7, 1, 6])
    assert_equal 10, minimize_array_value([10, 1])
  end
end
"
2444,count-subarrays-with-fixed-bounds,"# frozen_string_literal: true

# 2444. Count Subarrays With Fixed Bounds
# https://leetcode.com/problems/count-subarrays-with-fixed-bounds
# Hard

# @param {Integer[]} nums
# @param {Integer} min_k
# @param {Integer} max_k
# @return {Integer}
def count_subarrays(nums, min_k, max_k)
  max_found = min_found = false
  start = 0
  res = 0
  min_index = max_index = 0
  nums.each_with_index do |num, i|
    unless num.between?(min_k, max_k)
      start = i + 1
      min_found = max_found = false
    else
      if num == min_k
        min_found = true
        min_index = i
      end
      if num == max_k
        max_found = true
        max_index = i
      end
      if min_found && max_found
        res += ([min_index, max_index].min - start + 1)
      end
    end
  end
  res
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_count_subarrays < Test::Unit::TestCase
  def test_
    assert_equal 2, count_subarrays([1, 3, 5, 2, 7, 5], 1, 5)
    assert_equal 10, count_subarrays([1, 1, 1, 1], 1, 1)
  end
end
"
2448,minimum-cost-to-make-array-equal,"# frozen_string_literal: true

# 2448. Minimum Cost to Make Array Equal
# Hard
# https://leetcode.com/problems/minimum-cost-to-make-array-equal

=begin
You are given two 0-indexed arrays nums and cost consisting each of n positive integers.
You can do the following operation any number of times:
* Increase or decrease any element of the array nums by 1.
The cost of doing one operation on the ith element is cost[i].
Return the minimum total cost such that all the elements of the array nums become equal.

Example 1:
Input: nums = [1,3,5,2], cost = [2,3,1,14]
Output: 8
Explanation: We can make all the elements equal to 2 in the following way:
- Increase the 0th element one time. The cost is 2.
- Decrease the 1st element one time. The cost is 3.
- Decrease the 2nd element three times. The cost is 1 + 1 + 1 = 3.
The total cost is 2 + 3 + 3 = 8.
It can be shown that we cannot make the array equal with a smaller cost.

Example 2:
Input: nums = [2,2,2,2,2], cost = [4,2,8,1,3]
Output: 0
Explanation: All the elements are already equal, so no operations are needed.

Constraints:
* n == nums.length == cost.length
* 1 <= n <= 105
* 1 <= nums[i], cost[i] <= 106
=end

# @param {Integer[]} nums
# @param {Integer[]} costs
# @return {Integer}
def min_cost(nums, costs)
  min, max = nums.minmax
  return 0 if min == max

  memo = Hash.new { |h, k| h[k] = nums.zip(costs).sum(0) { |number, cost| cost * (k - number).abs } }
  memo[(min..max).bsearch { |number| memo[number] < memo[number + 1] }]
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_min_cost < Test::Unit::TestCase
  def test_
    assert_equal 8, min_cost([1, 3, 5, 2], [2, 3, 1, 14])
    assert_equal 0, min_cost([2, 2, 2, 2, 2], [4, 2, 8, 1, 3])
  end
end
"
2462,total-cost-to-hire-k-workers,"# frozen_string_literal: true

# 2462. Total Cost to Hire K Workers
# https://leetcode.com/problems/total-cost-to-hire-k-workers
# Medium
# TODO: Implement

=begin
You are given a 0-indexed integer array costs where costs[i] is the cost of hiring the ith worker.

You are also given two integers k and candidates. We want to hire exactly k workers according to the following rules:

You will run k sessions and hire exactly one worker in each session.
In each hiring session, choose the worker with the lowest cost from either the first candidates workers or the last candidates workers. Break the tie by the smallest index.
For example, if costs = [3,2,7,7,1,2] and candidates = 2, then in the first hiring session, we will choose the 4th worker because they have the lowest cost [3,2,7,7,1,2].
In the second hiring session, we will choose 1st worker because they have the same lowest cost as 4th worker but they have the smallest index [3,2,7,7,2]. Please note that the indexing may be changed in the process.
If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them. Break the tie by the smallest index.
A worker can only be chosen once.
Return the total cost to hire exactly k workers.

Example 1:
Input: costs = [17,12,10,2,7,2,11,20,8], k = 3, candidates = 4
Output: 11
Explanation: We hire 3 workers in total. The total cost is initially 0.
- In the first hiring round we choose the worker from [17,12,10,2,7,2,11,20,8]. The lowest cost is 2, and we break the tie by the smallest index, which is 3. The total cost = 0 + 2 = 2.
- In the second hiring round we choose the worker from [17,12,10,7,2,11,20,8]. The lowest cost is 2 (index 4). The total cost = 2 + 2 = 4.
- In the third hiring round we choose the worker from [17,12,10,7,11,20,8]. The lowest cost is 7 (index 3). The total cost = 4 + 7 = 11. Notice that the worker with index 3 was common in the first and last four workers.
The total hiring cost is 11.

Example 2:
Input: costs = [1,2,4,1], k = 3, candidates = 3
Output: 4
Explanation: We hire 3 workers in total. The total cost is initially 0.
- In the first hiring round we choose the worker from [1,2,4,1]. The lowest cost is 1, and we break the tie by the smallest index, which is 0. The total cost = 0 + 1 = 1. Notice that workers with index 1 and 2 are common in the first and last 3 workers.
- In the second hiring round we choose the worker from [2,4,1]. The lowest cost is 1 (index 2). The total cost = 1 + 1 = 2.
- In the third hiring round there are less than three candidates. We choose the worker from the remaining workers [2,4]. The lowest cost is 2 (index 0). The total cost = 2 + 2 = 4.
The total hiring cost is 4.

Constraints:
1 <= costs.length <= 105
1 <= costs[i] <= 105
1 <= k, candidates <= costs.length
=end

# @param {Integer[]} costs
# @param {Integer} k
# @param {Integer} candidates
# @return {Integer}
def total_cost(costs, k, candidates)
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_total_cost < Test::Unit::TestCase
  def test_
    assert_equal 11, total_cost([17, 12, 10, 2, 7, 2, 11, 20, 8], 3, 4)
    assert_equal 4, total_cost([1, 2, 4, 1], 3, 3)
  end
end
"
2466,count-ways-to-build-good-strings,"# frozen_string_literal: true

# 2466. Count Ways To Build Good Strings
# https://leetcode.com/problems/count-ways-to-build-good-strings
# Medium

=begin
Given the integers zero, one, low, and high, we can construct a string by starting with an empty string, and then at each step perform either of the following:

Append the character '0' zero times.
Append the character '1' one times.
This can be performed any number of times.

A good string is a string constructed by the above process having a length between low and high (inclusive).

Return the number of different good strings that can be constructed satisfying these properties. Since the answer can be large, return it modulo 10**9 + 7.

Example 1:
Input: low = 3, high = 3, zero = 1, one = 1
Output: 8
Explanation:
One possible valid good string is ""011"".
It can be constructed as follows: """" -> ""0"" -> ""01"" -> ""011"".
All binary strings from ""000"" to ""111"" are good strings in this example.

Example 2:
Input: low = 2, high = 3, zero = 1, one = 2
Output: 5
Explanation: The good strings are ""00"", ""11"", ""000"", ""110"", and ""011"".

Constraints:

1 <= low <= high <= 105
1 <= zero, one <= low
=end

# @param {Integer} low
# @param {Integer} high
# @param {Integer} zero
# @param {Integer} one
# @return {Integer}
MOD = 10**9 + 7

def count_good_strings(low, high, zero, one)
  dp = Array.new(high + 1, 0)
  dp[0] = 1
  (1..high).each { |i|
    dp[i] += dp[i - zero] % MOD if i >= zero
    dp[i] += dp[i - one] % MOD if i >= one
  }
  dp[low..high].sum % MOD
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_count_good_strings < Test::Unit::TestCase
  def test_
    assert_equal 8, count_good_strings(3, 3, 1, 1)
    assert_equal 5, count_good_strings(2, 3, 1, 2)
  end
end
"
2477,minimum-fuel-cost-to-report-to-the-capital,"# frozen_string_literal: true

# 2477. Minimum Fuel Cost to Report to the Capital
# https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital

# @param {Integer[][]} roads
# @param {Integer} seats
# @return {Integer}
def minimum_fuel_cost(roads, seats)
  hsh = Array.new roads.size + 1 do [] end
  roads.each do | (x, y) |
    hsh[x] << y
    hsh[y] << x
  end

  cost = 0
  l = -> n, p do
    c = hsh[n].reduce(1) { _2 == p ? (next _1) : _1 + l.(_2, n) }
    cost += (c + seats - 1) / seats
    c
  end

  hsh[0].each { l.(_1, 0) }

  cost
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_minimum_fuel_cost < Test::Unit::TestCase
  def test_
    assert_equal 3, minimum_fuel_cost([[0, 1], [0, 2], [0, 3]], 5)
    assert_equal 7, minimum_fuel_cost([[3, 1], [3, 2], [1, 0], [0, 4], [0, 5], [4, 6]], 2)
    assert_equal 0, minimum_fuel_cost([], 1)
  end
end
"
2483,minimum-penalty-for-a-shop,"# frozen_string_literal: true

# 2483. Minimum Penalty for a Shop
# Medium
# https://leetcode.com/problems/minimum-penalty-for-a-shop

=begin
You are given the customer visit log of a shop represented by a 0-indexed string customers consisting only of characters 'N' and 'Y':
* if the ith character is 'Y', it means that customers come at the ith hour
* whereas 'N' indicates that no customers come at the ith hour.
If the shop closes at the jth hour (0 <= j <= n), the penalty is calculated as follows:
* For every hour when the shop is open and no customers come, the penalty increases by 1.
* For every hour when the shop is closed and customers come, the penalty increases by 1.
Return the earliest hour at which the shop must be closed to incur a minimum penalty.
Note that if a shop closes at the jth hour, it means the shop is closed at the hour j.

Example 1:
Input: customers = ""YYNY""
Output: 2
Explanation:
- Closing the shop at the 0th hour incurs in 1+1+0+1 = 3 penalty.
- Closing the shop at the 1st hour incurs in 0+1+0+1 = 2 penalty.
- Closing the shop at the 2nd hour incurs in 0+0+0+1 = 1 penalty.
- Closing the shop at the 3rd hour incurs in 0+0+1+1 = 2 penalty.
- Closing the shop at the 4th hour incurs in 0+0+1+0 = 1 penalty.
Closing the shop at 2nd or 4th hour gives a minimum penalty. Since 2 is earlier, the optimal closing time is 2.

Example 2:
Input: customers = ""NNNNN""
Output: 0
Explanation: It is best to close the shop at the 0th hour as no customers arrive.

Example 3:
Input: customers = ""YYYY""
Output: 4
Explanation: It is best to close the shop at the 4th hour as customers arrive at each hour.

Constraints:
* 1 <= customers.length <= 105
* customers consists only of characters 'Y' and 'N'.
=end

# @param {String} customers
# @return {Integer}
def best_closing_time(customers)
  count = [0]
  customers.each_char { |customer| count << (count[-1] + (customer == ""Y"" ? 1 : 0)) }

  min = customers.length
  mindex = 0
  (0..customers.length).each do |i|
    score = (i - count[i]) + (count[-1] - count[i])
    if score < min
      min = score
      mindex = i
    end
  end

  mindex
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_best_closing_time < Test::Unit::TestCase
  def test_
    assert_equal 2, best_closing_time(""YYNY"")
    assert_equal 0, best_closing_time(""NNNNN"")
    assert_equal 4, best_closing_time(""YYYY"")
  end
end
"
2492,minimum-score-of-a-path-between-two-cities,"# frozen_string_literal: true

# 2492. Minimum Score of a Path Between Two Cities
# https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities

=begin

You are given a positive integer n representing n cities numbered from 1 to n. You are also given a 2D array roads where roads[i] = [ai, bi, distancei] indicates that there is a bidirectional road between cities ai and bi with a distance equal to distancei. The cities graph is not necessarily connected.

The score of a path between two cities is defined as the minimum distance of a road in this path.

Return the minimum possible score of a path between cities 1 and n.

### Note:

* A path is a sequence of roads between two cities.
* It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.
* The test cases are generated such that there is at least one path between 1 and n.

### Example 1:
Input: n = 4, roads = [[1,2,9],[2,3,6],[2,4,5],[1,4,7]]
Output: 5

### Example 2:
Input: n = 4, roads = [[1,2,2],[1,3,4],[3,4,7]]
Output: 2

### Constraints:

* 2 <= n <= 105
* 1 <= roads.length <= 105
* roads[i].length == 3
* 1 <= ai, bi <= n
* ai != bi
* 1 <= distancei <= 104
* There are no repeated edges.
* There is at least one path between 1 and n.

=end

# @param {Integer} n
# @param {Integer[][]} roads
# @return {Integer}
def min_score(n, roads)
  neighbors = Hash.new { |h, k| h[k] = [] }
  roads.each { |a, b, distance|
    neighbors[a] << [distance, b]
    neighbors[b] << [distance, a]
  }
  answer = Float::INFINITY
  queue = [1]
  visited = {}
  until queue.empty?
    node = queue.shift
    next if visited[node]
    visited[node] = true
    neighbors[node].each { |distance, neighbor|
      answer = [answer, distance].min
      queue << neighbor
    }
  end
  answer
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_min_score < Test::Unit::TestCase
  def test_
    assert_equal 5, min_score(4, [[1, 2, 9], [2, 3, 6], [2, 4, 5], [1, 4, 7]])
    assert_equal 2, min_score(4, [[1, 2, 2], [1, 3, 4], [3, 4, 7]])
  end
end
"
2542,maximum-subsequence-score,"# frozen_string_literal: true

# 2542. Maximum Subsequence Score
# https://leetcode.com/problems/maximum-subsequence-score
# Medium

=begin
You are given two 0-indexed integer arrays nums1 and nums2 of equal length n and a positive integer k. You must choose a subsequence of indices from nums1 of length k.

For chosen indices i0, i1, ..., ik - 1, your score is defined as:

The sum of the selected elements from nums1 multiplied with the minimum of the selected elements from nums2.
It can defined simply as: (nums1[i0] + nums1[i1] +...+ nums1[ik - 1]) * min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1]).
Return the maximum possible score.

A subsequence of indices of an array is a set that can be derived from the set {0, 1, ..., n-1} by deleting some or no elements.

Example 1:
Input: nums1 = [1,3,3,2], nums2 = [2,1,3,4], k = 3
Output: 12
Explanation:
The four possible subsequence scores are:
- We choose the indices 0, 1, and 2 with score = (1+3+3) * min(2,1,3) = 7.
- We choose the indices 0, 1, and 3 with score = (1+3+2) * min(2,1,4) = 6.
- We choose the indices 0, 2, and 3 with score = (1+3+2) * min(2,3,4) = 12.
- We choose the indices 1, 2, and 3 with score = (3+3+2) * min(1,3,4) = 8.
Therefore, we return the max score, which is 12.

Example 2:
Input: nums1 = [4,2,3,1,1], nums2 = [7,5,10,9,6], k = 1
Output: 30
Explanation:
Choosing index 2 is optimal: nums1[2] * nums2[2] = 3 * 10 = 30 is the maximum possible score.
=end

# @param {Integer[]} nums1
# @param {Integer[]} nums2
# @param {Integer} k
# @return {Integer}
def max_score(nums1, nums2, k)
  n = nums2.size
  inds_max_min = (0...n).to_a.sort_by { |i| -nums2[i] }

  sorted_array = []
  max = 0
  sum = 0
  inds_max_min.each do |index|
    next if sorted_array.size == k && sorted_array.last >= nums1[index]
    sum += nums1[index]
    insert_in_sort_array(sorted_array, nums1[index])
    sum -= sorted_array.pop if sorted_array.size > k
    max = [max, sum * nums2[index]].max if sorted_array.size == k
  end

  max
end

def insert_in_sort_array(array, insert_value)
  insert_at = array.bsearch_index { |value| (value <=> insert_value) <= 0 } || array.size
  array.insert(insert_at, insert_value)
end

# ********************#
#       TEST         #
# ********************#

require ""test/unit""
class Test_max_score < Test::Unit::TestCase
  def test_
    assert_equal 12, max_score([1, 3, 3, 2], [2, 1, 3, 4], 3)
    assert_equal 30, max_score([4, 2, 3, 1, 1], [7, 5, 10, 9, 6], 1)
  end
end
"
2551,put-marbles-in-bags,"# frozen_string_literal: true

# 2551. Put Marbles in Bags
# Hard
# https://leetcode.com/problems/put-marbles-in-bags

=begin
You have k bags. You are given a 0-indexed integer array weights where weights[i] is the weight of the ith marble. You are also given the integer k.
Divide the marbles into the k bags according to the following rules:
* No bag is empty.
* If the ith marble and jth marble are in a bag, then all marbles with an index between the ith and jth indices should also be in that same bag.
* If a bag consists of all the marbles with an index from i to j inclusively, then the cost of the bag is weights[i] + weights[j].
The score after distributing the marbles is the sum of the costs of all the k bags.
Return the difference between the maximum and minimum scores among marble distributions.

Example 1:
Input: weights = [1,3,5,1], k = 2
Output: 4
Explanation:
The distribution [1],[3,5,1] results in the minimal score of (1+1) + (3+1) = 6.
The distribution [1,3],[5,1], results in the maximal score of (1+3) + (5+1) = 10.
Thus, we return their difference 10 - 6 = 4.

Example 2:
Input: weights = [1, 3], k = 2
Output: 0
Explanation: The only distribution possible is [1],[3].
Since both the maximal and minimal score are the same, we return 0.

Constraints:
1 <= k <= weights.length <= 105
1 <= weights[i] <= 109
=end

# @param {Integer[]} weights
# @param {Integer} k
# @return {Integer}
def put_marbles(weights, k)
  a = weights.each_cons(2).map(&:sum).sort!
  a.last(k - 1).sum - a.first(k - 1).sum
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_put_marbles < Test::Unit::TestCase
  def test_
    assert_equal 4, put_marbles([1, 3, 5, 1], 2)
    assert_equal 0, put_marbles([1, 3], 2)
  end
end
"
2595,number-of-even-and-odd-bits,"# frozen_string_literal: true

# 2595. Number of Even and Odd Bits
# https://leetcode.com/problems/number-of-even-and-odd-bits

=begin

You are given a positive integer n.

Let even denote the number of even indices in the binary representation of n (0-indexed) with value 1.

Let odd denote the number of odd indices in the binary representation of n (0-indexed) with value 1.

Return an integer array answer where answer = [even, odd].

### Constraints:

* 1 <= n <= 1000

=end

# Runtime 89 ms, Beats 100%
# Memory 210.9 MB, Beats 100%
# @param {Integer} n
# @return {Integer[]}
def even_odd_bit(n)
  [(n & 341).digits(2).count(1), (n & 682).digits(2).count(1)]
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_even_odd_bit < Test::Unit::TestCase
  def test_
    assert_equal [2, 0], even_odd_bit(17)
    assert_equal [0, 1], even_odd_bit(2)
  end
end
"
2616,minimize-the-maximum-difference-of-pairs,"# frozen_string_literal: true

# 2616. Minimize the Maximum Difference of Pairs
# Medium
# https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs

=begin
You are given a 0-indexed integer array nums and an integer p. Find p pairs of indices of nums such that the maximum difference amongst all the pairs is minimized. Also, ensure no index appears more than once amongst the p pairs.
Note that for a pair of elements at the index i and j, the difference of this pair is |nums[i] - nums[j]|, where |x| represents the absolute value of x.
Return the minimum maximum difference among all p pairs. We define the maximum of an empty set to be zero.

Example 1:
Input: nums = [10,1,2,7,1,3], p = 2
Output: 1
Explanation: The first pair is formed from the indices 1 and 4, and the second pair is formed from the indices 2 and 5.
The maximum difference is max(|nums[1] - nums[4]|, |nums[2] - nums[5]|) = max(0, 1) = 1. Therefore, we return 1.

Example 2:
Input: nums = [4,2,1,2], p = 1
Output: 0
Explanation: Let the indices 1 and 3 form a pair. The difference of that pair is |2 - 2| = 0, which is the minimum we can attain.

Constraints:
* 1 <= nums.length <= 105
* 0 <= nums[i] <= 109
* 0 <= p <= (nums.length)/2
=end

# @param {Integer[]} nums
# @param {Integer} p
# @return {Integer}
def minimize_max(nums, pairs)
  nums.sort!
  diffs = []
  (1...nums.length).each do |i|
    diffs << nums[i] - nums[i - 1]
  end

  (0..diffs.max).bsearch do |n|
    i = 0
    pairs_copy = pairs
    while i < diffs.length && pairs_copy > 0
      if diffs[i] <= n
        i += 2
        pairs_copy -= 1
      else
        i += 1
      end
    end
    pairs_copy == 0
  end
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_length_of_longest_substring < Test::Unit::TestCase
  def test_
    assert_equal 1, minimize_max([10, 1, 2, 7, 1, 3], 2)
    assert_equal 0, minimize_max([4, 2, 1, 2], 1)
  end
end
"
2642,design-graph-with-shortest-path-calculator,"# frozen_string_literal: true

# 2642. Design Graph With Shortest Path Calculator
# Hard
# https://leetcode.com/problems/design-graph-with-shortest-path-calculator

=begin
There is a directed weighted graph that consists of n nodes numbered from 0 to n - 1. The edges of the graph are initially represented by the given array edges where edges[i] = [fromi, toi, edgeCosti] meaning that there is an edge from fromi to toi with the cost edgeCosti.

Implement the Graph class:
* Graph(int n, int[][] edges) initializes the object with n nodes and the given edges.
* addEdge(int[] edge) adds an edge to the list of edges where edge = [from, to, edgeCost]. It is guaranteed that there is no edge between the two nodes before adding this one.
* int shortestPath(int node1, int node2) returns the minimum cost of a path from node1 to node2. If no path exists, return -1. The cost of a path is the sum of the costs of the edges in the path.

Example 1:
Input
[""Graph"", ""shortestPath"", ""shortestPath"", ""addEdge"", ""shortestPath""]
[[4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]], [3, 2], [0, 3], [[1, 3, 4]], [0, 3]]
Output
[null, 6, -1, null, 6]

Explanation
Graph g = new Graph(4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]);
g.shortestPath(3, 2); // return 6. The shortest path from 3 to 2 in the first diagram above is 3 -> 0 -> 1 -> 2 with a total cost of 3 + 2 + 1 = 6.
g.shortestPath(0, 3); // return -1. There is no path from 0 to 3.
g.addEdge([1, 3, 4]); // We add an edge from node 1 to node 3, and we get the second diagram above.
g.shortestPath(0, 3); // return 6. The shortest path from 0 to 3 now is 0 -> 1 -> 3 with a total cost of 2 + 4 = 6.


Constraints:
* 1 <= n <= 100
* 0 <= edges.length <= n * (n - 1)
* edges[i].length == edge.length == 3
* 0 <= fromi, toi, from, to, node1, node2 <= n - 1
* 1 <= edgeCosti, edgeCost <= 106
* There are no repeated edges and no self-loops in the graph at any point.
* At most 100 calls will be made for addEdge.
* At most 100 calls will be made for shortestPath.
=end

class Graph
=begin
    :type n: Integer
    :type edges: Integer[][]
=end
  def initialize(n, edges)
    @adjacent_list = Hash.new { |h, k| h[k] = [] }
    @visited = Array.new(n, false)
    @n = n
    edges.each do |edge|
      @adjacent_list[edge[0]] << [edge[1], edge[2]]
    end
  end


=begin
    :type edge: Integer[]
    :rtype: Void
=end
  def add_edge(edge)
    @adjacent_list[edge[0]] << [edge[1], edge[2]]
  end


=begin
    :type node1: Integer
    :type node2: Integer
    :rtype: Integer
=end
  def shortest_path(node1, node2)
    Array.new

    cost_for_node = Array.new(@n, Float::INFINITY)
    cost_for_node[node1] = 0
    pq = [[0, node1]]

    while !pq.empty? do
      curr_cost, node = pq.pop

      return curr_cost if node == node2

      neighbors = @adjacent_list[node]

      for nei, cost in neighbors do
        new_cost = curr_cost + cost

        if new_cost < cost_for_node[nei]
          cost_for_node[nei] = new_cost
          index = pq.bsearch_index { |x| x[0] < new_cost } || pq.size
          pq.insert(index, [new_cost, nei])
        end
      end

    end
    -1
  end
end

# Your Graph object will be instantiated and called as such:
# obj = Graph.new(n, edges)
# obj.add_edge(edge)
# param_2 = obj.shortest_path(node1, node2)
"
2696,minimum-string-length-after-removing-substrings,"# frozen_string_literal: true

# 2696. Minimum String Length After Removing Substrings
# https://leetcode.com/problems/minimum-string-length-after-removing-substrings
# Easy

=begin
You are given a string s consisting only of uppercase English letters.

You can apply some operations to this string where, in one operation, you can remove any occurrence of one of the substrings ""AB"" or ""CD"" from s.

Return the minimum possible length of the resulting string that you can obtain.

Note that the string concatenates after removing the substring and could produce new ""AB"" or ""CD"" substrings.

Example 1:
Input: s = ""ABFCACDB""
Output: 2
Explanation: We can do the following operations:
- Remove the substring ""ABFCACDB"", so s = ""FCACDB"".
- Remove the substring ""FCACDB"", so s = ""FCAB"".
- Remove the substring ""FCAB"", so s = ""FC"".
So the resulting length of the string is 2.
It can be shown that it is the minimum length that we can obtain.

Example 2:
Input: s = ""ACBBD""
Output: 5
Explanation: We cannot do any operations on the string so the length remains the same.

Constraints:
1 <= s.length <= 100
s consists only of uppercase English letters.
=end

# @param {String} s
# @return {Integer}
def min_length(s)
  arr = []
  s.chars.each do |c|
    if c == ""B"" && arr.last == ""A""
      arr.pop
    elsif c == ""D"" && arr.last == ""C""
      arr.pop
    else
      arr.push(c)
    end
  end
  arr.size
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_min_length < Test::Unit::TestCase
  def test_
    assert_equal 2, min_length(""ABFCACDB"")
    assert_equal 5, min_length(""ACBBD"")
  end
end
"
2697,lexicographically-smallest-palindrome,"# frozen_string_literal: true

# 2697. Lexicographically Smallest Palindrome
# https://leetcode.com/problems/lexicographically-smallest-palindrome
# Easy

=begin
You are given a string s consisting of lowercase English letters, and you are allowed to perform operations on it. In one operation, you can replace a character in s with another lowercase English letter.

Your task is to make s a palindrome with the minimum number of operations possible. If there are multiple palindromes that can be made using the minimum number of operations, make the lexicographically smallest one.

A string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b.

Return the resulting palindrome string.

Example 1:
Input: s = ""egcfe""
Output: ""efcfe""
Explanation: The minimum number of operations to make ""egcfe"" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is ""efcfe"", by changing 'g'.

Example 2:
Input: s = ""abcd""
Output: ""abba""
Explanation: The minimum number of operations to make ""abcd"" a palindrome is 2, and the lexicographically smallest palindrome string we can get by modifying two characters is ""abba"".

Example 3:
Input: s = ""seven""
Output: ""neven""
Explanation: The minimum number of operations to make ""seven"" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is ""neven"".

Constraints:
1 <= s.length <= 1000
s consists of only lowercase English letters.
=end

# @param {String} s
# @return {String}
def make_smallest_palindrome(s)
  str = s.dup
  front = 0
  back = str.length - 1
  while front <= str.size() / 2
    str[front] = [str[front], str[back]].min
    str[back] = str[front]
    front += 1
    back -= 1
  end
  str
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_make_smallest_palindrome < Test::Unit::TestCase
  def test_
    assert_equal ""efcfe"", make_smallest_palindrome(""egcfe"")
    assert_equal ""abba"", make_smallest_palindrome(""abcd"")
    assert_equal ""neven"", make_smallest_palindrome(""seven"")
  end
end
"
2706,buy-two-chocolates,"# frozen_string_literal: true

# 2706. Buy Two Chocolates
# Easy
# https://leetcode.com/problems/buy-two-chocolates

=begin
You are given an integer array prices representing the prices of various chocolates in a store. You are also given a single integer money, which represents your initial amount of money.
You must buy exactly two chocolates in such a way that you still have some non-negative leftover money. You would like to minimize the sum of the prices of the two chocolates you buy.
Return the amount of money you will have leftover after buying the two chocolates. If there is no way for you to buy two chocolates without ending up in debt, return money. Note that the leftover must be non-negative.

Example 1:
Input: prices = [1,2,2], money = 3
Output: 0
Explanation: Purchase the chocolates priced at 1 and 2 units respectively. You will have 3 - 3 = 0 units of money afterwards. Thus, we return 0.

Example 2:
Input: prices = [3,2,3], money = 3
Output: 3
Explanation: You cannot buy 2 chocolates without going in debt, so we return 3.

Constraints:
2 <= prices.length <= 50
1 <= prices[i] <= 100
1 <= money <= 100
=end

# @param {Integer[]} prices
# @param {Integer} money
# @return {Integer}
def buy_choco(prices, money)
  prices.sort!

  if prices[0] + prices[1] <= money
    return money - prices[0] - prices[1]
  end

  money
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_buy_choco < Test::Unit::TestCase
  def test_
    assert_equal 0, buy_choco([1, 2, 2], 3)
    assert_equal 3, buy_choco([3, 2, 3], 3)
  end
end
"
2707,extra-characters-in-a-string,"# frozen_string_literal: true

# 2707. Extra Characters in a String
# Medium
# https://leetcode.com/problems/extra-characters-in-a-string

=begin
You are given a 0-indexed string s and a dictionary of words dictionary. You have to break s into one or more non-overlapping substrings such that each substring is present in dictionary. There may be some extra characters in s which are not present in any of the substrings.
Return the minimum number of extra characters left over if you break up s optimally.

Example 1:
Input: s = ""leetscode"", dictionary = [""leet"",""code"",""leetcode""]
Output: 1
Explanation: We can break s in two substrings: ""leet"" from index 0 to 3 and ""code"" from index 5 to 8. There is only 1 unused character (at index 4), so we return 1.

Example 2:
Input: s = ""sayhelloworld"", dictionary = [""hello"",""world""]
Output: 3
Explanation: We can break s in two substrings: ""hello"" from index 3 to 7 and ""world"" from index 8 to 12. The characters at indices 0, 1, 2 are not used in any substring and thus are considered as extra characters. Hence, we return 3.


Constraints:
1 <= s.length <= 50
1 <= dictionary.length <= 50
1 <= dictionary[i].length <= 50
dictionary[i] and s consists of only lowercase English letters
dictionary contains distinct words
=end

# @param {String} s
# @param {String[]} dictionary
# @return {Integer}
def min_extra_char(s, dictionary)
  d = dictionary.to_set
  n = s.size
  dp = Array.new(n + 1, 0)
  (0...n).reverse_each do |i|
    dp[i] = 1 + dp[i + 1]
    (i...n).each do |j|
      curr = s[i..j]
      if d.include?(curr)
        dp[i] = [dp[i], dp[j + 1]].min
      end
    end
  end
  dp[0]
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_min_extra_char < Test::Unit::TestCase
  def test_
    assert_equal 1, min_extra_char(""leetscode"", [""leet"", ""code"", ""leetcode""])
    assert_equal 3, min_extra_char(""sayhelloworld"", [""hello"", ""world""])
  end
end
"
2742,painting-the-walls,"# frozen_string_literal: true

# 2742. Painting the Walls
# Hard
# https://leetcode.com/problems/painting-the-walls

=begin
You are given two 0-indexed integer arrays, cost and time, of size n representing the costs and the time taken to paint n different walls respectively. There are two painters available:

A paid painter that paints the ith wall in time[i] units of time and takes cost[i] units of money.
A free painter that paints any wall in 1 unit of time at a cost of 0. But the free painter can only be used if the paid painter is already occupied.
Return the minimum amount of money required to paint the n walls.

Example 1:
Input: cost = [1,2,3,2], time = [1,2,3,2]
Output: 3
Explanation: The walls at index 0 and 1 will be painted by the paid painter, and it will take 3 units of time; meanwhile, the free painter will paint the walls at index 2 and 3, free of cost in 2 units of time. Thus, the total cost is 1 + 2 = 3.

Example 2:
Input: cost = [2,3,4,2], time = [1,1,1,1]
Output: 4
Explanation: The walls at index 0 and 3 will be painted by the paid painter, and it will take 2 units of time; meanwhile, the free painter will paint the walls at index 1 and 2, free of cost in 2 units of time. Thus, the total cost is 2 + 2 = 4.

Constraints:
1 <= cost.length <= 500
cost.length == time.length
1 <= cost[i] <= 106
1 <= time[i] <= 500
=end

# @param {Integer[]} cost
# @param {Integer[]} time
# @return {Integer}
def paint_walls(cost, time)
  n = cost.length
  dp = Array.new(n + 1, Float::INFINITY)
  dp[0] = 0

  (0...n).each do |i|
    n.downto(1) do |j|
      dp[j] = [dp[j], dp[[j - time[i] - 1, 0].max] + cost[i]].min
    end
  end

  dp[n]
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_paint_walls < Test::Unit::TestCase
  def test_
    assert_equal 3, paint_walls([1, 2, 3, 2], [1, 2, 3, 2])
    assert_equal 4, paint_walls([2, 3, 4, 2], [1, 1, 1, 1])
  end
end
"
2785,sort-vowels-in-a-string,"# frozen_string_literal: true

# 2785. Sort Vowels in a String
# Medium
# https://leetcode.com/problems/sort-vowels-in-a-string

=begin
Given a 0-indexed string s, permute s to get a new string t such that:
* All consonants remain in their original places. More formally, if there is an index i with 0 <= i < s.length such that s[i] is a consonant, then t[i] = s[i].
* The vowels must be sorted in the nondecreasing order of their ASCII values. More formally, for pairs of indices i, j with 0 <= i < j < s.length such that s[i] and s[j] are vowels, then t[i] must not have a higher ASCII value than t[j].
Return the resulting string.
The vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in lowercase or uppercase. Consonants comprise all letters that are not vowels.

Example 1:
Input: s = ""lEetcOde""
Output: ""lEOtcede""
Explanation: 'E', 'O', and 'e' are the vowels in s; 'l', 't', 'c', and 'd' are all consonants. The vowels are sorted according to their ASCII values, and the consonants remain in the same places.

Example 2:
Input: s = ""lYmpH""
Output: ""lYmpH""
Explanation: There are no vowels in s (all characters in s are consonants), so we return ""lYmpH"".

Constraints:
* 1 <= s.length <= 105
* s consists only of letters of the English alphabet in uppercase and lowercase.
=end

# @param {String} s
# @return {String}
def sort_vowels(s)
  ans = s.dup
  vowels = []
  vs = Array[""A"", ""E"", ""I"", ""O"", ""U"", ""a"", ""e"", ""i"", ""o"", ""u""]

  ans.each_char { |char| vowels << char if vs.include?(char) }
  vowels.sort!

  ans.each_char.with_index do |char, i|
    if vs.include?(char)
      ans[i] = vowels.shift
    end
  end

  ans
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_sort_vowels < Test::Unit::TestCase
  def test_
    assert_equal ""lEOtcede"", sort_vowels(""lEetcOde"")
    assert_equal ""lYmpH"", sort_vowels(""lYmpH"")
  end
end
"
2842,difference-between-ones-and-zeros-in-row-and-column,"# frozen_string_literal: true

# 2482. Difference Between Ones and Zeros in Row and Column
# Medium
# https://leetcode.com/problems/difference-between-ones-and-zeros-in-row-and-column

=begin
You are given a 0-indexed m x n binary matrix grid.
A 0-indexed m x n difference matrix diff is created with the following procedure:
* Let the number of ones in the ith row be onesRowi.
* Let the number of ones in the jth column be onesColj.
* Let the number of zeros in the ith row be zerosRowi.
* Let the number of zeros in the jth column be zerosColj.
* diff[i][j] = onesRowi + onesColj - zerosRowi - zerosColj
Return the difference matrix diff.

Example 1:
Input: grid = [[0,1,1],[1,0,1],[0,0,1]]
Output: [[0,0,4],[0,0,4],[-2,-2,2]]
Explanation:
- diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0 = 2 + 1 - 1 - 2 = 0
- diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1 = 2 + 1 - 1 - 2 = 0
- diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2 = 2 + 3 - 1 - 0 = 4
- diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0 = 2 + 1 - 1 - 2 = 0
- diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1 = 2 + 1 - 1 - 2 = 0
- diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2 = 2 + 3 - 1 - 0 = 4
- diff[2][0] = onesRow2 + onesCol0 - zerosRow2 - zerosCol0 = 1 + 1 - 2 - 2 = -2
- diff[2][1] = onesRow2 + onesCol1 - zerosRow2 - zerosCol1 = 1 + 1 - 2 - 2 = -2
- diff[2][2] = onesRow2 + onesCol2 - zerosRow2 - zerosCol2 = 1 + 3 - 2 - 0 = 2

Example 2:
Input: grid = [[1,1,1],[1,1,1]]
Output: [[5,5,5],[5,5,5]]
Explanation:
- diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0 = 3 + 2 - 0 - 0 = 5
- diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1 = 3 + 2 - 0 - 0 = 5
- diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2 = 3 + 2 - 0 - 0 = 5
- diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0 = 3 + 2 - 0 - 0 = 5
- diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1 = 3 + 2 - 0 - 0 = 5
- diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2 = 3 + 2 - 0 - 0 = 5

Constraints:
m == grid.length
n == grid[i].length
1 <= m, n <= 105
1 <= m * n <= 105
grid[i][j] is either 0 or 1.
=end

# @param {Integer[][]} grid
# @return {Integer[][]}
def ones_minus_zeros(grid)
  grid.transpose.map(&:sum).yield_self do |b|
    grid.map { 2 * _1.sum - grid.size - b.size }.map { |s| b.map { 2 * _1 + s } }
  end
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_ones_minus_zeros < Test::Unit::TestCase
  def test_
    assert_equal [[0, 0, 4], [0, 0, 4], [-2, -2, 2]], ones_minus_zeros([[0, 1, 1], [1, 0, 1], [0, 0, 1]])
    assert_equal [[5, 5, 5], [5, 5, 5]], ones_minus_zeros([[1, 1, 1], [1, 1, 1]])
  end
end
"
2849,determine-if-a-cell-is-reachable-at-a-given-time,"# frozen_string_literal: true

# 2849. Determine if a Cell Is Reachable at a Given Time
# Medium
# https://leetcode.com/problems/determine-if-a-cell-is-reachable-at-a-given-time

=begin
You are given four integers sx, sy, fx, fy, and a non-negative integer t.
In an infinite 2D grid, you start at the cell (sx, sy). Each second, you must move to any of its adjacent cells.
Return true if you can reach cell (fx, fy) after exactly t seconds, or false otherwise.
A cell's adjacent cells are the 8 cells around it that share at least one corner with it. You can visit the same cell several times.

Example 1:
Input: sx = 2, sy = 4, fx = 7, fy = 7, t = 6
Output: true
Explanation: Starting at cell (2, 4), we can reach cell (7, 7) in exactly 6 seconds by going through the cells depicted in the picture above.

Example 2:
Input: sx = 3, sy = 1, fx = 7, fy = 3, t = 3
Output: false
Explanation: Starting at cell (3, 1), it takes at least 4 seconds to reach cell (7, 3) by going through the cells depicted in the picture above. Hence, we cannot reach cell (7, 3) at the third second.

Constraints:
* 1 <= sx, sy, fx, fy <= 109
* 0 <= t <= 109
=end

# @param {Integer} sx
# @param {Integer} sy
# @param {Integer} fx
# @param {Integer} fy
# @param {Integer} t
# @return {Boolean}
def is_reachable_at_time(sx, sy, fx, fy, t)
  return false if t == 1 && sx == fx && sy == fy

  (sx - fx).abs <= t && (sy - fy).abs <= t
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_is_reachable_at_time < Test::Unit::TestCase
  def test_
    assert_equal true, is_reachable_at_time(2, 4, 7, 7, 6)
    assert_equal false, is_reachable_at_time(3, 1, 7, 3, 3)
  end
end
"
2966,divide-array-into-arrays-with-max-difference,"# frozen_string_literal: true

# 2966. Divide Array Into Arrays With Max Difference
# Medium
# https://leetcode.com/problems/divide-array-into-arrays-with-max-difference

=begin
You are given an integer array nums of size n and a positive integer k.
Divide the array into one or more arrays of size 3 satisfying the following conditions:
* Each element of nums should be in exactly one array.
* The difference between any two elements in one array is less than or equal to k.
Return a 2D array containing all the arrays. If it is impossible to satisfy the conditions, return an empty array. And if there are multiple answers, return any of them.

Example 1:
Input: nums = [1,3,4,8,7,9,3,5,1], k = 2
Output: [[1,1,3],[3,4,5],[7,8,9]]
Explanation: We can divide the array into the following arrays: [1,1,3], [3,4,5] and [7,8,9].
The difference between any two elements in each array is less than or equal to 2.
Note that the order of elements is not important.

Example 2:
Input: nums = [1,3,3,2,7,3], k = 3
Output: []
Explanation: It is not possible to divide the array satisfying all the conditions.

Constraints:
* n == nums.length
* 1 <= n <= 105
* n is a multiple of 3.
* 1 <= nums[i] <= 105
* 1 <= k <= 105
=end

# @param {Integer[]} nums
# @param {Integer} k
# @return {Integer[][]}
def divide_array(nums, k)
  possible_array = []
  nums.sort!
  nums.each_slice(3) do |n|
    return [] if n[2] - n[0] > k
    possible_array << n
  end
  possible_array
end

# **************** #
#       TEST       #
# **************** #

require ""test/unit""
class Test_divide_array < Test::Unit::TestCase
  def test_
    assert_equal [[1, 1, 3], [3, 4, 5], [7, 8, 9]], divide_array([1, 3, 4, 8, 7, 9, 3, 5, 1], 2)
    assert_equal [], divide_array([1, 3, 3, 2, 7, 3], 3)
  end
end
"
